<html>
<head>
<title>autocommand.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
autocommand.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2014-2015 Nathan West</span>
<span class="s0">#</span>
<span class="s0"># This file is part of autocommand.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is free software: you can redistribute it and/or modify</span>
<span class="s0"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="s0"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="s0"># (at your option) any later version.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is distributed in the hope that it will be useful,</span>
<span class="s0"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s0"># GNU Lesser General Public License for more details.</span>
<span class="s0">#</span>
<span class="s0"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="s0"># along with autocommand.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">autoparse </span><span class="s2">import </span><span class="s1">autoparse</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">automain </span><span class="s2">import </span><span class="s1">automain</span>
<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">autoasync </span><span class="s2">import </span><span class="s1">autoasync</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">autocommand</span><span class="s3">(</span>
        <span class="s1">module</span><span class="s3">, *,</span>
        <span class="s1">description</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">epilog</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">add_nos</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">parser</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">loop</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">forever</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">pass_loop</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'autocommand requires a module name argument'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">autocommand_decorator</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
        <span class="s0"># Step 1: if requested, run it all in an asyncio event loop. autoasync</span>
        <span class="s0"># patches the __signature__ of the decorated function, so that in the</span>
        <span class="s0"># event that pass_loop is True, the `loop` parameter of the original</span>
        <span class="s0"># function will *not* be interpreted as a command-line argument by</span>
        <span class="s0"># autoparse</span>
        <span class="s2">if </span><span class="s1">loop </span><span class="s2">is not None or </span><span class="s1">forever </span><span class="s2">or </span><span class="s1">pass_loop</span><span class="s3">:</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">autoasync</span><span class="s3">(</span>
                <span class="s1">func</span><span class="s3">,</span>
                <span class="s1">loop</span><span class="s3">=</span><span class="s2">None if </span><span class="s1">loop </span><span class="s2">is True else </span><span class="s1">loop</span><span class="s3">,</span>
                <span class="s1">pass_loop</span><span class="s3">=</span><span class="s1">pass_loop</span><span class="s3">,</span>
                <span class="s1">forever</span><span class="s3">=</span><span class="s1">forever</span><span class="s3">)</span>

        <span class="s0"># Step 2: create parser. We do this second so that the arguments are</span>
        <span class="s0"># parsed and passed *before* entering the asyncio event loop, if it</span>
        <span class="s0"># exists. This simplifies the stack trace and ensures errors are</span>
        <span class="s0"># reported earlier. It also ensures that errors raised during parsing &amp;</span>
        <span class="s0"># passing are still raised if `forever` is True.</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">autoparse</span><span class="s3">(</span>
            <span class="s1">func</span><span class="s3">,</span>
            <span class="s1">description</span><span class="s3">=</span><span class="s1">description</span><span class="s3">,</span>
            <span class="s1">epilog</span><span class="s3">=</span><span class="s1">epilog</span><span class="s3">,</span>
            <span class="s1">add_nos</span><span class="s3">=</span><span class="s1">add_nos</span><span class="s3">,</span>
            <span class="s1">parser</span><span class="s3">=</span><span class="s1">parser</span><span class="s3">)</span>

        <span class="s0"># Step 3: call the function automatically if __name__ == '__main__' (or</span>
        <span class="s0"># if True was provided)</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">automain</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)(</span><span class="s1">func</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">func</span>

    <span class="s2">return </span><span class="s1">autocommand_decorator</span>
</pre>
</body>
</html>