<html>
<head>
<title>autoasync.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
autoasync.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2014-2015 Nathan West</span>
<span class="s0">#</span>
<span class="s0"># This file is part of autocommand.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is free software: you can redistribute it and/or modify</span>
<span class="s0"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="s0"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="s0"># (at your option) any later version.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is distributed in the hope that it will be useful,</span>
<span class="s0"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s0"># GNU Lesser General Public License for more details.</span>
<span class="s0">#</span>
<span class="s0"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="s0"># along with autocommand.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="s2">from </span><span class="s1">asyncio </span><span class="s2">import </span><span class="s1">get_event_loop</span><span class="s3">, </span><span class="s1">iscoroutine</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">signature</span>


<span class="s2">async def </span><span class="s1">_run_forever_coro</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">):</span>
    <span class="s4">''' 
    This helper function launches an async main function that was tagged with 
    forever=True. There are two possibilities: 
 
    - The function is a normal function, which handles initializing the event 
      loop, which is then run forever 
    - The function is a coroutine, which needs to be scheduled in the event 
      loop, which is then run forever 
      - There is also the possibility that the function is a normal function 
        wrapping a coroutine function 
 
    The function is therefore called unconditionally and scheduled in the event 
    loop if the return value is a coroutine object. 
 
    The reason this is a separate function is to make absolutely sure that all 
    the objects created are garbage collected after all is said and done; we 
    do this to ensure that any exceptions raised in the tasks are collected 
    ASAP. 
    '''</span>

    <span class="s0"># Personal note: I consider this an antipattern, as it relies on the use of</span>
    <span class="s0"># unowned resources. The setup function dumps some stuff into the event</span>
    <span class="s0"># loop where it just whirls in the ether without a well defined owner or</span>
    <span class="s0"># lifetime. For this reason, there's a good chance I'll remove the</span>
    <span class="s0"># forever=True feature from autoasync at some point in the future.</span>
    <span class="s1">thing </span><span class="s3">= </span><span class="s1">coro</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">iscoroutine</span><span class="s3">(</span><span class="s1">thing</span><span class="s3">):</span>
        <span class="s2">await </span><span class="s1">thing</span>


<span class="s2">def </span><span class="s1">autoasync</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">loop</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">forever</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">pass_loop</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s4">''' 
    Convert an asyncio coroutine into a function which, when called, is 
    evaluted in an event loop, and the return value returned. This is intented 
    to make it easy to write entry points into asyncio coroutines, which 
    otherwise need to be explictly evaluted with an event loop's 
    run_until_complete. 
 
    If `loop` is given, it is used as the event loop to run the coro in. If it 
    is None (the default), the loop is retreived using asyncio.get_event_loop. 
    This call is defered until the decorated function is called, so that 
    callers can install custom event loops or event loop policies after 
    @autoasync is applied. 
 
    If `forever` is True, the loop is run forever after the decorated coroutine 
    is finished. Use this for servers created with asyncio.start_server and the 
    like. 
 
    If `pass_loop` is True, the event loop object is passed into the coroutine 
    as the `loop` kwarg when the wrapper function is called. In this case, the 
    wrapper function's __signature__ is updated to remove this parameter, so 
    that autoparse can still be used on it without generating a parameter for 
    `loop`. 
 
    This coroutine can be called with ( @autoasync(...) ) or without 
    ( @autoasync ) arguments. 
 
    Examples: 
 
    @autoasync 
    def get_file(host, port): 
        reader, writer = yield from asyncio.open_connection(host, port) 
        data = reader.read() 
        sys.stdout.write(data.decode()) 
 
    get_file(host, port) 
 
    @autoasync(forever=True, pass_loop=True) 
    def server(host, port, loop): 
        yield_from loop.create_server(Proto, host, port) 
 
    server('localhost', 8899) 
 
    '''</span>
    <span class="s2">if </span><span class="s1">coro </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return lambda </span><span class="s1">c</span><span class="s3">: </span><span class="s1">autoasync</span><span class="s3">(</span>
            <span class="s1">c</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">=</span><span class="s1">loop</span><span class="s3">,</span>
            <span class="s1">forever</span><span class="s3">=</span><span class="s1">forever</span><span class="s3">,</span>
            <span class="s1">pass_loop</span><span class="s3">=</span><span class="s1">pass_loop</span><span class="s3">)</span>

    <span class="s0"># The old and new signatures are required to correctly bind the loop</span>
    <span class="s0"># parameter in 100% of cases, even if it's a positional parameter.</span>
    <span class="s0"># NOTE: A future release will probably require the loop parameter to be</span>
    <span class="s0"># a kwonly parameter.</span>
    <span class="s2">if </span><span class="s1">pass_loop</span><span class="s3">:</span>
        <span class="s1">old_sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">)</span>
        <span class="s1">new_sig </span><span class="s3">= </span><span class="s1">old_sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">parameters</span><span class="s3">=(</span>
            <span class="s1">param </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">param </span><span class="s2">in </span><span class="s1">old_sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s5">&quot;loop&quot;</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">wraps</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">autoasync_wrapper</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s0"># Defer the call to get_event_loop so that, if a custom policy is</span>
        <span class="s0"># installed after the autoasync decorator, it is respected at call time</span>
        <span class="s1">local_loop </span><span class="s3">= </span><span class="s1">get_event_loop</span><span class="s3">() </span><span class="s2">if </span><span class="s1">loop </span><span class="s2">is None else </span><span class="s1">loop</span>

        <span class="s0"># Inject the 'loop' argument. We have to use this signature binding to</span>
        <span class="s0"># ensure it's injected in the correct place (positional, keyword, etc)</span>
        <span class="s2">if </span><span class="s1">pass_loop</span><span class="s3">:</span>
            <span class="s1">bound_args </span><span class="s3">= </span><span class="s1">old_sig</span><span class="s3">.</span><span class="s1">bind_partial</span><span class="s3">()</span>
            <span class="s1">bound_args</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span>
                <span class="s1">loop</span><span class="s3">=</span><span class="s1">local_loop</span><span class="s3">,</span>
                <span class="s3">**</span><span class="s1">new_sig</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">).</span><span class="s1">arguments</span><span class="s3">)</span>
            <span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs </span><span class="s3">= </span><span class="s1">bound_args</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">bound_args</span><span class="s3">.</span><span class="s1">kwargs</span>

        <span class="s2">if </span><span class="s1">forever</span><span class="s3">:</span>
            <span class="s1">local_loop</span><span class="s3">.</span><span class="s1">create_task</span><span class="s3">(</span><span class="s1">_run_forever_coro</span><span class="s3">(</span>
                <span class="s1">coro</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">local_loop</span>
            <span class="s3">))</span>
            <span class="s1">local_loop</span><span class="s3">.</span><span class="s1">run_forever</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">local_loop</span><span class="s3">.</span><span class="s1">run_until_complete</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">))</span>

    <span class="s0"># Attach the updated signature. This allows 'pass_loop' to be used with</span>
    <span class="s0"># autoparse</span>
    <span class="s2">if </span><span class="s1">pass_loop</span><span class="s3">:</span>
        <span class="s1">autoasync_wrapper</span><span class="s3">.</span><span class="s1">__signature__ </span><span class="s3">= </span><span class="s1">new_sig</span>

    <span class="s2">return </span><span class="s1">autoasync_wrapper</span>
</pre>
</body>
</html>