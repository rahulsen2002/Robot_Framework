<html>
<head>
<title>autoparse.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
autoparse.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2014-2015 Nathan West</span>
<span class="s0">#</span>
<span class="s0"># This file is part of autocommand.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is free software: you can redistribute it and/or modify</span>
<span class="s0"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="s0"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="s0"># (at your option) any later version.</span>
<span class="s0">#</span>
<span class="s0"># autocommand is distributed in the hope that it will be useful,</span>
<span class="s0"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s0"># GNU Lesser General Public License for more details.</span>
<span class="s0">#</span>
<span class="s0"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="s0"># along with autocommand.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">re </span><span class="s2">import </span><span class="s1">compile </span><span class="s2">as </span><span class="s1">compile_regex</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">getdoc</span><span class="s3">, </span><span class="s1">Parameter</span>
<span class="s2">from </span><span class="s1">argparse </span><span class="s2">import </span><span class="s1">ArgumentParser</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">IOBase</span>
<span class="s2">from </span><span class="s1">autocommand</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">AutocommandError</span>


<span class="s1">_empty </span><span class="s3">= </span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span>


<span class="s2">class </span><span class="s1">AnnotationError</span><span class="s3">(</span><span class="s1">AutocommandError</span><span class="s3">):</span>
    <span class="s4">'''Annotation error: annotation must be a string, type, or tuple of both'''</span>


<span class="s2">class </span><span class="s1">PositionalArgError</span><span class="s3">(</span><span class="s1">AutocommandError</span><span class="s3">):</span>
    <span class="s4">''' 
    Postional Arg Error: autocommand can't handle postional-only parameters 
    '''</span>


<span class="s2">class </span><span class="s1">KWArgError</span><span class="s3">(</span><span class="s1">AutocommandError</span><span class="s3">):</span>
    <span class="s4">'''kwarg Error: autocommand can't handle a **kwargs parameter'''</span>


<span class="s2">class </span><span class="s1">DocstringError</span><span class="s3">(</span><span class="s1">AutocommandError</span><span class="s3">):</span>
    <span class="s4">'''Docstring error'''</span>


<span class="s2">class </span><span class="s1">TooManySplitsError</span><span class="s3">(</span><span class="s1">DocstringError</span><span class="s3">):</span>
    <span class="s4">''' 
    The docstring had too many ---- section splits. Currently we only support 
    using up to a single split, to split the docstring into description and 
    epilog parts. 
    '''</span>


<span class="s2">def </span><span class="s1">_get_type_description</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">):</span>
    <span class="s4">''' 
    Given an annotation, return the (type, description) for the parameter. 
    If you provide an annotation that is somehow both a string and a callable, 
    the behavior is undefined. 
    '''</span>
    <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is </span><span class="s1">_empty</span><span class="s3">:</span>
        <span class="s2">return None</span><span class="s3">, </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">annotation</span><span class="s3">, </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">return None</span><span class="s3">, </span><span class="s1">annotation</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">arg1</span><span class="s3">, </span><span class="s1">arg2 </span><span class="s3">= </span><span class="s1">annotation</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AnnotationError</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">arg1</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg2</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">arg2</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">arg2</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">arg2</span><span class="s3">, </span><span class="s1">arg1</span>

    <span class="s2">raise </span><span class="s1">AnnotationError</span><span class="s3">(</span><span class="s1">annotation</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_add_arguments</span><span class="s3">(</span><span class="s1">param</span><span class="s3">, </span><span class="s1">parser</span><span class="s3">, </span><span class="s1">used_char_args</span><span class="s3">, </span><span class="s1">add_nos</span><span class="s3">):</span>
    <span class="s4">''' 
    Add the argument(s) to an ArgumentParser (using add_argument) for a given 
    parameter. used_char_args is the set of -short options currently already in 
    use, and is updated (if necessary) by this function. If add_nos is True, 
    this will also add an inverse switch for all boolean options. For 
    instance, for the boolean parameter &quot;verbose&quot;, this will create --verbose 
    and --no-verbose. 
    '''</span>

    <span class="s0"># Impl note: This function is kept separate from make_parser because it's</span>
    <span class="s0"># already very long and I wanted to separate out as much as possible into</span>
    <span class="s0"># its own call scope, to prevent even the possibility of suble mutation</span>
    <span class="s0"># bugs.</span>
    <span class="s2">if </span><span class="s1">param</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">is </span><span class="s1">param</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">PositionalArgError</span><span class="s3">(</span><span class="s1">param</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">param</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">is </span><span class="s1">param</span><span class="s3">.</span><span class="s1">VAR_KEYWORD</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">KWArgError</span><span class="s3">(</span><span class="s1">param</span><span class="s3">)</span>

    <span class="s0"># These are the kwargs for the add_argument function.</span>
    <span class="s1">arg_spec </span><span class="s3">= {}</span>
    <span class="s1">is_option </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># Get the type and default from the annotation.</span>
    <span class="s1">arg_type</span><span class="s3">, </span><span class="s1">description </span><span class="s3">= </span><span class="s1">_get_type_description</span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>

    <span class="s0"># Get the default value</span>
    <span class="s1">default </span><span class="s3">= </span><span class="s1">param</span><span class="s3">.</span><span class="s1">default</span>

    <span class="s0"># If there is no explicit type, and the default is present and not None,</span>
    <span class="s0"># infer the type from the default.</span>
    <span class="s2">if </span><span class="s1">arg_type </span><span class="s2">is None and </span><span class="s1">default </span><span class="s2">not in </span><span class="s3">{</span><span class="s1">_empty</span><span class="s3">, </span><span class="s2">None</span><span class="s3">}:</span>
        <span class="s1">arg_type </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">default</span><span class="s3">)</span>

    <span class="s0"># Add default. The presence of a default means this is an option, not an</span>
    <span class="s0"># argument.</span>
    <span class="s2">if </span><span class="s1">default </span><span class="s2">is not </span><span class="s1">_empty</span><span class="s3">:</span>
        <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'default'</span><span class="s3">] = </span><span class="s1">default</span>
        <span class="s1">is_option </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s0"># Add the type</span>
    <span class="s2">if </span><span class="s1">arg_type </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s0"># Special case for bool: make it just a --switch</span>
        <span class="s2">if </span><span class="s1">arg_type </span><span class="s2">is </span><span class="s1">bool</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">default </span><span class="s2">or </span><span class="s1">default </span><span class="s2">is </span><span class="s1">_empty</span><span class="s3">:</span>
                <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'action'</span><span class="s3">] = </span><span class="s5">'store_true'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'action'</span><span class="s3">] = </span><span class="s5">'store_false'</span>

            <span class="s0"># Switches are always options</span>
            <span class="s1">is_option </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s0"># Special case for file types: make it a string type, for filename</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">default</span><span class="s3">, </span><span class="s1">IOBase</span><span class="s3">):</span>
            <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] = </span><span class="s1">str</span>

        <span class="s0"># TODO: special case for list type.</span>
        <span class="s0">#   - How to specificy type of list members?</span>
        <span class="s0">#       - param: [int]</span>
        <span class="s0">#       - param: int =[]</span>
        <span class="s0">#   - action='append' vs nargs='*'</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'type'</span><span class="s3">] = </span><span class="s1">arg_type</span>

    <span class="s0"># nargs: if the signature includes *args, collect them as trailing CLI</span>
    <span class="s0"># arguments in a list. *args can't have a default value, so it can never be</span>
    <span class="s0"># an option.</span>
    <span class="s2">if </span><span class="s1">param</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">is </span><span class="s1">param</span><span class="s3">.</span><span class="s1">VAR_POSITIONAL</span><span class="s3">:</span>
        <span class="s0"># TODO: consider depluralizing metavar/name here.</span>
        <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'nargs'</span><span class="s3">] = </span><span class="s5">'*'</span>

    <span class="s0"># Add description.</span>
    <span class="s2">if </span><span class="s1">description </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'help'</span><span class="s3">] = </span><span class="s1">description</span>

    <span class="s0"># Get the --flags</span>
    <span class="s1">flags </span><span class="s3">= []</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">param</span><span class="s3">.</span><span class="s1">name</span>

    <span class="s2">if </span><span class="s1">is_option</span><span class="s3">:</span>
        <span class="s0"># Add the first letter as a -short option.</span>
        <span class="s2">for </span><span class="s1">letter </span><span class="s2">in </span><span class="s1">name</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">name</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">swapcase</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">letter </span><span class="s2">not in </span><span class="s1">used_char_args</span><span class="s3">:</span>
                <span class="s1">used_char_args</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">letter</span><span class="s3">)</span>
                <span class="s1">flags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">'-{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">letter</span><span class="s3">))</span>
                <span class="s2">break</span>

        <span class="s0"># If the parameter is a --long option, or is a -short option that</span>
        <span class="s0"># somehow failed to get a flag, add it.</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) &gt; </span><span class="s6">1 </span><span class="s2">or not </span><span class="s1">flags</span><span class="s3">:</span>
            <span class="s1">flags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">'--{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

        <span class="s1">arg_spec</span><span class="s3">[</span><span class="s5">'dest'</span><span class="s3">] = </span><span class="s1">name</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">flags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(*</span><span class="s1">flags</span><span class="s3">, **</span><span class="s1">arg_spec</span><span class="s3">)</span>

    <span class="s0"># Create the --no- version for boolean switches</span>
    <span class="s2">if </span><span class="s1">add_nos </span><span class="s2">and </span><span class="s1">arg_type </span><span class="s2">is </span><span class="s1">bool</span><span class="s3">:</span>
        <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
            <span class="s5">'--no-{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
            <span class="s1">action</span><span class="s3">=</span><span class="s5">'store_const'</span><span class="s3">,</span>
            <span class="s1">dest</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
            <span class="s1">const</span><span class="s3">=</span><span class="s1">default </span><span class="s2">if </span><span class="s1">default </span><span class="s2">is not </span><span class="s1">_empty </span><span class="s2">else False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_parser</span><span class="s3">(</span><span class="s1">func_sig</span><span class="s3">, </span><span class="s1">description</span><span class="s3">, </span><span class="s1">epilog</span><span class="s3">, </span><span class="s1">add_nos</span><span class="s3">):</span>
    <span class="s4">''' 
    Given the signature of a function, create an ArgumentParser 
    '''</span>
    <span class="s1">parser </span><span class="s3">= </span><span class="s1">ArgumentParser</span><span class="s3">(</span><span class="s1">description</span><span class="s3">=</span><span class="s1">description</span><span class="s3">, </span><span class="s1">epilog</span><span class="s3">=</span><span class="s1">epilog</span><span class="s3">)</span>

    <span class="s1">used_char_args </span><span class="s3">= {</span><span class="s5">'h'</span><span class="s3">}</span>

    <span class="s0"># Arange the params so that single-character arguments are first. This</span>
    <span class="s0"># esnures they don't have to get --long versions. sorted is stable, so the</span>
    <span class="s0"># parameters will otherwise still be in relative order.</span>
    <span class="s1">params </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
        <span class="s1">func_sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(),</span>
        <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">param</span><span class="s3">: </span><span class="s1">len</span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s1">_add_arguments</span><span class="s3">(</span><span class="s1">param</span><span class="s3">, </span><span class="s1">parser</span><span class="s3">, </span><span class="s1">used_char_args</span><span class="s3">, </span><span class="s1">add_nos</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">parser</span>


<span class="s1">_DOCSTRING_SPLIT </span><span class="s3">= </span><span class="s1">compile_regex</span><span class="s3">(</span><span class="s5">r'\n\s*-{4,}\s*\n'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">parse_docstring</span><span class="s3">(</span><span class="s1">docstring</span><span class="s3">):</span>
    <span class="s4">''' 
    Given a docstring, parse it into a description and epilog part 
    '''</span>
    <span class="s2">if </span><span class="s1">docstring </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">''</span><span class="s3">, </span><span class="s5">''</span>

    <span class="s1">parts </span><span class="s3">= </span><span class="s1">_DOCSTRING_SPLIT</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">docstring</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">docstring</span><span class="s3">, </span><span class="s5">''</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">parts</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">parts</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TooManySplitsError</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">autoparse</span><span class="s3">(</span>
        <span class="s1">func</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *,</span>
        <span class="s1">description</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">epilog</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">add_nos</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">parser</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s4">''' 
    This decorator converts a function that takes normal arguments into a 
    function which takes a single optional argument, argv, parses it using an 
    argparse.ArgumentParser, and calls the underlying function with the parsed 
    arguments. If it is not given, sys.argv[1:] is used. This is so that the 
    function can be used as a setuptools entry point, as well as a normal main 
    function. sys.argv[1:] is not evaluated until the function is called, to 
    allow injecting different arguments for testing. 
 
    It uses the argument signature of the function to create an 
    ArgumentParser. Parameters without defaults become positional parameters, 
    while parameters *with* defaults become --options. Use annotations to set 
    the type of the parameter. 
 
    The `desctiption` and `epilog` parameters corrospond to the same respective 
    argparse parameters. If no description is given, it defaults to the 
    decorated functions's docstring, if present. 
 
    If add_nos is True, every boolean option (that is, every parameter with a 
    default of True/False or a type of bool) will have a --no- version created 
    as well, which inverts the option. For instance, the --verbose option will 
    have a --no-verbose counterpart. These are not mutually exclusive- 
    whichever one appears last in the argument list will have precedence. 
 
    If a parser is given, it is used instead of one generated from the function 
    signature. In this case, no parser is created; instead, the given parser is 
    used to parse the argv argument. The parser's results' argument names must 
    match up with the parameter names of the decorated function. 
 
    The decorated function is attached to the result as the `func` attribute, 
    and the parser is attached as the `parser` attribute. 
    '''</span>

    <span class="s0"># If @autoparse(...) is used instead of @autoparse</span>
    <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return lambda </span><span class="s1">f</span><span class="s3">: </span><span class="s1">autoparse</span><span class="s3">(</span>
            <span class="s1">f</span><span class="s3">, </span><span class="s1">description</span><span class="s3">=</span><span class="s1">description</span><span class="s3">,</span>
            <span class="s1">epilog</span><span class="s3">=</span><span class="s1">epilog</span><span class="s3">,</span>
            <span class="s1">add_nos</span><span class="s3">=</span><span class="s1">add_nos</span><span class="s3">,</span>
            <span class="s1">parser</span><span class="s3">=</span><span class="s1">parser</span><span class="s3">)</span>

    <span class="s1">func_sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>

    <span class="s1">docstr_description</span><span class="s3">, </span><span class="s1">docstr_epilog </span><span class="s3">= </span><span class="s1">parse_docstring</span><span class="s3">(</span><span class="s1">getdoc</span><span class="s3">(</span><span class="s1">func</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">parser </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">parser </span><span class="s3">= </span><span class="s1">make_parser</span><span class="s3">(</span>
            <span class="s1">func_sig</span><span class="s3">,</span>
            <span class="s1">description </span><span class="s2">or </span><span class="s1">docstr_description</span><span class="s3">,</span>
            <span class="s1">epilog </span><span class="s2">or </span><span class="s1">docstr_epilog</span><span class="s3">,</span>
            <span class="s1">add_nos</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">wraps</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">autoparse_wrapper</span><span class="s3">(</span><span class="s1">argv</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">argv </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">argv </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">argv</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>

        <span class="s0"># Get empty argument binding, to fill with parsed arguments. This</span>
        <span class="s0"># object does all the heavy lifting of turning named arguments into</span>
        <span class="s0"># into correctly bound *args and **kwargs.</span>
        <span class="s1">parsed_args </span><span class="s3">= </span><span class="s1">func_sig</span><span class="s3">.</span><span class="s1">bind_partial</span><span class="s3">()</span>
        <span class="s1">parsed_args</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">parser</span><span class="s3">.</span><span class="s1">parse_args</span><span class="s3">(</span><span class="s1">argv</span><span class="s3">)))</span>

        <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">parsed_args</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">parsed_args</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s0"># TODO: attach an updated __signature__ to autoparse_wrapper, just in case.</span>

    <span class="s0"># Attach the wrapped function and parser, and return the wrapper.</span>
    <span class="s1">autoparse_wrapper</span><span class="s3">.</span><span class="s1">func </span><span class="s3">= </span><span class="s1">func</span>
    <span class="s1">autoparse_wrapper</span><span class="s3">.</span><span class="s1">parser </span><span class="s3">= </span><span class="s1">parser</span>
    <span class="s2">return </span><span class="s1">autoparse_wrapper</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">smart_open</span><span class="s3">(</span><span class="s1">filename_or_file</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s4">''' 
    This context manager allows you to open a filename, if you want to default 
    some already-existing file object, like sys.stdout, which shouldn't be 
    closed at the end of the context. If the filename argument is a str, bytes, 
    or int, the file object is created via a call to open with the given *args 
    and **kwargs, sent to the context, and closed at the end of the context, 
    just like &quot;with open(filename) as f:&quot;. If it isn't one of the openable 
    types, the object simply sent to the context unchanged, and left unclosed 
    at the end of the context. Example: 
 
        def work_with_file(name=sys.stdout): 
            with smart_open(name) as f: 
                # Works correctly if name is a str filename or sys.stdout 
                print(&quot;Some stuff&quot;, file=f) 
                # If it was a filename, f is closed at the end here. 
    '''</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">filename_or_file</span><span class="s3">, (</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)):</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename_or_file</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s2">as </span><span class="s1">file</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">file</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">yield </span><span class="s1">filename_or_file</span>
</pre>
</body>
</html>