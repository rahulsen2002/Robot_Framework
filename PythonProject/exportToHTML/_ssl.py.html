<html>
<head>
<title>_ssl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ssl.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">operator </span><span class="s0">as </span><span class="s1">_operator</span>
<span class="s0">import </span><span class="s1">ssl </span><span class="s0">as </span><span class="s1">_stdlib_ssl</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum </span><span class="s0">as </span><span class="s1">_Enum</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">ClassVar</span><span class="s2">, </span><span class="s1">Final </span><span class="s0">as </span><span class="s1">TFinal</span><span class="s2">, </span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">TypeVar</span>

<span class="s0">import </span><span class="s1">trio</span>

<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">_sync</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_highlevel_generic </span><span class="s0">import </span><span class="s1">aclose_forcefully</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">ConflictDetector</span><span class="s2">, </span><span class="s1">final</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Listener</span><span class="s2">, </span><span class="s1">Stream</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Awaitable</span><span class="s2">, </span><span class="s1">Callable</span>

    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">TypeVarTuple</span><span class="s2">, </span><span class="s1">Unpack</span>

    <span class="s1">Ts </span><span class="s2">= </span><span class="s1">TypeVarTuple</span><span class="s2">(</span><span class="s3">&quot;Ts&quot;</span><span class="s2">)</span>

<span class="s4"># General theory of operation:</span>
<span class="s4">#</span>
<span class="s4"># We implement an API that closely mirrors the stdlib ssl module's blocking</span>
<span class="s4"># API, and we do it using the stdlib ssl module's non-blocking in-memory API.</span>
<span class="s4"># The stdlib non-blocking in-memory API is barely documented, and acts as a</span>
<span class="s4"># thin wrapper around openssl, whose documentation also leaves something to be</span>
<span class="s4"># desired. So here's the main things you need to know to understand the code</span>
<span class="s4"># in this file:</span>
<span class="s4">#</span>
<span class="s4"># We use an ssl.SSLObject, which exposes the four main I/O operations:</span>
<span class="s4">#</span>
<span class="s4"># - do_handshake: performs the initial handshake. Must be called once at the</span>
<span class="s4">#   beginning of each connection; is a no-op once it's completed once.</span>
<span class="s4">#</span>
<span class="s4"># - write: takes some unencrypted data and attempts to send it to the remote</span>
<span class="s4">#   peer.</span>

<span class="s4"># - read: attempts to decrypt and return some data from the remote peer.</span>
<span class="s4">#</span>
<span class="s4"># - unwrap: this is weirdly named; maybe it helps to realize that the thing it</span>
<span class="s4">#   wraps is called SSL_shutdown. It sends a cryptographically signed message</span>
<span class="s4">#   saying &quot;I'm closing this connection now&quot;, and then waits to receive the</span>
<span class="s4">#   same from the remote peer (unless we already received one, in which case</span>
<span class="s4">#   it returns immediately).</span>
<span class="s4">#</span>
<span class="s4"># All of these operations read and write from some in-memory buffers called</span>
<span class="s4"># &quot;BIOs&quot;, which are an opaque OpenSSL-specific object that's basically</span>
<span class="s4"># semantically equivalent to a Python bytearray. When they want to send some</span>
<span class="s4"># bytes to the remote peer, they append them to the outgoing BIO, and when</span>
<span class="s4"># they want to receive some bytes from the remote peer, they try to pull them</span>
<span class="s4"># out of the incoming BIO. &quot;Sending&quot; always succeeds, because the outgoing BIO</span>
<span class="s4"># can always be extended to hold more data. &quot;Receiving&quot; acts sort of like a</span>
<span class="s4"># non-blocking socket: it might manage to get some data immediately, or it</span>
<span class="s4"># might fail and need to be tried again later. We can also directly add or</span>
<span class="s4"># remove data from the BIOs whenever we want.</span>
<span class="s4">#</span>
<span class="s4"># Now the problem is that while these I/O operations are opaque atomic</span>
<span class="s4"># operations from the point of view of us calling them, under the hood they</span>
<span class="s4"># might require some arbitrary sequence of sends and receives from the remote</span>
<span class="s4"># peer. This is particularly true for do_handshake, which generally requires a</span>
<span class="s4"># few round trips, but it's also true for write and read, due to an evil thing</span>
<span class="s4"># called &quot;renegotiation&quot;.</span>
<span class="s4">#</span>
<span class="s4"># Renegotiation is the process by which one of the peers might arbitrarily</span>
<span class="s4"># decide to redo the handshake at any time. Did I mention it's evil? It's</span>
<span class="s4"># pretty evil, and almost universally hated. The HTTP/2 spec forbids the use</span>
<span class="s4"># of TLS renegotiation for HTTP/2 connections. TLS 1.3 removes it from the</span>
<span class="s4"># protocol entirely. It's impossible to trigger a renegotiation if using</span>
<span class="s4"># Python's ssl module. OpenSSL's renegotiation support is pretty buggy [1].</span>
<span class="s4"># Nonetheless, it does get used in real life, mostly in two cases:</span>
<span class="s4">#</span>
<span class="s4"># 1) Normally in TLS 1.2 and below, when the client side of a connection wants</span>
<span class="s4"># to present a certificate to prove their identity, that certificate gets sent</span>
<span class="s4"># in plaintext. This is bad, because it means that anyone eavesdropping can</span>
<span class="s4"># see who's connecting â€“ it's like sending your username in plain text. Not as</span>
<span class="s4"># bad as sending your password in plain text, but still, pretty bad. However,</span>
<span class="s4"># renegotiations *are* encrypted. So as a workaround, it's not uncommon for</span>
<span class="s4"># systems that want to use client certificates to first do an anonymous</span>
<span class="s4"># handshake, and then to turn around and do a second handshake (=</span>
<span class="s4"># renegotiation) and this time ask for a client cert. Or sometimes this is</span>
<span class="s4"># done on a case-by-case basis, e.g. a web server might accept a connection,</span>
<span class="s4"># read the request, and then once it sees the page you're asking for it might</span>
<span class="s4"># stop and ask you for a certificate.</span>
<span class="s4">#</span>
<span class="s4"># 2) In principle the same TLS connection can be used for an arbitrarily long</span>
<span class="s4"># time, and might transmit arbitrarily large amounts of data. But this creates</span>
<span class="s4"># a cryptographic problem: an attacker who has access to arbitrarily large</span>
<span class="s4"># amounts of data that's all encrypted using the same key may eventually be</span>
<span class="s4"># able to use this to figure out the key. Is this a real practical problem? I</span>
<span class="s4"># have no idea, I'm not a cryptographer. In any case, some people worry that</span>
<span class="s4"># it's a problem, so their TLS libraries are designed to automatically trigger</span>
<span class="s4"># a renegotiation every once in a while on some sort of timer.</span>
<span class="s4">#</span>
<span class="s4"># The end result is that you might be going along, minding your own business,</span>
<span class="s4"># and then *bam*! a wild renegotiation appears! And you just have to cope.</span>
<span class="s4">#</span>
<span class="s4"># The reason that coping with renegotiations is difficult is that some</span>
<span class="s4"># unassuming &quot;read&quot; or &quot;write&quot; call might find itself unable to progress until</span>
<span class="s4"># it does a handshake, which remember is a process with multiple round</span>
<span class="s4"># trips. So read might have to send data, and write might have to receive</span>
<span class="s4"># data, and this might happen multiple times. And some of those attempts might</span>
<span class="s4"># fail because there isn't any data yet, and need to be retried. Managing all</span>
<span class="s4"># this is pretty complicated.</span>
<span class="s4">#</span>
<span class="s4"># Here's how openssl (and thus the stdlib ssl module) handle this. All of the</span>
<span class="s4"># I/O operations above follow the same rules. When you call one of them:</span>
<span class="s4">#</span>
<span class="s4"># - it might write some data to the outgoing BIO</span>
<span class="s4"># - it might read some data from the incoming BIO</span>
<span class="s4"># - it might raise SSLWantReadError if it can't complete without reading more</span>
<span class="s4">#   data from the incoming BIO. This is important: the &quot;read&quot; in ReadError</span>
<span class="s4">#   refers to reading from the *underlying* stream.</span>
<span class="s4"># - (and in principle it might raise SSLWantWriteError too, but that never</span>
<span class="s4">#   happens when using memory BIOs, so never mind)</span>
<span class="s4">#</span>
<span class="s4"># If it doesn't raise an error, then the operation completed successfully</span>
<span class="s4"># (though we still need to take any outgoing data out of the memory buffer and</span>
<span class="s4"># put it onto the wire). If it *does* raise an error, then we need to retry</span>
<span class="s4"># *exactly that method call* later â€“ in particular, if a 'write' failed, we</span>
<span class="s4"># need to try again later *with the same data*, because openssl might have</span>
<span class="s4"># already committed some of the initial parts of our data to its output even</span>
<span class="s4"># though it didn't tell us that, and has remembered that the next time we call</span>
<span class="s4"># write it needs to skip the first 1024 bytes or whatever it is. (Well,</span>
<span class="s4"># technically, we're actually allowed to call 'write' again with a data buffer</span>
<span class="s4"># which is the same as our old one PLUS some extra stuff added onto the end,</span>
<span class="s4"># but in Trio that never comes up so never mind.)</span>
<span class="s4">#</span>
<span class="s4"># There are some people online who claim that once you've gotten a Want*Error</span>
<span class="s4"># then the *very next call* you make to openssl *must* be the same as the</span>
<span class="s4"># previous one. I'm pretty sure those people are wrong. In particular, it's</span>
<span class="s4"># okay to call write, get a WantReadError, and then call read a few times;</span>
<span class="s4"># it's just that *the next time you call write*, it has to be with the same</span>
<span class="s4"># data.</span>
<span class="s4">#</span>
<span class="s4"># One final wrinkle: we want our SSLStream to support full-duplex operation,</span>
<span class="s4"># i.e. it should be possible for one task to be calling send_all while another</span>
<span class="s4"># task is calling receive_some. But renegotiation makes this a big hassle, because</span>
<span class="s4"># even if SSLStream's restricts themselves to one task calling send_all and one</span>
<span class="s4"># task calling receive_some, those two tasks might end up both wanting to call</span>
<span class="s4"># send_all, or both to call receive_some at the same time *on the underlying</span>
<span class="s4"># stream*. So we have to do some careful locking to hide this problem from our</span>
<span class="s4"># users.</span>
<span class="s4">#</span>
<span class="s4"># (Renegotiation is evil.)</span>
<span class="s4">#</span>
<span class="s4"># So our basic strategy is to define a single helper method called &quot;_retry&quot;,</span>
<span class="s4"># which has generic logic for dealing with SSLWantReadError, pushing data from</span>
<span class="s4"># the outgoing BIO to the wire, reading data from the wire to the incoming</span>
<span class="s4"># BIO, retrying an I/O call until it works, and synchronizing with other tasks</span>
<span class="s4"># that might be calling _retry concurrently. Basically it takes an SSLObject</span>
<span class="s4"># non-blocking in-memory method and converts it into a Trio async blocking</span>
<span class="s4"># method. _retry is only about 30 lines of code, but all these cases</span>
<span class="s4"># multiplied by concurrent calls make it extremely tricky, so there are lots</span>
<span class="s4"># of comments down below on the details, and a really extensive test suite in</span>
<span class="s4"># test_ssl.py. And now you know *why* it's so tricky, and can probably</span>
<span class="s4"># understand how it works.</span>
<span class="s4">#</span>
<span class="s4"># [1] https://rt.openssl.org/Ticket/Display.html?id=3712</span>

<span class="s4"># XX how closely should we match the stdlib API?</span>
<span class="s4"># - maybe suppress_ragged_eofs=False is a better default?</span>
<span class="s4"># - maybe check crypto folks for advice?</span>
<span class="s4"># - this is also interesting: https://bugs.python.org/issue8108#msg102867</span>

<span class="s4"># Definitely keep an eye on Cory's TLS API ideas on security-sig etc.</span>

<span class="s4"># XX document behavior on cancellation/error (i.e.: all is lost abandon</span>
<span class="s4"># stream)</span>
<span class="s4"># docs will need to make very clear that this is different from all the other</span>
<span class="s4"># cancellations in core Trio</span>


<span class="s1">T </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;T&quot;</span><span class="s2">)</span>

<span class="s4">################################################################</span>
<span class="s4"># SSLStream</span>
<span class="s4">################################################################</span>

<span class="s4"># Ideally, when the user calls SSLStream.receive_some() with no argument, then</span>
<span class="s4"># we should do exactly one call to self.transport_stream.receive_some(),</span>
<span class="s4"># decrypt everything we got, and return it. Unfortunately, the way openssl's</span>
<span class="s4"># API works, we have to pick how much data we want to allow when we call</span>
<span class="s4"># read(), and then it (potentially) triggers a call to</span>
<span class="s4"># transport_stream.receive_some(). So at the time we pick the amount of data</span>
<span class="s4"># to decrypt, we don't know how much data we've read. As a simple heuristic,</span>
<span class="s4"># we record the max amount of data returned by previous calls to</span>
<span class="s4"># transport_stream.receive_some(), and we use that for future calls to read().</span>
<span class="s4"># But what do we use for the very first call? That's what this constant sets.</span>
<span class="s4">#</span>
<span class="s4"># Note that the value passed to read() is a limit on the amount of</span>
<span class="s4"># *decrypted* data, but we can only see the size of the *encrypted* data</span>
<span class="s4"># returned by transport_stream.receive_some(). TLS adds a small amount of</span>
<span class="s4"># framing overhead, and TLS compression is rarely used these days because it's</span>
<span class="s4"># insecure. So the size of the encrypted data should be a slight over-estimate</span>
<span class="s4"># of the size of the decrypted data, which is exactly what we want.</span>
<span class="s4">#</span>
<span class="s4"># The specific value is not really based on anything; it might be worth tuning</span>
<span class="s4"># at some point. But, if you have an TCP connection with the typical 1500 byte</span>
<span class="s4"># MTU and an initial window of 10 (see RFC 6928), then the initial burst of</span>
<span class="s4"># data will be limited to ~15000 bytes (or a bit less due to IP-level framing</span>
<span class="s4"># overhead), so this is chosen to be larger than that.</span>
<span class="s1">STARTING_RECEIVE_SIZE</span><span class="s2">: </span><span class="s1">TFinal </span><span class="s2">= </span><span class="s5">16384</span>


<span class="s0">def </span><span class="s1">_is_eof</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">: </span><span class="s1">BaseException </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s4"># There appears to be a bug on Python 3.10, where SSLErrors</span>
    <span class="s4"># aren't properly translated into SSLEOFErrors.</span>
    <span class="s4"># This stringly-typed error check is borrowed from the AnyIO</span>
    <span class="s4"># project.</span>
    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLEOFError</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span>
        <span class="s3">&quot;UNEXPECTED_EOF_WHILE_READING&quot; </span><span class="s0">in </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s3">&quot;strerror&quot;</span><span class="s2">, ())</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">NeedHandshakeError</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Some :class:`SSLStream` methods can't return any meaningful data until 
    after the handshake. If you call them before the handshake, they raise 
    this error. 
 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">_Once</span><span class="s2">:</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s3">&quot;_afn&quot;</span><span class="s2">, </span><span class="s3">&quot;_args&quot;</span><span class="s2">, </span><span class="s3">&quot;_done&quot;</span><span class="s2">, </span><span class="s3">&quot;started&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">afn</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[*</span><span class="s1">Ts</span><span class="s2">], </span><span class="s1">Awaitable</span><span class="s2">[</span><span class="s1">object</span><span class="s2">]],</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">: </span><span class="s1">Unpack</span><span class="s2">[</span><span class="s1">Ts</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_afn </span><span class="s2">= </span><span class="s1">afn</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_args </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">started </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_done </span><span class="s2">= </span><span class="s1">_sync</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">checkpoint</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">started</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">started </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_afn</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_done</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">elif not </span><span class="s1">checkpoint </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_done</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">():</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_done</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">done</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_done</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">())</span>


<span class="s1">_State </span><span class="s2">= </span><span class="s1">_Enum</span><span class="s2">(</span><span class="s3">&quot;_State&quot;</span><span class="s2">, [</span><span class="s3">&quot;OK&quot;</span><span class="s2">, </span><span class="s3">&quot;BROKEN&quot;</span><span class="s2">, </span><span class="s3">&quot;CLOSED&quot;</span><span class="s2">])</span>

<span class="s4"># invariant</span>
<span class="s1">T_Stream </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;T_Stream&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">Stream</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">SSLStream</span><span class="s2">(</span><span class="s1">Stream</span><span class="s2">, </span><span class="s1">Generic</span><span class="s2">[</span><span class="s1">T_Stream</span><span class="s2">]):</span>
    <span class="s6">r&quot;&quot;&quot;Encrypted communication using SSL/TLS. 
 
    :class:`SSLStream` wraps an arbitrary :class:`~trio.abc.Stream`, and 
    allows you to perform encrypted communication over it using the usual 
    :class:`~trio.abc.Stream` interface. You pass regular data to 
    :meth:`send_all`, then it encrypts it and sends the encrypted data on the 
    underlying :class:`~trio.abc.Stream`; :meth:`receive_some` takes encrypted 
    data out of the underlying :class:`~trio.abc.Stream` and decrypts it 
    before returning it. 
 
    You should read the standard library's :mod:`ssl` documentation carefully 
    before attempting to use this class, and probably other general 
    documentation on SSL/TLS as well. SSL/TLS is subtle and quick to 
    anger. Really. I'm not kidding. 
 
    Args: 
      transport_stream (~trio.abc.Stream): The stream used to transport 
          encrypted data. Required. 
 
      ssl_context (~ssl.SSLContext): The :class:`~ssl.SSLContext` used for 
          this connection. Required. Usually created by calling 
          :func:`ssl.create_default_context`. 
 
      server_hostname (str, bytes, or None): The name of the server being 
          connected to. Used for `SNI 
          &lt;https://en.wikipedia.org/wiki/Server_Name_Indication&gt;`__ and for 
          validating the server's certificate (if hostname checking is 
          enabled). This is effectively mandatory for clients, and actually 
          mandatory if ``ssl_context.check_hostname`` is ``True``. 
 
      server_side (bool): Whether this stream is acting as a client or 
          server. Defaults to False, i.e. client mode. 
 
      https_compatible (bool): There are two versions of SSL/TLS commonly 
          encountered in the wild: the standard version, and the version used 
          for HTTPS (HTTP-over-SSL/TLS). 
 
          Standard-compliant SSL/TLS implementations always send a 
          cryptographically signed ``close_notify`` message before closing the 
          connection. This is important because if the underlying transport 
          were simply closed, then there wouldn't be any way for the other 
          side to know whether the connection was intentionally closed by the 
          peer that they negotiated a cryptographic connection to, or by some 
          `man-in-the-middle 
          &lt;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&gt;`__ attacker 
          who can't manipulate the cryptographic stream, but can manipulate 
          the transport layer (a so-called &quot;truncation attack&quot;). 
 
          However, this part of the standard is widely ignored by real-world 
          HTTPS implementations, which means that if you want to interoperate 
          with them, then you NEED to ignore it too. 
 
          Fortunately this isn't as bad as it sounds, because the HTTP 
          protocol already includes its own equivalent of ``close_notify``, so 
          doing this again at the SSL/TLS level is redundant. But not all 
          protocols do! Therefore, by default Trio implements the safer 
          standard-compliant version (``https_compatible=False``). But if 
          you're speaking HTTPS or some other protocol where 
          ``close_notify``\s are commonly skipped, then you should set 
          ``https_compatible=True``; with this setting, Trio will neither 
          expect nor send ``close_notify`` messages. 
 
          If you have code that was written to use :class:`ssl.SSLSocket` and 
          now you're porting it to Trio, then it may be useful to know that a 
          difference between :class:`SSLStream` and :class:`ssl.SSLSocket` is 
          that :class:`~ssl.SSLSocket` implements the 
          ``https_compatible=True`` behavior by default. 
 
    Attributes: 
      transport_stream (trio.abc.Stream): The underlying transport stream 
          that was passed to ``__init__``. An example of when this would be 
          useful is if you're using :class:`SSLStream` over a 
          :class:`~trio.SocketStream` and want to call the 
          :class:`~trio.SocketStream`'s :meth:`~trio.SocketStream.setsockopt` 
          method. 
 
    Internally, this class is implemented using an instance of 
    :class:`ssl.SSLObject`, and all of :class:`~ssl.SSLObject`'s methods and 
    attributes are re-exported as methods and attributes on this class. 
    However, there is one difference: :class:`~ssl.SSLObject` has several 
    methods that return information about the encrypted connection, like 
    :meth:`~ssl.SSLSocket.cipher` or 
    :meth:`~ssl.SSLSocket.selected_alpn_protocol`. If you call them before the 
    handshake, when they can't possibly return useful data, then 
    :class:`ssl.SSLObject` returns None, but :class:`trio.SSLStream` 
    raises :exc:`NeedHandshakeError`. 
 
    This also means that if you register a SNI callback using 
    `~ssl.SSLContext.sni_callback`, then the first argument your callback 
    receives will be a :class:`ssl.SSLObject`. 
 
    &quot;&quot;&quot;</span>

    <span class="s4"># Note: any new arguments here should likely also be added to</span>
    <span class="s4"># SSLListener.__init__, and maybe the open_ssl_over_tcp_* helpers.</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">transport_stream</span><span class="s2">: </span><span class="s1">T_Stream</span><span class="s2">,</span>
        <span class="s1">ssl_context</span><span class="s2">: </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLContext</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">server_hostname</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s1">bytes </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">server_side</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">https_compatible</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">: </span><span class="s1">T_Stream </span><span class="s2">= </span><span class="s1">transport_stream</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">OK</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible </span><span class="s2">= </span><span class="s1">https_compatible</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_outgoing </span><span class="s2">= </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">MemoryBIO</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing</span><span class="s2">: </span><span class="s1">bytes </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming </span><span class="s2">= </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">MemoryBIO</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object </span><span class="s2">= </span><span class="s1">ssl_context</span><span class="s2">.</span><span class="s1">wrap_bio</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_outgoing</span><span class="s2">,</span>
            <span class="s1">server_side</span><span class="s2">=</span><span class="s1">server_side</span><span class="s2">,</span>
            <span class="s1">server_hostname</span><span class="s2">=</span><span class="s1">server_hostname</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s4"># Tracks whether we've already done the initial handshake</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook </span><span class="s2">= </span><span class="s1">_Once</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_do_handshake</span><span class="s2">)</span>

        <span class="s4"># These are used to synchronize access to self.transport_stream</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_send_lock </span><span class="s2">= </span><span class="s1">_sync</span><span class="s2">.</span><span class="s1">StrictFIFOLock</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_count </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_lock </span><span class="s2">= </span><span class="s1">_sync</span><span class="s2">.</span><span class="s1">Lock</span><span class="s2">()</span>

        <span class="s4"># These are used to make sure that our caller doesn't attempt to make</span>
        <span class="s4"># multiple concurrent calls to send_all/wait_send_all_might_not_block</span>
        <span class="s4"># or to receive_some.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_send_conflict_detector </span><span class="s2">= </span><span class="s1">ConflictDetector</span><span class="s2">(</span>
            <span class="s3">&quot;another task is currently sending data on this SSLStream&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_recv_conflict_detector </span><span class="s2">= </span><span class="s1">ConflictDetector</span><span class="s2">(</span>
            <span class="s3">&quot;another task is currently receiving data on this SSLStream&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_estimated_receive_size </span><span class="s2">= </span><span class="s1">STARTING_RECEIVE_SIZE</span>

    <span class="s1">_forwarded</span><span class="s2">: </span><span class="s1">ClassVar </span><span class="s2">= {</span>
        <span class="s3">&quot;context&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;server_side&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;server_hostname&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;session&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;session_reused&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;getpeercert&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;selected_npn_protocol&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;cipher&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;shared_ciphers&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;compression&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;pending&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;get_channel_binding&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;selected_alpn_protocol&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;version&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s1">_after_handshake</span><span class="s2">: </span><span class="s1">ClassVar </span><span class="s2">= {</span>
        <span class="s3">&quot;session_reused&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;getpeercert&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;selected_npn_protocol&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;cipher&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;shared_ciphers&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;compression&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;get_channel_binding&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;selected_alpn_protocol&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;version&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(  </span><span class="s4"># type: ignore[explicit-any]</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_forwarded</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_after_handshake </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">done</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NeedHandshakeError</span><span class="s2">(</span><span class="s3">f&quot;call do_handshake() before calling </span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">object</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_forwarded</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__dir__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">super</span><span class="s2">().</span><span class="s1">__dir__</span><span class="s2">()) + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_forwarded</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_check_status</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s0">is </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">OK</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s0">is </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">BROKEN</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s0">is </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">CLOSED</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">ClosedResourceError</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">()</span>

    <span class="s4"># This is probably the single trickiest function in Trio. It has lots of</span>
    <span class="s4"># comments, though, just make sure to think carefully if you ever have to</span>
    <span class="s4"># touch it. The big comment at the top of this file will help explain</span>
    <span class="s4"># too.</span>
    <span class="s0">async def </span><span class="s1">_retry</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fn</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[*</span><span class="s1">Ts</span><span class="s2">], </span><span class="s1">T</span><span class="s2">],</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">: </span><span class="s1">Unpack</span><span class="s2">[</span><span class="s1">Ts</span><span class="s2">],</span>
        <span class="s1">ignore_want_read</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">is_handshake</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; T </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
        <span class="s1">yielded </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">finished </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">while not </span><span class="s1">finished</span><span class="s2">:</span>
            <span class="s4"># WARNING: this code needs to be very careful with when it</span>
            <span class="s4"># calls 'await'! There might be multiple tasks calling this</span>
            <span class="s4"># function at the same time trying to do different operations,</span>
            <span class="s4"># so we need to be careful to:</span>
            <span class="s4">#</span>
            <span class="s4"># 1) interact with the SSLObject, then</span>
            <span class="s4"># 2) await on exactly one thing that lets us make forward</span>
            <span class="s4"># progress, then</span>
            <span class="s4"># 3) loop or exit</span>
            <span class="s4">#</span>
            <span class="s4"># In particular we don't want to yield while interacting with</span>
            <span class="s4"># the SSLObject (because it's shared state, so someone else</span>
            <span class="s4"># might come in and mess with it while we're suspended), and</span>
            <span class="s4"># we don't want to yield *before* starting the operation that</span>
            <span class="s4"># will help us make progress, because then someone else might</span>
            <span class="s4"># come in and leapfrog us.</span>

            <span class="s4"># Call the SSLObject method, and get its result.</span>
            <span class="s4">#</span>
            <span class="s4"># NB: despite what the docs say, SSLWantWriteError can't</span>
            <span class="s4"># happen â€“ &quot;Writes to memory BIOs will always succeed if</span>
            <span class="s4"># memory is available: that is their size can grow</span>
            <span class="s4"># indefinitely.&quot;</span>
            <span class="s4"># https://wiki.openssl.org/index.php/Manual:BIO_s_mem(3)</span>
            <span class="s1">want_read </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">ret </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLWantReadError</span><span class="s2">:</span>
                <span class="s1">want_read </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLError</span><span class="s2">, </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">CertificateError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">BROKEN</span>
                <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError </span><span class="s0">from </span><span class="s1">exc</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">finished </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">ignore_want_read</span><span class="s2">:</span>
                <span class="s1">want_read </span><span class="s2">= </span><span class="s0">False</span>
                <span class="s1">finished </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">to_send </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outgoing</span><span class="s2">.</span><span class="s1">read</span><span class="s2">()</span>

            <span class="s4"># Some versions of SSL_do_handshake have a bug in how they handle</span>
            <span class="s4"># the TLS 1.3 handshake on the server side: after the handshake</span>
            <span class="s4"># finishes, they automatically send session tickets, even though</span>
            <span class="s4"># the client may not be expecting data to arrive at this point and</span>
            <span class="s4"># sending it could cause a deadlock or lost data. This applies at</span>
            <span class="s4"># least to OpenSSL 1.1.1c and earlier, and the OpenSSL devs</span>
            <span class="s4"># currently have no plans to fix it:</span>
            <span class="s4">#</span>
            <span class="s4">#   https://github.com/openssl/openssl/issues/7948</span>
            <span class="s4">#   https://github.com/openssl/openssl/issues/7967</span>
            <span class="s4">#</span>
            <span class="s4"># The correct behavior is to wait to send session tickets on the</span>
            <span class="s4"># first call to SSL_write. (This is what BoringSSL does.) So, we</span>
            <span class="s4"># use a heuristic to detect when OpenSSL has tried to send session</span>
            <span class="s4"># tickets, and we manually delay sending them until the</span>
            <span class="s4"># appropriate moment. For more discussion see:</span>
            <span class="s4">#</span>
            <span class="s4">#   https://github.com/python-trio/trio/issues/819#issuecomment-517529763</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">is_handshake</span>
                <span class="s0">and not </span><span class="s1">want_read</span>
                <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">server_side</span>
                <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">version</span><span class="s2">() == </span><span class="s3">&quot;TLSv1.3&quot;</span>
            <span class="s2">):</span>
                <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing </span><span class="s0">is None</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing </span><span class="s2">= </span><span class="s1">to_send</span>
                <span class="s1">to_send </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span>

            <span class="s4"># Outputs from the above code block are:</span>
            <span class="s4">#</span>
            <span class="s4"># - to_send: bytestring; if non-empty then we need to send</span>
            <span class="s4">#   this data to make forward progress</span>
            <span class="s4">#</span>
            <span class="s4"># - want_read: True if we need to receive_some some data to make</span>
            <span class="s4">#   forward progress</span>
            <span class="s4">#</span>
            <span class="s4"># - finished: False means that we need to retry the call to</span>
            <span class="s4">#   fn(*args) again, after having pushed things forward. True</span>
            <span class="s4">#   means we still need to do whatever was said (in particular</span>
            <span class="s4">#   send any data in to_send), but once we do then we're</span>
            <span class="s4">#   done.</span>
            <span class="s4">#</span>
            <span class="s4"># - ret: the operation's return value. (Meaningless unless</span>
            <span class="s4">#   finished is True.)</span>
            <span class="s4">#</span>
            <span class="s4"># Invariant: want_read and finished can't both be True at the</span>
            <span class="s4"># same time.</span>
            <span class="s4">#</span>
            <span class="s4"># Now we need to move things forward. There are two things we</span>
            <span class="s4"># might have to do, and any given operation might require</span>
            <span class="s4"># either, both, or neither to proceed:</span>
            <span class="s4">#</span>
            <span class="s4"># - send the data in to_send</span>
            <span class="s4">#</span>
            <span class="s4"># - receive_some some data and put it into the incoming BIO</span>
            <span class="s4">#</span>
            <span class="s4"># Our strategy is: if there's data to send, send it;</span>
            <span class="s4"># *otherwise* if there's data to receive_some, receive_some it.</span>
            <span class="s4">#</span>
            <span class="s4"># If both need to happen, then we only send. Why? Well, we</span>
            <span class="s4"># know that *right now* we have to both send and receive_some</span>
            <span class="s4"># before the operation can complete. But as soon as we yield,</span>
            <span class="s4"># that information becomes potentially stale â€“ e.g. while</span>
            <span class="s4"># we're sending, some other task might go and receive_some the</span>
            <span class="s4"># data we need and put it into the incoming BIO. And if it</span>
            <span class="s4"># does, then we *definitely don't* want to do a receive_some â€“</span>
            <span class="s4"># there might not be any more data coming, and we'd deadlock!</span>
            <span class="s4"># We could do something tricky to keep track of whether a</span>
            <span class="s4"># receive_some happens while we're sending, but the case where</span>
            <span class="s4"># we have to do both is very unusual (only during a</span>
            <span class="s4"># renegotiation), so it's better to keep things simple. So we</span>
            <span class="s4"># do just one potentially-blocking operation, then check again</span>
            <span class="s4"># for fresh information.</span>
            <span class="s4">#</span>
            <span class="s4"># And we prioritize sending over receiving because, if there</span>
            <span class="s4"># are multiple tasks that want to receive_some, then it</span>
            <span class="s4"># doesn't matter what order they go in. But if there are</span>
            <span class="s4"># multiple tasks that want to send, then they each have</span>
            <span class="s4"># different data, and the data needs to get put onto the wire</span>
            <span class="s4"># in the same order that it was retrieved from the outgoing</span>
            <span class="s4"># BIO. So if we have data to send, that *needs* to be the</span>
            <span class="s4"># *very* *next* *thing* we do, to make sure no-one else sneaks</span>
            <span class="s4"># in before us. Or if we can't send immediately because</span>
            <span class="s4"># someone else is, then we at least need to get in line</span>
            <span class="s4"># immediately.</span>
            <span class="s0">if </span><span class="s1">to_send</span><span class="s2">:</span>
                <span class="s4"># NOTE: This relies on the lock being strict FIFO fair!</span>
                <span class="s0">async with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_send_lock</span><span class="s2">:</span>
                    <span class="s1">yielded </span><span class="s2">= </span><span class="s0">True</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing </span><span class="s0">is not None</span><span class="s2">:</span>
                            <span class="s1">to_send </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing </span><span class="s2">+ </span><span class="s1">to_send</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_delayed_outgoing </span><span class="s2">= </span><span class="s0">None</span>
                        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">send_all</span><span class="s2">(</span><span class="s1">to_send</span><span class="s2">)</span>
                    <span class="s0">except</span><span class="s2">:</span>
                        <span class="s4"># Some unknown amount of our data got sent, and we</span>
                        <span class="s4"># don't know how much. This stream is doomed.</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">BROKEN</span>
                        <span class="s0">raise</span>
            <span class="s0">elif </span><span class="s1">want_read</span><span class="s2">:</span>
                <span class="s4"># It's possible that someone else is already blocked in</span>
                <span class="s4"># transport_stream.receive_some. If so then we want to</span>
                <span class="s4"># wait for them to finish, but we don't want to call</span>
                <span class="s4"># transport_stream.receive_some again ourselves; we just</span>
                <span class="s4"># want to loop around and check if their contribution</span>
                <span class="s4"># helped anything. So we make a note of how many times</span>
                <span class="s4"># some task has been through here before taking the lock,</span>
                <span class="s4"># and if it's changed by the time we get the lock, then we</span>
                <span class="s4"># skip calling transport_stream.receive_some and loop</span>
                <span class="s4"># around immediately.</span>
                <span class="s1">recv_count </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_count</span>
                <span class="s0">async with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_lock</span><span class="s2">:</span>
                    <span class="s1">yielded </span><span class="s2">= </span><span class="s0">True</span>
                    <span class="s0">if </span><span class="s1">recv_count </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_count</span><span class="s2">:</span>
                        <span class="s1">data </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">receive_some</span><span class="s2">()</span>
                        <span class="s0">if not </span><span class="s1">data</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming</span><span class="s2">.</span><span class="s1">write_eof</span><span class="s2">()</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_estimated_receive_size </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span>
                                <span class="s1">self</span><span class="s2">.</span><span class="s1">_estimated_receive_size</span><span class="s2">,</span>
                                <span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">),</span>
                            <span class="s2">)</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_recv_count </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s0">if not </span><span class="s1">yielded</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">ret</span>

    <span class="s0">async def </span><span class="s1">_do_handshake</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_retry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">do_handshake</span><span class="s2">, </span><span class="s1">is_handshake</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">except</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">BROKEN</span>
            <span class="s0">raise</span>

    <span class="s0">async def </span><span class="s1">do_handshake</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Ensure that the initial handshake has completed. 
 
        The SSL protocol requires an initial handshake to exchange 
        certificates, select cryptographic keys, and so forth, before any 
        actual data can be sent or received. You don't have to call this 
        method; if you don't, then :class:`SSLStream` will automatically 
        perform the handshake as needed, the first time you try to send or 
        receive data. But if you want to trigger it manually â€“ for example, 
        because you want to look at the peer's certificate before you start 
        talking to them â€“ then you can call this method. 
 
        If the initial handshake is already in progress in another task, this 
        waits for it to complete and then returns. 
 
        If the initial handshake has already completed, this returns 
        immediately without doing anything (except executing a checkpoint). 
 
        .. warning:: If this method is cancelled, then it may leave the 
           :class:`SSLStream` in an unusable state. If this happens then any 
           future attempt to use the object will raise 
           :exc:`trio.BrokenResourceError`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_status</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">checkpoint</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s4"># Most things work if we don't explicitly force do_handshake to be called</span>
    <span class="s4"># before calling receive_some or send_all, because openssl will</span>
    <span class="s4"># automatically perform the handshake on the first SSL_{read,write}</span>
    <span class="s4"># call. BUT, allowing openssl to do this will disable Python's hostname</span>
    <span class="s4"># checking!!! See:</span>
    <span class="s4">#   https://bugs.python.org/issue30141</span>
    <span class="s4"># So we *definitely* have to make sure that do_handshake is called</span>
    <span class="s4"># before doing anything else.</span>
    <span class="s0">async def </span><span class="s1">receive_some</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">max_bytes</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; bytes </span><span class="s2">| </span><span class="s1">bytearray</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Read some data from the underlying transport, decrypt it, and 
        return it. 
 
        See :meth:`trio.abc.ReceiveStream.receive_some` for details. 
 
        .. warning:: If this method is cancelled while the initial handshake 
           or a renegotiation are in progress, then it may leave the 
           :class:`SSLStream` in an unusable state. If this happens then any 
           future attempt to use the object will raise 
           :exc:`trio.BrokenResourceError`. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_recv_conflict_detector</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_status</span><span class="s2">()</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">checkpoint</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s4"># For some reason, EOF before handshake sometimes raises</span>
                <span class="s4"># SSLSyscallError instead of SSLEOFError (e.g. on my linux</span>
                <span class="s4"># laptop, but not on appveyor). Thanks openssl.</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible </span><span class="s0">and </span><span class="s2">(</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">, </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLSyscallError</span><span class="s2">)</span>
                    <span class="s0">or </span><span class="s1">_is_eof</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
                    <span class="s0">return </span><span class="s7">b&quot;&quot;</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise</span>
            <span class="s0">if </span><span class="s1">max_bytes </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s4"># If we somehow have more data already in our pending buffer</span>
                <span class="s4"># than the estimate receive size, bump up our size a bit for</span>
                <span class="s4"># this read only.</span>
                <span class="s1">max_bytes </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_estimated_receive_size</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming</span><span class="s2">.</span><span class="s1">pending</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">max_bytes </span><span class="s2">= </span><span class="s1">_operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">max_bytes</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">max_bytes </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;max_bytes must be &gt;= 1&quot;</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">received </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_retry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">read</span><span class="s2">, </span><span class="s1">max_bytes</span><span class="s2">)</span>
                <span class="s0">assert </span><span class="s1">received </span><span class="s0">is not None</span>
                <span class="s0">return </span><span class="s1">received</span>
            <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s4"># This isn't quite equivalent to just returning b&quot;&quot; in the</span>
                <span class="s4"># first place, because we still end up with self._state set to</span>
                <span class="s4"># BROKEN. But that's actually fine, because after getting an</span>
                <span class="s4"># EOF on TLS then the only thing you can do is close the</span>
                <span class="s4"># stream, and closing doesn't care about the state.</span>

                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible </span><span class="s0">and </span><span class="s1">_is_eof</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">):</span>
                    <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
                    <span class="s0">return </span><span class="s7">b&quot;&quot;</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise</span>

    <span class="s0">async def </span><span class="s1">send_all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">: </span><span class="s1">bytes </span><span class="s2">| </span><span class="s1">bytearray </span><span class="s2">| </span><span class="s1">memoryview</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Encrypt some data and then send it on the underlying transport. 
 
        See :meth:`trio.abc.SendStream.send_all` for details. 
 
        .. warning:: If this method is cancelled, then it may leave the 
           :class:`SSLStream` in an unusable state. If this happens then any 
           attempt to use the object will raise 
           :exc:`trio.BrokenResourceError`. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_send_conflict_detector</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_status</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">checkpoint</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s4"># SSLObject interprets write(b&quot;&quot;) as an EOF for some reason, which</span>
            <span class="s4"># is not what we want.</span>
            <span class="s0">if not </span><span class="s1">data</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
                <span class="s0">return</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_retry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">write</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">unwrap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Stream</span><span class="s2">, </span><span class="s1">bytes </span><span class="s2">| </span><span class="s1">bytearray</span><span class="s2">]:</span>
        <span class="s6">&quot;&quot;&quot;Cleanly close down the SSL/TLS encryption layer, allowing the 
        underlying stream to be used for unencrypted communication. 
 
        You almost certainly don't need this. 
 
        Returns: 
          A pair ``(transport_stream, trailing_bytes)``, where 
          ``transport_stream`` is the underlying transport stream, and 
          ``trailing_bytes`` is a byte string. Since :class:`SSLStream` 
          doesn't necessarily know where the end of the encrypted data will 
          be, it can happen that it accidentally reads too much from the 
          underlying stream. ``trailing_bytes`` contains this extra data; you 
          should process it as if it was returned from a call to 
          ``transport_stream.receive_some(...)``. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_recv_conflict_detector</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_send_conflict_detector</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_status</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">checkpoint</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_retry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">unwrap</span><span class="s2">)</span>
            <span class="s1">transport_stream </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">CLOSED</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream </span><span class="s2">= </span><span class="s0">None  </span><span class="s4"># type: ignore[assignment]  # State is CLOSED now, nothing should use</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">transport_stream</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_incoming</span><span class="s2">.</span><span class="s1">read</span><span class="s2">())</span>

    <span class="s0">async def </span><span class="s1">aclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Gracefully shut down this connection, and close the underlying 
        transport. 
 
        If ``https_compatible`` is False (the default), then this attempts to 
        first send a ``close_notify`` and then close the underlying stream by 
        calling its :meth:`~trio.abc.AsyncResource.aclose` method. 
 
        If ``https_compatible`` is set to True, then this simply closes the 
        underlying stream and marks this stream as closed. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s0">is </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">CLOSED</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s0">is </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">BROKEN </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">CLOSED</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
            <span class="s0">return</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s4"># https_compatible=False, so we're in spec-compliant mode and have</span>
            <span class="s4"># to send close_notify so that the other side gets a cryptographic</span>
            <span class="s4"># assurance that we've called aclose. Of course, we can't do</span>
            <span class="s4"># anything cryptographic until after we've completed the</span>
            <span class="s4"># handshake:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshook</span><span class="s2">.</span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">checkpoint</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s4"># Then, we call SSL_shutdown *once*, because we want to send a</span>
            <span class="s4"># close_notify but *not* wait for the other side to send back a</span>
            <span class="s4"># response. In principle it would be more polite to wait for the</span>
            <span class="s4"># other side to reply with their own close_notify. However, if</span>
            <span class="s4"># they aren't paying attention (e.g., if they're just sending</span>
            <span class="s4"># data and not receiving) then we will never notice our</span>
            <span class="s4"># close_notify and we'll be waiting forever. Eventually we'll time</span>
            <span class="s4"># out (hopefully), but it's still kind of nasty. And we can't</span>
            <span class="s4"># require the other side to always be receiving, because (a)</span>
            <span class="s4"># backpressure is kind of important, and (b) I bet there are</span>
            <span class="s4"># broken TLS implementations out there that don't receive all the</span>
            <span class="s4"># time. (Like e.g. anyone using Python ssl in synchronous mode.)</span>
            <span class="s4">#</span>
            <span class="s4"># The send-then-immediately-close behavior is explicitly allowed</span>
            <span class="s4"># by the TLS specs, so we're ok on that.</span>
            <span class="s4">#</span>
            <span class="s4"># Subtlety: SSLObject.unwrap will immediately call it a second</span>
            <span class="s4"># time, and the second time will raise SSLWantReadError because</span>
            <span class="s4"># there hasn't been time for the other side to respond</span>
            <span class="s4"># yet. (Unless they spontaneously sent a close_notify before we</span>
            <span class="s4"># called this, and it's either already been processed or gets</span>
            <span class="s4"># pulled out of the buffer by Python's second call.) So the way to</span>
            <span class="s4"># do what we want is to ignore SSLWantReadError on this call.</span>
            <span class="s4">#</span>
            <span class="s4"># Also, because the other side might have already sent</span>
            <span class="s4"># close_notify and closed their connection then it's possible that</span>
            <span class="s4"># our attempt to send close_notify will raise</span>
            <span class="s4"># BrokenResourceError. This is totally legal, and in fact can happen</span>
            <span class="s4"># with two well-behaved Trio programs talking to each other, so we</span>
            <span class="s4"># don't want to raise an error. So we suppress BrokenResourceError</span>
            <span class="s4"># here. (This is safe, because literally the only thing this call</span>
            <span class="s4"># to _retry will do is send the close_notify alert, so that's</span>
            <span class="s4"># surely where the error comes from.)</span>
            <span class="s4">#</span>
            <span class="s4"># FYI in some cases this could also raise SSLSyscallError which I</span>
            <span class="s4"># think is because SSL_shutdown is terrible. (Check out that note</span>
            <span class="s4"># at the bottom of the man page saying that it sometimes gets</span>
            <span class="s4"># raised spuriously.) I haven't seen this since we switched to</span>
            <span class="s4"># immediately closing the socket, and I don't know exactly what</span>
            <span class="s4"># conditions cause it and how to respond, so for now we're just</span>
            <span class="s4"># letting that happen. But if you start seeing it, then hopefully</span>
            <span class="s4"># this will give you a little head start on tracking it down,</span>
            <span class="s4"># because whoa did this puzzle us at the 2017 PyCon sprints.</span>
            <span class="s4">#</span>
            <span class="s4"># Also, if someone else is blocked in send/receive, then we aren't</span>
            <span class="s4"># going to be able to do a clean shutdown. If that happens, we'll</span>
            <span class="s4"># just do an unclean shutdown.</span>
            <span class="s0">with </span><span class="s1">contextlib</span><span class="s2">.</span><span class="s1">suppress</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BusyResourceError</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_retry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_object</span><span class="s2">.</span><span class="s1">unwrap</span><span class="s2">, </span><span class="s1">ignore_want_read</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">except</span><span class="s2">:</span>
            <span class="s4"># Failure! Kill the stream and move on.</span>
            <span class="s0">await </span><span class="s1">aclose_forcefully</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">)</span>
            <span class="s0">raise</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Success! Gracefully close the underlying stream.</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_state </span><span class="s2">= </span><span class="s1">_State</span><span class="s2">.</span><span class="s1">CLOSED</span>

    <span class="s0">async def </span><span class="s1">wait_send_all_might_not_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;See :meth:`trio.abc.SendStream.wait_send_all_might_not_block`.&quot;&quot;&quot;</span>
        <span class="s4"># This method's implementation is deceptively simple.</span>
        <span class="s4">#</span>
        <span class="s4"># First, we take the outer send lock, because of Trio's standard</span>
        <span class="s4"># semantics that wait_send_all_might_not_block and send_all</span>
        <span class="s4"># conflict.</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer_send_conflict_detector</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_status</span><span class="s2">()</span>
            <span class="s4"># Then we take the inner send lock. We know that no other tasks</span>
            <span class="s4"># are calling self.send_all or self.wait_send_all_might_not_block,</span>
            <span class="s4"># because we have the outer_send_lock. But! There might be another</span>
            <span class="s4"># task calling self.receive_some -&gt; transport_stream.send_all, in</span>
            <span class="s4"># which case if we were to call</span>
            <span class="s4"># transport_stream.wait_send_all_might_not_block directly we'd</span>
            <span class="s4"># have two tasks doing write-related operations on</span>
            <span class="s4"># transport_stream simultaneously, which is not allowed. We</span>
            <span class="s4"># *don't* want to raise this conflict to our caller, because it's</span>
            <span class="s4"># purely an internal affair â€“ all they did was call</span>
            <span class="s4"># wait_send_all_might_not_block and receive_some at the same time,</span>
            <span class="s4"># which is totally valid. And waiting for the lock is OK, because</span>
            <span class="s4"># a call to send_all certainly wouldn't complete while the other</span>
            <span class="s4"># task holds the lock.</span>
            <span class="s0">async with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inner_send_lock</span><span class="s2">:</span>
                <span class="s4"># Now we have the lock, which creates another potential</span>
                <span class="s4"># problem: what if a call to self.receive_some attempts to do</span>
                <span class="s4"># transport_stream.send_all now? It'll have to wait for us to</span>
                <span class="s4"># finish! But that's OK, because we release the lock as soon</span>
                <span class="s4"># as the underlying stream becomes writable, and the</span>
                <span class="s4"># self.receive_some call wasn't going to make any progress</span>
                <span class="s4"># until then anyway.</span>
                <span class="s4">#</span>
                <span class="s4"># Of course, this does mean we might return *before* the</span>
                <span class="s4"># stream is logically writable, because immediately after we</span>
                <span class="s4"># return self.receive_some might write some data and make it</span>
                <span class="s4"># non-writable again. But that's OK too,</span>
                <span class="s4"># wait_send_all_might_not_block only guarantees that it</span>
                <span class="s4"># doesn't return late.</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">wait_send_all_might_not_block</span><span class="s2">()</span>


<span class="s4"># this is necessary for Sphinx, see also `_abc.py`</span>
<span class="s1">SSLStream</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">SSLStream</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s3">&quot;._ssl&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">final</span>
<span class="s0">class </span><span class="s1">SSLListener</span><span class="s2">(</span><span class="s1">Listener</span><span class="s2">[</span><span class="s1">SSLStream</span><span class="s2">[</span><span class="s1">T_Stream</span><span class="s2">]]):</span>
    <span class="s6">&quot;&quot;&quot;A :class:`~trio.abc.Listener` for SSL/TLS-encrypted servers. 
 
    :class:`SSLListener` wraps around another Listener, and converts 
    all incoming connections to encrypted connections by wrapping them 
    in a :class:`SSLStream`. 
 
    Args: 
      transport_listener (~trio.abc.Listener): The listener whose incoming 
          connections will be wrapped in :class:`SSLStream`. 
 
      ssl_context (~ssl.SSLContext): The :class:`~ssl.SSLContext` that will be 
          used for incoming connections. 
 
      https_compatible (bool): Passed on to :class:`SSLStream`. 
 
    Attributes: 
      transport_listener (trio.abc.Listener): The underlying listener that was 
          passed to ``__init__``. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">transport_listener</span><span class="s2">: </span><span class="s1">Listener</span><span class="s2">[</span><span class="s1">T_Stream</span><span class="s2">],</span>
        <span class="s1">ssl_context</span><span class="s2">: </span><span class="s1">_stdlib_ssl</span><span class="s2">.</span><span class="s1">SSLContext</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">https_compatible</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">transport_listener </span><span class="s2">= </span><span class="s1">transport_listener</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_context </span><span class="s2">= </span><span class="s1">ssl_context</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible </span><span class="s2">= </span><span class="s1">https_compatible</span>

    <span class="s0">async def </span><span class="s1">accept</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; SSLStream</span><span class="s2">[</span><span class="s1">T_Stream</span><span class="s2">]:</span>
        <span class="s6">&quot;&quot;&quot;Accept the next connection and wrap it in an :class:`SSLStream`. 
 
        See :meth:`trio.abc.Listener.accept` for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">transport_stream </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_listener</span><span class="s2">.</span><span class="s1">accept</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">SSLStream</span><span class="s2">(</span>
            <span class="s1">transport_stream</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_ssl_context</span><span class="s2">,</span>
            <span class="s1">server_side</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">https_compatible</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_https_compatible</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">aclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Close the transport listener.&quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transport_listener</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
</pre>
</body>
</html>