<html>
<head>
<title>api_tests.txt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api_tests.txt</font>
</center></td></tr></table>
<pre><span class="s0">Pluggable Distributions of Python Software</span>
<span class="s0">==========================================</span>

<span class="s0">Distributions</span>
<span class="s0">-------------</span>

<span class="s0">A &quot;Distribution&quot; is a collection of files that represent a &quot;Release&quot; of a</span>
<span class="s0">&quot;Project&quot; as of a particular point in time, denoted by a</span>
<span class="s0">&quot;Version&quot;::</span>

    <span class="s0">&gt;&gt;&gt; import sys, pkg_resources</span>
    <span class="s0">&gt;&gt;&gt; from pkg_resources import Distribution</span>
    <span class="s0">&gt;&gt;&gt; Distribution(project_name=&quot;Foo&quot;, version=&quot;1.2&quot;)</span>
    <span class="s0">Foo 1.2</span>

<span class="s0">Distributions have a location, which can be a filename, URL, or really anything</span>
<span class="s0">else you care to use::</span>

    <span class="s0">&gt;&gt;&gt; dist = Distribution(</span>
    <span class="s0">...     location=&quot;http://example.com/something&quot;,</span>
    <span class="s0">...     project_name=&quot;Bar&quot;, version=&quot;0.9&quot;</span>
    <span class="s0">... )</span>

    <span class="s0">&gt;&gt;&gt; dist</span>
    <span class="s0">Bar 0.9 (http://example.com/something)</span>


<span class="s0">Distributions have various introspectable attributes::</span>

    <span class="s0">&gt;&gt;&gt; dist.location</span>
    <span class="s0">'http://example.com/something'</span>

    <span class="s0">&gt;&gt;&gt; dist.project_name</span>
    <span class="s0">'Bar'</span>

    <span class="s0">&gt;&gt;&gt; dist.version</span>
    <span class="s0">'0.9'</span>

    <span class="s0">&gt;&gt;&gt; dist.py_version == '{}.{}'.format(*sys.version_info)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; print(dist.platform)</span>
    <span class="s0">None</span>

<span class="s0">Including various computed attributes::</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import parse_version</span>
    <span class="s0">&gt;&gt;&gt; dist.parsed_version == parse_version(dist.version)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; dist.key    # case-insensitive form of the project name</span>
    <span class="s0">'bar'</span>

<span class="s0">Distributions are compared (and hashed) by version first::</span>

    <span class="s0">&gt;&gt;&gt; Distribution(version='1.0') == Distribution(version='1.0')</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; Distribution(version='1.0') == Distribution(version='1.1')</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; Distribution(version='1.0') &lt;  Distribution(version='1.1')</span>
    <span class="s0">True</span>

<span class="s0">but also by project name (case-insensitive), platform, Python version,</span>
<span class="s0">location, etc.::</span>

    <span class="s0">&gt;&gt;&gt; Distribution(project_name=&quot;Foo&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(project_name=&quot;Foo&quot;,version=&quot;1.0&quot;)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; Distribution(project_name=&quot;Foo&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(project_name=&quot;foo&quot;,version=&quot;1.0&quot;)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; Distribution(project_name=&quot;Foo&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(project_name=&quot;Foo&quot;,version=&quot;1.1&quot;)</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; Distribution(project_name=&quot;Foo&quot;,py_version=&quot;2.3&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(project_name=&quot;Foo&quot;,py_version=&quot;2.4&quot;,version=&quot;1.0&quot;)</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; Distribution(location=&quot;spam&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(location=&quot;spam&quot;,version=&quot;1.0&quot;)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; Distribution(location=&quot;spam&quot;,version=&quot;1.0&quot;) == \</span>
    <span class="s0">... Distribution(location=&quot;baz&quot;,version=&quot;1.0&quot;)</span>
    <span class="s0">False</span>



<span class="s0">Hash and compare distribution by prio/plat</span>

<span class="s0">Get version from metadata</span>
<span class="s0">provider capabilities</span>
<span class="s0">egg_name()</span>
<span class="s0">as_requirement()</span>
<span class="s0">from_location, from_filename (w/path normalization)</span>

<span class="s0">Releases may have zero or more &quot;Requirements&quot;, which indicate</span>
<span class="s0">what releases of another project the release requires in order to</span>
<span class="s0">function.  A Requirement names the other project, expresses some criteria</span>
<span class="s0">as to what releases of that project are acceptable, and lists any &quot;Extras&quot;</span>
<span class="s0">that the requiring release may need from that project.  (An Extra is an</span>
<span class="s0">optional feature of a Release, that can only be used if its additional</span>
<span class="s0">Requirements are satisfied.)</span>



<span class="s0">The Working Set</span>
<span class="s0">---------------</span>

<span class="s0">A collection of active distributions is called a Working Set.  Note that a</span>
<span class="s0">Working Set can contain any importable distribution, not just pluggable ones.</span>
<span class="s0">For example, the Python standard library is an importable distribution that</span>
<span class="s0">will usually be part of the Working Set, even though it is not pluggable.</span>
<span class="s0">Similarly, when you are doing development work on a project, the files you are</span>
<span class="s0">editing are also a Distribution.  (And, with a little attention to the</span>
<span class="s0">directory names used,  and including some additional metadata, such a</span>
<span class="s0">&quot;development distribution&quot; can be made pluggable as well.)</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import WorkingSet</span>

<span class="s0">A working set's entries are the sys.path entries that correspond to the active</span>
<span class="s0">distributions.  By default, the working set's entries are the items on</span>
<span class="s0">``sys.path``::</span>

    <span class="s0">&gt;&gt;&gt; ws = WorkingSet()</span>
    <span class="s0">&gt;&gt;&gt; ws.entries == sys.path</span>
    <span class="s0">True</span>

<span class="s0">But you can also create an empty working set explicitly, and add distributions</span>
<span class="s0">to it::</span>

    <span class="s0">&gt;&gt;&gt; ws = WorkingSet([])</span>
    <span class="s0">&gt;&gt;&gt; ws.add(dist)</span>
    <span class="s0">&gt;&gt;&gt; ws.entries</span>
    <span class="s0">['http://example.com/something']</span>
    <span class="s0">&gt;&gt;&gt; dist in ws</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; Distribution('foo',version=&quot;&quot;) in ws</span>
    <span class="s0">False</span>

<span class="s0">And you can iterate over its distributions::</span>

    <span class="s0">&gt;&gt;&gt; list(ws)</span>
    <span class="s0">[Bar 0.9 (http://example.com/something)]</span>

<span class="s0">Adding the same distribution more than once is a no-op::</span>

    <span class="s0">&gt;&gt;&gt; ws.add(dist)</span>
    <span class="s0">&gt;&gt;&gt; list(ws)</span>
    <span class="s0">[Bar 0.9 (http://example.com/something)]</span>

<span class="s0">For that matter, adding multiple distributions for the same project also does</span>
<span class="s0">nothing, because a working set can only hold one active distribution per</span>
<span class="s0">project -- the first one added to it::</span>

    <span class="s0">&gt;&gt;&gt; ws.add(</span>
    <span class="s0">...     Distribution(</span>
    <span class="s0">...         'http://example.com/something', project_name=&quot;Bar&quot;,</span>
    <span class="s0">...         version=&quot;7.2&quot;</span>
    <span class="s0">...     )</span>
    <span class="s0">... )</span>
    <span class="s0">&gt;&gt;&gt; list(ws)</span>
    <span class="s0">[Bar 0.9 (http://example.com/something)]</span>

<span class="s0">You can append a path entry to a working set using ``add_entry()``::</span>

    <span class="s0">&gt;&gt;&gt; ws.entries</span>
    <span class="s0">['http://example.com/something']</span>
    <span class="s0">&gt;&gt;&gt; ws.add_entry(pkg_resources.__file__)</span>
    <span class="s0">&gt;&gt;&gt; ws.entries</span>
    <span class="s0">['http://example.com/something', '...pkg_resources...']</span>

<span class="s0">Multiple additions result in multiple entries, even if the entry is already in</span>
<span class="s0">the working set (because ``sys.path`` can contain the same entry more than</span>
<span class="s0">once)::</span>

    <span class="s0">&gt;&gt;&gt; ws.add_entry(pkg_resources.__file__)</span>
    <span class="s0">&gt;&gt;&gt; ws.entries</span>
    <span class="s0">['...example.com...', '...pkg_resources...', '...pkg_resources...']</span>

<span class="s0">And you can specify the path entry a distribution was found under, using the</span>
<span class="s0">optional second parameter to ``add()``::</span>

    <span class="s0">&gt;&gt;&gt; ws = WorkingSet([])</span>
    <span class="s0">&gt;&gt;&gt; ws.add(dist,&quot;foo&quot;)</span>
    <span class="s0">&gt;&gt;&gt; ws.entries</span>
    <span class="s0">['foo']</span>

<span class="s0">But even if a distribution is found under multiple path entries, it still only</span>
<span class="s0">shows up once when iterating the working set:</span>

    <span class="s0">&gt;&gt;&gt; ws.add_entry(ws.entries[0])</span>
    <span class="s0">&gt;&gt;&gt; list(ws)</span>
    <span class="s0">[Bar 0.9 (http://example.com/something)]</span>

<span class="s0">You can ask a WorkingSet to ``find()`` a distribution matching a requirement::</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import Requirement</span>
    <span class="s0">&gt;&gt;&gt; print(ws.find(Requirement.parse(&quot;Foo==1.0&quot;)))   # no match, return None</span>
    <span class="s0">None</span>

    <span class="s0">&gt;&gt;&gt; ws.find(Requirement.parse(&quot;Bar==0.9&quot;))  # match, return distribution</span>
    <span class="s0">Bar 0.9 (http://example.com/something)</span>

<span class="s0">Note that asking for a conflicting version of a distribution already in a</span>
<span class="s0">working set triggers a ``pkg_resources.VersionConflict`` error:</span>

    <span class="s0">&gt;&gt;&gt; try:</span>
    <span class="s0">...     ws.find(Requirement.parse(&quot;Bar==1.0&quot;))</span>
    <span class="s0">... except pkg_resources.VersionConflict as exc:</span>
    <span class="s0">...     print(str(exc))</span>
    <span class="s0">... else:</span>
    <span class="s0">...     raise AssertionError(&quot;VersionConflict was not raised&quot;)</span>
    <span class="s0">(Bar 0.9 (http://example.com/something), Requirement.parse('Bar==1.0'))</span>

<span class="s0">You can subscribe a callback function to receive notifications whenever a new</span>
<span class="s0">distribution is added to a working set.  The callback is immediately invoked</span>
<span class="s0">once for each existing distribution in the working set, and then is called</span>
<span class="s0">again for new distributions added thereafter::</span>

    <span class="s0">&gt;&gt;&gt; def added(dist): print(&quot;Added %s&quot; % dist)</span>
    <span class="s0">&gt;&gt;&gt; ws.subscribe(added)</span>
    <span class="s0">Added Bar 0.9</span>
    <span class="s0">&gt;&gt;&gt; foo12 = Distribution(project_name=&quot;Foo&quot;, version=&quot;1.2&quot;, location=&quot;f12&quot;)</span>
    <span class="s0">&gt;&gt;&gt; ws.add(foo12)</span>
    <span class="s0">Added Foo 1.2</span>

<span class="s0">Note, however, that only the first distribution added for a given project name</span>
<span class="s0">will trigger a callback, even during the initial ``subscribe()`` callback::</span>

    <span class="s0">&gt;&gt;&gt; foo14 = Distribution(project_name=&quot;Foo&quot;, version=&quot;1.4&quot;, location=&quot;f14&quot;)</span>
    <span class="s0">&gt;&gt;&gt; ws.add(foo14)   # no callback, because Foo 1.2 is already active</span>

    <span class="s0">&gt;&gt;&gt; ws = WorkingSet([])</span>
    <span class="s0">&gt;&gt;&gt; ws.add(foo12)</span>
    <span class="s0">&gt;&gt;&gt; ws.add(foo14)</span>
    <span class="s0">&gt;&gt;&gt; ws.subscribe(added)</span>
    <span class="s0">Added Foo 1.2</span>

<span class="s0">And adding a callback more than once has no effect, either::</span>

    <span class="s0">&gt;&gt;&gt; ws.subscribe(added)     # no callbacks</span>

    <span class="s0"># and no double-callbacks on subsequent additions, either</span>
    <span class="s0">&gt;&gt;&gt; just_a_test = Distribution(project_name=&quot;JustATest&quot;, version=&quot;0.99&quot;)</span>
    <span class="s0">&gt;&gt;&gt; ws.add(just_a_test)</span>
    <span class="s0">Added JustATest 0.99</span>


<span class="s0">Finding Plugins</span>
<span class="s0">---------------</span>

<span class="s0">``WorkingSet`` objects can be used to figure out what plugins in an</span>
<span class="s0">``Environment`` can be loaded without any resolution errors::</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import Environment</span>

    <span class="s0">&gt;&gt;&gt; plugins = Environment([])   # normally, a list of plugin directories</span>
    <span class="s0">&gt;&gt;&gt; plugins.add(foo12)</span>
    <span class="s0">&gt;&gt;&gt; plugins.add(foo14)</span>
    <span class="s0">&gt;&gt;&gt; plugins.add(just_a_test)</span>

<span class="s0">In the simplest case, we just get the newest version of each distribution in</span>
<span class="s0">the plugin environment::</span>

    <span class="s0">&gt;&gt;&gt; ws = WorkingSet([])</span>
    <span class="s0">&gt;&gt;&gt; ws.find_plugins(plugins)</span>
    <span class="s0">([JustATest 0.99, Foo 1.4 (f14)], {})</span>

<span class="s0">But if there's a problem with a version conflict or missing requirements, the</span>
<span class="s0">method falls back to older versions, and the error info dict will contain an</span>
<span class="s0">exception instance for each unloadable plugin::</span>

    <span class="s0">&gt;&gt;&gt; ws.add(foo12)   # this will conflict with Foo 1.4</span>
    <span class="s0">&gt;&gt;&gt; ws.find_plugins(plugins)</span>
    <span class="s0">([JustATest 0.99, Foo 1.2 (f12)], {Foo 1.4 (f14): VersionConflict(...)})</span>

<span class="s0">But if you disallow fallbacks, the failed plugin will be skipped instead of</span>
<span class="s0">trying older versions::</span>

    <span class="s0">&gt;&gt;&gt; ws.find_plugins(plugins, fallback=False)</span>
    <span class="s0">([JustATest 0.99], {Foo 1.4 (f14): VersionConflict(...)})</span>



<span class="s0">Platform Compatibility Rules</span>
<span class="s0">----------------------------</span>

<span class="s0">On the Mac, there are potential compatibility issues for modules compiled</span>
<span class="s0">on newer versions of macOS than what the user is running. Additionally,</span>
<span class="s0">macOS will soon have two platforms to contend with: Intel and PowerPC.</span>

<span class="s0">Basic equality works as on other platforms::</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import compatible_platforms as cp</span>
    <span class="s0">&gt;&gt;&gt; reqd = 'macosx-10.4-ppc'</span>
    <span class="s0">&gt;&gt;&gt; cp(reqd, reqd)</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;win32&quot;, reqd)</span>
    <span class="s0">False</span>

<span class="s0">Distributions made on other machine types are not compatible::</span>

    <span class="s0">&gt;&gt;&gt; cp(&quot;macosx-10.4-i386&quot;, reqd)</span>
    <span class="s0">False</span>

<span class="s0">Distributions made on earlier versions of the OS are compatible, as</span>
<span class="s0">long as they are from the same top-level version. The patchlevel version</span>
<span class="s0">number does not matter::</span>

    <span class="s0">&gt;&gt;&gt; cp(&quot;macosx-10.4-ppc&quot;, reqd)</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;macosx-10.3-ppc&quot;, reqd)</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;macosx-10.5-ppc&quot;, reqd)</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;macosx-9.5-ppc&quot;, reqd)</span>
    <span class="s0">False</span>

<span class="s0">Backwards compatibility for packages made via earlier versions of</span>
<span class="s0">setuptools is provided as well::</span>

    <span class="s0">&gt;&gt;&gt; cp(&quot;darwin-8.2.0-Power_Macintosh&quot;, reqd)</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;darwin-7.2.0-Power_Macintosh&quot;, reqd)</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; cp(&quot;darwin-8.2.0-Power_Macintosh&quot;, &quot;macosx-10.3-ppc&quot;)</span>
    <span class="s0">False</span>


<span class="s0">Environment Markers</span>
<span class="s0">-------------------</span>

    <span class="s0">&gt;&gt;&gt; from pkg_resources import invalid_marker as im, evaluate_marker as em</span>
    <span class="s0">&gt;&gt;&gt; import os</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;sys_platform&quot;))</span>
    <span class="s0">Expected marker operator, one of &lt;=, &lt;, !=, ==, &gt;=, &gt;, ~=, ===, in, not in</span>
        <span class="s0">sys_platform</span>
                    <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;sys_platform==&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">sys_platform==</span>
                      <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;sys_platform=='win32'&quot;))</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;sys=='x'&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">sys=='x'</span>
        <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;(extra)&quot;))</span>
    <span class="s0">Expected marker operator, one of &lt;=, &lt;, !=, ==, &gt;=, &gt;, ~=, ===, in, not in</span>
        <span class="s0">(extra)</span>
              <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;(extra&quot;))</span>
    <span class="s0">Expected marker operator, one of &lt;=, &lt;, !=, ==, &gt;=, &gt;, ~=, ===, in, not in</span>
        <span class="s0">(extra</span>
              <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;os.open('foo')=='y'&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">os.open('foo')=='y'</span>
        <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;'x'=='y' and os.open('foo')=='y'&quot;))   # no short-circuit!</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">'x'=='y' and os.open('foo')=='y'</span>
                     <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;'x'=='x' or os.open('foo')=='y'&quot;))   # no short-circuit!</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">'x'=='x' or os.open('foo')=='y'</span>
                    <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;r'x'=='x'&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">r'x'=='x'</span>
        <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;'''x'''=='x'&quot;))</span>
    <span class="s0">Expected marker operator, one of &lt;=, &lt;, !=, ==, &gt;=, &gt;, ~=, ===, in, not in</span>
        <span class="s0">'''x'''=='x'</span>
          <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im('&quot;&quot;&quot;x&quot;&quot;&quot;==&quot;x&quot;'))</span>
    <span class="s0">Expected marker operator, one of &lt;=, &lt;, !=, ==, &gt;=, &gt;, ~=, ===, in, not in</span>
        <span class="s0">&quot;&quot;&quot;x&quot;&quot;&quot;==&quot;x&quot;</span>
          <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(r&quot;x\n=='x'&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">x\n=='x'</span>
        <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; print(im(&quot;os.open=='y'&quot;))</span>
    <span class="s0">Expected a marker variable or quoted string</span>
        <span class="s0">os.open=='y'</span>
        <span class="s0">^</span>

    <span class="s0">&gt;&gt;&gt; em(&quot;sys_platform=='win32'&quot;) == (sys.platform=='win32')</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; em(&quot;python_version &gt;= '2.7'&quot;)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; em(&quot;python_version &gt; '2.6'&quot;)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; im(&quot;implementation_name=='cpython'&quot;)</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; im(&quot;platform_python_implementation=='CPython'&quot;)</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; im(&quot;implementation_version=='3.5.1'&quot;)</span>
    <span class="s0">False</span>
</pre>
</body>
</html>