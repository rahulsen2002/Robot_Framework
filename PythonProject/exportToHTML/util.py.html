<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.util 
 
Miscellaneous utility functions -- anything that doesn't fit into 
one of the other *util.py modules. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">util</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pathlib</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">sysconfig</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">AnyStr</span>

<span class="s2">from </span><span class="s1">jaraco</span><span class="s3">.</span><span class="s1">functools </span><span class="s2">import </span><span class="s1">pass_none</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_log </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_modified </span><span class="s2">import </span><span class="s1">newer</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">DistutilsByteCompileError</span><span class="s3">, </span><span class="s1">DistutilsPlatformError</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">spawn </span><span class="s2">import </span><span class="s1">spawn</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">TypeVarTuple</span><span class="s3">, </span><span class="s1">Unpack</span>

    <span class="s1">_Ts </span><span class="s3">= </span><span class="s1">TypeVarTuple</span><span class="s3">(</span><span class="s4">&quot;_Ts&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_host_platform</span><span class="s3">() </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string that identifies the current platform. Use this 
    function to distinguish platform-specific build directories and 
    platform-specific built distributions. 
    &quot;&quot;&quot;</span>

    <span class="s5"># This function initially exposed platforms as defined in Python 3.9</span>
    <span class="s5"># even with older Python versions when distutils was split out.</span>
    <span class="s5"># Now it delegates to stdlib sysconfig.</span>

    <span class="s2">return </span><span class="s1">sysconfig</span><span class="s3">.</span><span class="s1">get_platform</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">get_platform</span><span class="s3">() </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'nt'</span><span class="s3">:</span>
        <span class="s1">TARGET_TO_PLAT </span><span class="s3">= {</span>
            <span class="s4">'x86'</span><span class="s3">: </span><span class="s4">'win32'</span><span class="s3">,</span>
            <span class="s4">'x64'</span><span class="s3">: </span><span class="s4">'win-amd64'</span><span class="s3">,</span>
            <span class="s4">'arm'</span><span class="s3">: </span><span class="s4">'win-arm32'</span><span class="s3">,</span>
            <span class="s4">'arm64'</span><span class="s3">: </span><span class="s4">'win-arm64'</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">target </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'VSCMD_ARG_TGT_ARCH'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">TARGET_TO_PLAT</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">target</span><span class="s3">) </span><span class="s2">or </span><span class="s1">get_host_platform</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">get_host_platform</span><span class="s3">()</span>


<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">'darwin'</span><span class="s3">:</span>
    <span class="s1">_syscfg_macosx_ver </span><span class="s3">= </span><span class="s2">None  </span><span class="s5"># cache the version pulled from sysconfig</span>
<span class="s1">MACOSX_VERSION_VAR </span><span class="s3">= </span><span class="s4">'MACOSX_DEPLOYMENT_TARGET'</span>


<span class="s2">def </span><span class="s1">_clear_cached_macosx_ver</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;For testing only. Do not call.&quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_syscfg_macosx_ver</span>
    <span class="s1">_syscfg_macosx_ver </span><span class="s3">= </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">get_macosx_target_ver_from_syscfg</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Get the version of macOS latched in the Python interpreter configuration. 
    Returns the version as a string or None if can't obtain one. Cached.&quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_syscfg_macosx_ver</span>
    <span class="s2">if </span><span class="s1">_syscfg_macosx_ver </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">sysconfig</span>

        <span class="s1">ver </span><span class="s3">= </span><span class="s1">sysconfig</span><span class="s3">.</span><span class="s1">get_config_var</span><span class="s3">(</span><span class="s1">MACOSX_VERSION_VAR</span><span class="s3">) </span><span class="s2">or </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">ver</span><span class="s3">:</span>
            <span class="s1">_syscfg_macosx_ver </span><span class="s3">= </span><span class="s1">ver</span>
    <span class="s2">return </span><span class="s1">_syscfg_macosx_ver</span>


<span class="s2">def </span><span class="s1">get_macosx_target_ver</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Return the version of macOS for which we are building. 
 
    The target version defaults to the version in sysconfig latched at time 
    the Python interpreter was built, unless overridden by an environment 
    variable. If neither source has a value, then None is returned&quot;&quot;&quot;</span>

    <span class="s1">syscfg_ver </span><span class="s3">= </span><span class="s1">get_macosx_target_ver_from_syscfg</span><span class="s3">()</span>
    <span class="s1">env_ver </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">MACOSX_VERSION_VAR</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">env_ver</span><span class="s3">:</span>
        <span class="s5"># Validate overridden version against sysconfig version, if have both.</span>
        <span class="s5"># Ensure that the deployment target of the build process is not less</span>
        <span class="s5"># than 10.3 if the interpreter was built for 10.3 or later.  This</span>
        <span class="s5"># ensures extension modules are built with correct compatibility</span>
        <span class="s5"># values, specifically LDSHARED which can use</span>
        <span class="s5"># '-undefined dynamic_lookup' which only works on &gt;= 10.3.</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">syscfg_ver</span>
            <span class="s2">and </span><span class="s1">split_version</span><span class="s3">(</span><span class="s1">syscfg_ver</span><span class="s3">) &gt;= [</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">]</span>
            <span class="s2">and </span><span class="s1">split_version</span><span class="s3">(</span><span class="s1">env_ver</span><span class="s3">) &lt; [</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">]</span>
        <span class="s3">):</span>
            <span class="s1">my_msg </span><span class="s3">= (</span>
                <span class="s4">'$' </span><span class="s3">+ </span><span class="s1">MACOSX_VERSION_VAR </span><span class="s3">+ </span><span class="s4">' mismatch: '</span>
                <span class="s4">f'now &quot;</span><span class="s2">{</span><span class="s1">env_ver</span><span class="s2">}</span><span class="s4">&quot; but &quot;</span><span class="s2">{</span><span class="s1">syscfg_ver</span><span class="s2">}</span><span class="s4">&quot; during configure; '</span>
                <span class="s4">'must use 10.3 or later'</span>
            <span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">DistutilsPlatformError</span><span class="s3">(</span><span class="s1">my_msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">env_ver</span>
    <span class="s2">return </span><span class="s1">syscfg_ver</span>


<span class="s2">def </span><span class="s1">split_version</span><span class="s3">(</span><span class="s1">s</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Convert a dot-separated string into a list of numbers for comparisons&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">s</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)]</span>


<span class="s3">@</span><span class="s1">pass_none</span>
<span class="s2">def </span><span class="s1">convert_path</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Allow for pathlib.Path inputs, coax to a native path string. 
 
    If None is passed, will just pass it through as 
    Setuptools relies on this behavior. 
 
    &gt;&gt;&gt; convert_path(None) is None 
    True 
 
    Removes empty paths. 
 
    &gt;&gt;&gt; convert_path('foo/./bar').replace('\\', '/') 
    'foo/bar' 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">fspath</span><span class="s3">(</span><span class="s1">pathlib</span><span class="s3">.</span><span class="s1">PurePath</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">change_root</span><span class="s3">(</span>
    <span class="s1">new_root</span><span class="s3">: </span><span class="s1">AnyStr </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">[</span><span class="s1">AnyStr</span><span class="s3">], </span><span class="s1">pathname</span><span class="s3">: </span><span class="s1">AnyStr </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">[</span><span class="s1">AnyStr</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; AnyStr</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return 'pathname' with 'new_root' prepended.  If 'pathname' is 
    relative, this is equivalent to &quot;os.path.join(new_root,pathname)&quot;. 
    Otherwise, it requires making 'pathname' relative and then joining the 
    two, which is tricky on DOS/Windows and Mac OS. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'posix'</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isabs</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">new_root</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">new_root</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:])</span>

    <span class="s2">elif </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'nt'</span><span class="s3">:</span>
        <span class="s3">(</span><span class="s1">drive</span><span class="s3">, </span><span class="s1">path</span><span class="s3">) = </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">splitdrive</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">path</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">os</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>
        <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">new_root</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">raise </span><span class="s1">DistutilsPlatformError</span><span class="s3">(</span><span class="s4">f&quot;nothing known about platform '</span><span class="s2">{</span><span class="s1">os</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">functools</span><span class="s3">.</span><span class="s1">lru_cache</span>
<span class="s2">def </span><span class="s1">check_environ</span><span class="s3">() </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Ensure that 'os.environ' has all the environment variables we 
    guarantee that users can use in config files, command-line options, 
    etc.  Currently this includes: 
      HOME - user's home directory (Unix only) 
      PLAT - description of the current platform, including hardware 
             and OS (see 'get_platform()') 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'posix' </span><span class="s2">and </span><span class="s4">'HOME' </span><span class="s2">not in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">pwd</span>

            <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s4">'HOME'</span><span class="s3">] = </span><span class="s1">pwd</span><span class="s3">.</span><span class="s1">getpwuid</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">getuid</span><span class="s3">())[</span><span class="s6">5</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">ImportError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
            <span class="s5"># bpo-10496: if the current user identifier doesn't exist in the</span>
            <span class="s5"># password database, do nothing</span>
            <span class="s2">pass</span>

    <span class="s2">if </span><span class="s4">'PLAT' </span><span class="s2">not in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">:</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s4">'PLAT'</span><span class="s3">] = </span><span class="s1">get_platform</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">subst_vars</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">local_vars</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform variable substitution on 'string'. 
    Variables are indicated by format-style braces (&quot;{var}&quot;). 
    Variable is substituted by the value found in the 'local_vars' 
    dictionary or in 'os.environ' if it's not in 'local_vars'. 
    'os.environ' is first checked/augmented to guarantee that it contains 
    certain values: see 'check_environ()'.  Raise ValueError for any 
    variables not found in either 'local_vars' or 'os.environ'. 
    &quot;&quot;&quot;</span>
    <span class="s1">check_environ</span><span class="s3">()</span>
    <span class="s1">lookup </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">)</span>
    <span class="s1">lookup</span><span class="s3">.</span><span class="s1">update</span><span class="s3">((</span><span class="s1">name</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">local_vars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_subst_compat</span><span class="s3">(</span><span class="s1">s</span><span class="s3">).</span><span class="s1">format_map</span><span class="s3">(</span><span class="s1">lookup</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">var</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;invalid variable </span><span class="s2">{</span><span class="s1">var</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_subst_compat</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Replace shell/Perl-style variable substitution with 
    format-style. For compatibility. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_subst</span><span class="s3">(</span><span class="s1">match</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f'</span><span class="s2">{{{</span><span class="s1">match</span><span class="s3">.</span><span class="s1">group</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span><span class="s2">}}}</span><span class="s4">'</span>

    <span class="s1">repl </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s4">r'\$([a-zA-Z_][a-zA-Z_0-9]*)'</span><span class="s3">, </span><span class="s1">_subst</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">repl </span><span class="s3">!= </span><span class="s1">s</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">warnings</span>

        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;shell/Perl-style substitutions are deprecated&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">repl</span>


<span class="s2">def </span><span class="s1">grok_environment_error</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;error: &quot;</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5"># Function kept for backward compatibility.</span>
    <span class="s5"># Used to try clever things with EnvironmentErrors,</span>
    <span class="s5"># but nowadays str(exception) produces good messages.</span>
    <span class="s2">return </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">)</span>


<span class="s5"># Needed by 'split_quoted()'</span>
<span class="s1">_wordchars_re </span><span class="s3">= </span><span class="s1">_squote_re </span><span class="s3">= </span><span class="s1">_dquote_re </span><span class="s3">= </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_init_regex</span><span class="s3">():</span>
    <span class="s2">global </span><span class="s1">_wordchars_re</span><span class="s3">, </span><span class="s1">_squote_re</span><span class="s3">, </span><span class="s1">_dquote_re</span>
    <span class="s1">_wordchars_re </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">rf'[^\\\'\&quot;</span><span class="s2">{</span><span class="s1">string</span><span class="s3">.</span><span class="s1">whitespace</span><span class="s2">} </span><span class="s4">]*'</span><span class="s3">)</span>
    <span class="s1">_squote_re </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;'(?:[^'\\]|\\.)*'&quot;</span><span class="s3">)</span>
    <span class="s1">_dquote_re </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r'&quot;(?:[^&quot;\\]|\\.)*&quot;'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">split_quoted</span><span class="s3">(</span><span class="s1">s</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Split a string up according to Unix shell-like rules for quotes and 
    backslashes.  In short: words are delimited by spaces, as long as those 
    spaces are not escaped by a backslash, or inside a quoted string. 
    Single and double quotes are equivalent, and the quote characters can 
    be backslash-escaped.  The backslash is stripped from any two-character 
    escape sequence, leaving only the escaped character.  The quote 
    characters are stripped from any quoted string.  Returns a list of 
    words. 
    &quot;&quot;&quot;</span>

    <span class="s5"># This is a nice algorithm for splitting up a single string, since it</span>
    <span class="s5"># doesn't require character-by-character examination.  It was a little</span>
    <span class="s5"># bit of a brain-bender to get it working right, though...</span>
    <span class="s2">if </span><span class="s1">_wordchars_re </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">_init_regex</span><span class="s3">()</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()</span>
    <span class="s1">words </span><span class="s3">= []</span>
    <span class="s1">pos </span><span class="s3">= </span><span class="s6">0</span>

    <span class="s2">while </span><span class="s1">s</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">_wordchars_re</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">)</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">end</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">end </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
            <span class="s1">words</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[:</span><span class="s1">end</span><span class="s3">])</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">] </span><span class="s2">in </span><span class="s1">string</span><span class="s3">.</span><span class="s1">whitespace</span><span class="s3">:</span>
            <span class="s5"># unescaped, unquoted whitespace: now</span>
            <span class="s5"># we definitely have a word delimiter</span>
            <span class="s1">words</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[:</span><span class="s1">end</span><span class="s3">])</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">:].</span><span class="s1">lstrip</span><span class="s3">()</span>
            <span class="s1">pos </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s2">elif </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">] == </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s3">:</span>
            <span class="s5"># preserve whatever is being escaped;</span>
            <span class="s5"># will become part of the current word</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[:</span><span class="s1">end</span><span class="s3">] + </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">:]</span>
            <span class="s1">pos </span><span class="s3">= </span><span class="s1">end </span><span class="s3">+ </span><span class="s6">1</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">] == </span><span class="s4">&quot;'&quot;</span><span class="s3">:  </span><span class="s5"># slurp singly-quoted string</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">_squote_re</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">] == </span><span class="s4">'&quot;'</span><span class="s3">:  </span><span class="s5"># slurp doubly-quoted string</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">_dquote_re</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">f&quot;this can't happen (bad char '</span><span class="s2">{</span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">]</span><span class="s2">}</span><span class="s4">')&quot;</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;bad string (mismatched </span><span class="s2">{</span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">]</span><span class="s2">} </span><span class="s4">quotes?)&quot;</span><span class="s3">)</span>

            <span class="s3">(</span><span class="s1">beg</span><span class="s3">, </span><span class="s1">end</span><span class="s3">) = </span><span class="s1">m</span><span class="s3">.</span><span class="s1">span</span><span class="s3">()</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[:</span><span class="s1">beg</span><span class="s3">] + </span><span class="s1">s</span><span class="s3">[</span><span class="s1">beg </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">: </span><span class="s1">end </span><span class="s3">- </span><span class="s6">1</span><span class="s3">] + </span><span class="s1">s</span><span class="s3">[</span><span class="s1">end</span><span class="s3">:]</span>
            <span class="s1">pos </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">end</span><span class="s3">() - </span><span class="s6">2</span>

        <span class="s2">if </span><span class="s1">pos </span><span class="s3">&gt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
            <span class="s1">words</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">words</span>


<span class="s5"># split_quoted ()</span>


<span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
    <span class="s1">func</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Unpack</span><span class="s3">[</span><span class="s1">_Ts</span><span class="s3">]], </span><span class="s1">object</span><span class="s3">],</span>
    <span class="s1">args</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Unpack</span><span class="s3">[</span><span class="s1">_Ts</span><span class="s3">]],</span>
    <span class="s1">msg</span><span class="s3">: </span><span class="s1">object </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">verbose</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">dry_run</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform some action that affects the outside world (e.g. by 
    writing to the filesystem). Such actions are special because they 
    are disabled by the 'dry_run' flag. This method handles that 
    complication; simply supply the 
    function to call and an argument tuple for it (to embody the 
    &quot;external action&quot; being performed) and an optional message to 
    emit. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">msg </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}{</span><span class="s1">args</span><span class="s2">!r}</span><span class="s4">&quot;</span>
        <span class="s2">if </span><span class="s1">msg</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">:] == </span><span class="s4">',)'</span><span class="s3">:  </span><span class="s5"># correct for singleton tuple</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s1">msg</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">2</span><span class="s3">] + </span><span class="s4">')'</span>

    <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">dry_run</span><span class="s3">:</span>
        <span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">strtobool</span><span class="s3">(</span><span class="s1">val</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Convert a string representation of truth to true (1) or false (0). 
 
    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values 
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if 
    'val' is anything else. 
    &quot;&quot;&quot;</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">val </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'y'</span><span class="s3">, </span><span class="s4">'yes'</span><span class="s3">, </span><span class="s4">'t'</span><span class="s3">, </span><span class="s4">'true'</span><span class="s3">, </span><span class="s4">'on'</span><span class="s3">, </span><span class="s4">'1'</span><span class="s3">):</span>
        <span class="s2">return True</span>
    <span class="s2">elif </span><span class="s1">val </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'n'</span><span class="s3">, </span><span class="s4">'no'</span><span class="s3">, </span><span class="s4">'f'</span><span class="s3">, </span><span class="s4">'false'</span><span class="s3">, </span><span class="s4">'off'</span><span class="s3">, </span><span class="s4">'0'</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;invalid truth value </span><span class="s2">{</span><span class="s1">val</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">byte_compile</span><span class="s3">(  </span><span class="s5"># noqa: C901</span>
    <span class="s1">py_files</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">],</span>
    <span class="s1">optimize</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">force</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">prefix</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">base_dir</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">verbose</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">dry_run</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">direct</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Byte-compile a collection of Python source files to .pyc 
    files in a __pycache__ subdirectory.  'py_files' is a list 
    of files to compile; any files that don't end in &quot;.py&quot; are silently 
    skipped.  'optimize' must be one of the following: 
      0 - don't optimize 
      1 - normal optimization (like &quot;python -O&quot;) 
      2 - extra optimization (like &quot;python -OO&quot;) 
    If 'force' is true, all files are recompiled regardless of 
    timestamps. 
 
    The source filename encoded in each bytecode file defaults to the 
    filenames listed in 'py_files'; you can modify these with 'prefix' and 
    'basedir'.  'prefix' is a string that will be stripped off of each 
    source filename, and 'base_dir' is a directory name that will be 
    prepended (after 'prefix' is stripped).  You can supply either or both 
    (or neither) of 'prefix' and 'base_dir', as you wish. 
 
    If 'dry_run' is true, doesn't actually do anything that would 
    affect the filesystem. 
 
    Byte-compilation is either done directly in this interpreter process 
    with the standard py_compile module, or indirectly by writing a 
    temporary script and executing it.  Normally, you should let 
    'byte_compile()' figure out to use direct compilation or not (see 
    the source for details).  The 'direct' flag is used by the script 
    generated in indirect mode; unless you know what you're doing, leave 
    it set to None. 
    &quot;&quot;&quot;</span>

    <span class="s5"># nothing is done if sys.dont_write_bytecode is True</span>
    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">dont_write_bytecode</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">DistutilsByteCompileError</span><span class="s3">(</span><span class="s4">'byte-compiling is disabled.'</span><span class="s3">)</span>

    <span class="s5"># First, if the caller didn't force us into direct or indirect mode,</span>
    <span class="s5"># figure out which mode we should be in.  We take a conservative</span>
    <span class="s5"># approach: choose direct mode *only* if the current interpreter is</span>
    <span class="s5"># in debug mode and optimize is 0.  If we're not in debug mode (-O</span>
    <span class="s5"># or -OO), we don't know which level of optimization this</span>
    <span class="s5"># interpreter is running with, so we can't do direct</span>
    <span class="s5"># byte-compilation and be certain that it's the right thing.  Thus,</span>
    <span class="s5"># always compile indirectly if the current interpreter is in either</span>
    <span class="s5"># optimize mode, or if either optimization level was requested by</span>
    <span class="s5"># the caller.</span>
    <span class="s2">if </span><span class="s1">direct </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">direct </span><span class="s3">= </span><span class="s2">__debug__ and </span><span class="s1">optimize </span><span class="s3">== </span><span class="s6">0</span>

    <span class="s5"># &quot;Indirect&quot; byte-compilation: write a temporary script and then</span>
    <span class="s5"># run it with the appropriate flags.</span>
    <span class="s2">if not </span><span class="s1">direct</span><span class="s3">:</span>
        <span class="s3">(</span><span class="s1">script_fd</span><span class="s3">, </span><span class="s1">script_name</span><span class="s3">) = </span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">mkstemp</span><span class="s3">(</span><span class="s4">&quot;.py&quot;</span><span class="s3">)</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;writing byte-compilation script '%s'&quot;</span><span class="s3">, </span><span class="s1">script_name</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">dry_run</span><span class="s3">:</span>
            <span class="s1">script </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">fdopen</span><span class="s3">(</span><span class="s1">script_fd</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">'utf-8'</span><span class="s3">)</span>

            <span class="s2">with </span><span class="s1">script</span><span class="s3">:</span>
                <span class="s1">script</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span>
                    <span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">from distutils.util import byte_compile 
files = [ 
&quot;&quot;&quot;</span>
                <span class="s3">)</span>

                <span class="s5"># XXX would be nice to write absolute filenames, just for</span>
                <span class="s5"># safety's sake (script should be more robust in the face of</span>
                <span class="s5"># chdir'ing before running it).  But this requires abspath'ing</span>
                <span class="s5"># 'prefix' as well, and that breaks the hack in build_lib's</span>
                <span class="s5"># 'byte_compile()' method that carefully tacks on a trailing</span>
                <span class="s5"># slash (os.sep really) to make sure the prefix here is &quot;just</span>
                <span class="s5"># right&quot;.  This whole prefix business is rather delicate -- the</span>
                <span class="s5"># problem is that it's really a directory, but I'm treating it</span>
                <span class="s5"># as a dumb string, so trailing slashes and so forth matter.</span>

                <span class="s1">script</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;,</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">, </span><span class="s1">py_files</span><span class="s3">)) + </span><span class="s4">&quot;]</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s1">script</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span>
                    <span class="s4">f&quot;&quot;&quot;</span>
<span class="s4">byte_compile(files, optimize=</span><span class="s2">{</span><span class="s1">optimize</span><span class="s2">!r}</span><span class="s4">, force=</span><span class="s2">{</span><span class="s1">force</span><span class="s2">!r}</span><span class="s4">,</span>
             <span class="s4">prefix=</span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">!r}</span><span class="s4">, base_dir=</span><span class="s2">{</span><span class="s1">base_dir</span><span class="s2">!r}</span><span class="s4">,</span>
             <span class="s4">verbose=</span><span class="s2">{</span><span class="s1">verbose</span><span class="s2">!r}</span><span class="s4">, dry_run=False,</span>
             <span class="s4">direct=True)</span>
<span class="s4">&quot;&quot;&quot;</span>
                <span class="s3">)</span>

        <span class="s1">cmd </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">]</span>
        <span class="s1">cmd</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">_optim_args_from_interpreter_flags</span><span class="s3">())</span>
        <span class="s1">cmd</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">script_name</span><span class="s3">)</span>
        <span class="s1">spawn</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">dry_run</span><span class="s3">=</span><span class="s1">dry_run</span><span class="s3">)</span>
        <span class="s1">execute</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">, (</span><span class="s1">script_name</span><span class="s3">,), </span><span class="s4">f&quot;removing </span><span class="s2">{</span><span class="s1">script_name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">dry_run</span><span class="s3">=</span><span class="s1">dry_run</span><span class="s3">)</span>

    <span class="s5"># &quot;Direct&quot; byte-compilation: use the py_compile module to compile</span>
    <span class="s5"># right here, right now.  Note that the script generated in indirect</span>
    <span class="s5"># mode simply calls 'byte_compile()' in direct mode, a weird sort of</span>
    <span class="s5"># cross-process recursion.  Hey, it works!</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">py_compile </span><span class="s2">import </span><span class="s1">compile</span>

        <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">py_files</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">file</span><span class="s3">[-</span><span class="s6">3</span><span class="s3">:] != </span><span class="s4">&quot;.py&quot;</span><span class="s3">:</span>
                <span class="s5"># This lets us be lazy and not filter filenames in</span>
                <span class="s5"># the &quot;install_lib&quot; command.</span>
                <span class="s2">continue</span>

            <span class="s5"># Terminology from the py_compile module:</span>
            <span class="s5">#   cfile - byte-compiled file</span>
            <span class="s5">#   dfile - purported source filename (same as 'file' by default)</span>
            <span class="s2">if </span><span class="s1">optimize </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">opt </span><span class="s3">= </span><span class="s4">'' </span><span class="s2">if </span><span class="s1">optimize </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">optimize</span>
                <span class="s1">cfile </span><span class="s3">= </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">cache_from_source</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">optimization</span><span class="s3">=</span><span class="s1">opt</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">cfile </span><span class="s3">= </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">cache_from_source</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)</span>
            <span class="s1">dfile </span><span class="s3">= </span><span class="s1">file</span>
            <span class="s2">if </span><span class="s1">prefix</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">file</span><span class="s3">[: </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">)] != </span><span class="s1">prefix</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                        <span class="s4">f&quot;invalid prefix: filename </span><span class="s2">{</span><span class="s1">file</span><span class="s2">!r} </span><span class="s4">doesn't start with </span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">!r}</span><span class="s4">&quot;</span>
                    <span class="s3">)</span>
                <span class="s1">dfile </span><span class="s3">= </span><span class="s1">dfile</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">) :]</span>
            <span class="s2">if </span><span class="s1">base_dir</span><span class="s3">:</span>
                <span class="s1">dfile </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">base_dir</span><span class="s3">, </span><span class="s1">dfile</span><span class="s3">)</span>

            <span class="s1">cfile_base </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">cfile</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">direct</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">force </span><span class="s2">or </span><span class="s1">newer</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">cfile</span><span class="s3">):</span>
                    <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;byte-compiling %s to %s&quot;</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">cfile_base</span><span class="s3">)</span>
                    <span class="s2">if not </span><span class="s1">dry_run</span><span class="s3">:</span>
                        <span class="s1">compile</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">cfile</span><span class="s3">, </span><span class="s1">dfile</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;skipping byte-compilation of %s to %s&quot;</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">cfile_base</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rfc822_escape</span><span class="s3">(</span><span class="s1">header</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Return a version of the string escaped for inclusion in an 
    RFC-822 header, by ensuring there are 8 spaces space after each newline. 
    &quot;&quot;&quot;</span>
    <span class="s1">indent </span><span class="s3">= </span><span class="s6">8 </span><span class="s3">* </span><span class="s4">&quot; &quot;</span>
    <span class="s1">lines </span><span class="s3">= </span><span class="s1">header</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">(</span><span class="s1">keepends</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s5"># Emulate the behaviour of `str.split`</span>
    <span class="s5"># (the terminal line break in `splitlines` does not result in an extra line):</span>
    <span class="s1">ends_in_newline </span><span class="s3">= </span><span class="s1">lines </span><span class="s2">and </span><span class="s1">lines</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">splitlines</span><span class="s3">()[</span><span class="s6">0</span><span class="s3">] != </span><span class="s1">lines</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">suffix </span><span class="s3">= </span><span class="s1">indent </span><span class="s2">if </span><span class="s1">ends_in_newline </span><span class="s2">else </span><span class="s4">&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">indent</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">) + </span><span class="s1">suffix</span>


<span class="s2">def </span><span class="s1">is_mingw</span><span class="s3">() </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Returns True if the current platform is mingw. 
 
    Python compiled with Mingw-w64 has sys.platform == 'win32' and 
    get_platform() starts with 'mingw'. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">'win32' </span><span class="s2">and </span><span class="s1">get_platform</span><span class="s3">().</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'mingw'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_freethreaded</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Return True if the Python interpreter is built with free threading support.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">sysconfig</span><span class="s3">.</span><span class="s1">get_config_var</span><span class="s3">(</span><span class="s4">'Py_GIL_DISABLED'</span><span class="s3">))</span>
</pre>
</body>
</html>