<html>
<head>
<title>embedded.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
embedded.py</font>
</center></td></tr></table>
<pre><span class="s0">#  Copyright 2008-2015 Nokia Networks</span>
<span class="s0">#  Copyright 2016-     Robot Framework Foundation</span>
<span class="s0">#</span>
<span class="s0">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0">#  you may not use this file except in compliance with the License.</span>
<span class="s0">#  You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="s0">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0">#  See the License for the specific language governing permissions and</span>
<span class="s0">#  limitations under the License.</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">Sequence</span>

<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">DataError</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s1">get_error_message</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">variables </span><span class="s2">import </span><span class="s1">VariableMatches</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">context </span><span class="s2">import </span><span class="s1">EXECUTION_CONTEXTS</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">typeinfo </span><span class="s2">import </span><span class="s1">TypeInfo</span>

<span class="s1">VARIABLE_PLACEHOLDER </span><span class="s3">= </span><span class="s4">&quot;robot-834d5d70-239e-43f6-97fb-902acf41625b&quot;</span>


<span class="s2">class </span><span class="s1">EmbeddedArguments</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">re</span><span class="s3">.</span><span class="s1">Pattern</span><span class="s3">,</span>
        <span class="s1">args</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = (),</span>
        <span class="s1">custom_patterns</span><span class="s3">: </span><span class="s4">&quot;Mapping[str, str]|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">types</span><span class="s3">: </span><span class="s4">&quot;Sequence[TypeInfo|None]&quot; </span><span class="s3">= (),</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">custom_patterns </span><span class="s3">= </span><span class="s1">custom_patterns </span><span class="s2">or None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">types </span><span class="s3">= </span><span class="s1">types</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_name</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;EmbeddedArguments|None&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">EmbeddedArgumentParser</span><span class="s3">().</span><span class="s1">parse</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) </span><span class="s2">if </span><span class="s4">&quot;${&quot; </span><span class="s2">in </span><span class="s1">name </span><span class="s2">else None</span>

    <span class="s2">def </span><span class="s1">match</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;re.Match|None&quot;</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Deprecated since Robot Framework 7.3.&quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;'EmbeddedArguments.match()' is deprecated since Robot Framework 7.3. Use &quot;</span>
            <span class="s4">&quot;new 'EmbeddedArguments.matches()' or 'EmbeddedArguments.parse_args()' &quot;</span>
            <span class="s4">&quot;instead. Alternatively, use 'EmbeddedArguments.name.fullmatch()' to &quot;</span>
            <span class="s4">&quot;preserve the old behavior and to be compatible with earlier Robot &quot;</span>
            <span class="s4">&quot;Framework versions.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">fullmatch</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">matches</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return ``True`` if ``name`` matches these embedded arguments.&quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_args</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">parse_args</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;tuple[str, ...]&quot;</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Parse arguments matching these embedded arguments from ``name``.&quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s3">, </span><span class="s1">placeholders </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_args</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">placeholders</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">args</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replace_placeholders</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">placeholders</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">_parse_args</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;tuple[tuple[str, ...], dict[str, str]]&quot;</span><span class="s3">:</span>
        <span class="s1">parts </span><span class="s3">= []</span>
        <span class="s1">placeholders </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">VariableMatches</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">ph </span><span class="s3">= </span><span class="s4">f&quot;=</span><span class="s2">{</span><span class="s1">VARIABLE_PLACEHOLDER</span><span class="s2">}</span><span class="s4">-</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">placeholders</span><span class="s3">) + </span><span class="s6">1</span><span class="s2">}</span><span class="s4">=&quot;</span>
            <span class="s1">placeholders</span><span class="s3">[</span><span class="s1">ph</span><span class="s3">] = </span><span class="s1">match</span><span class="s3">.</span><span class="s1">match</span>
            <span class="s1">parts</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">:] = [</span><span class="s1">match</span><span class="s3">.</span><span class="s1">before</span><span class="s3">, </span><span class="s1">ph</span><span class="s3">, </span><span class="s1">match</span><span class="s3">.</span><span class="s1">after</span><span class="s3">]</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">) </span><span class="s2">if </span><span class="s1">parts </span><span class="s2">else </span><span class="s1">name</span>
        <span class="s1">match </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">fullmatch</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">match</span><span class="s3">.</span><span class="s1">groups</span><span class="s3">() </span><span class="s2">if </span><span class="s1">match </span><span class="s2">else </span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">args</span><span class="s3">, </span><span class="s1">placeholders</span>

    <span class="s2">def </span><span class="s1">_replace_placeholders</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">placeholders</span><span class="s3">: </span><span class="s4">&quot;dict[str, str]&quot;</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">ph </span><span class="s2">in </span><span class="s1">placeholders</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">ph </span><span class="s2">in </span><span class="s1">arg</span><span class="s3">:</span>
                <span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">ph</span><span class="s3">, </span><span class="s1">placeholders</span><span class="s3">[</span><span class="s1">ph</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">arg</span>

    <span class="s2">def </span><span class="s1">map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">args</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s4">&quot;list[tuple[str, object]]&quot;</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= [</span>
            <span class="s1">info</span><span class="s3">.</span><span class="s1">convert</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">name</span><span class="s3">) </span><span class="s2">if </span><span class="s1">info </span><span class="s2">else </span><span class="s1">value</span>
            <span class="s2">for </span><span class="s1">info</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">types</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">validate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">args</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]):</span>
        <span class="s5">&quot;&quot;&quot;Validate that embedded args match custom regexps. 
 
        Initial validation is done already when matching keywords, but this 
        validation makes sure arguments match also if they are given as variables. 
 
        Currently, argument not matching only causes a deprecation warning, but 
        that will be changed to ``ValueError`` in RF 8.0: 
        https://github.com/robotframework/robotframework/issues/4069 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">custom_patterns</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">custom_patterns </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s1">pattern </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">custom_patterns</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
                <span class="s2">if not </span><span class="s1">re</span><span class="s3">.</span><span class="s1">fullmatch</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
                    <span class="s0"># TODO: Change to `raise ValueError(...)` in RF 8.0.</span>
                    <span class="s1">context </span><span class="s3">= </span><span class="s1">EXECUTION_CONTEXTS</span><span class="s3">.</span><span class="s1">current</span>
                    <span class="s1">context</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s4">f&quot;Embedded argument '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' got value </span><span class="s2">{</span><span class="s1">value</span><span class="s2">!r} </span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;that does not match custom pattern </span><span class="s2">{</span><span class="s1">pattern</span><span class="s2">!r}</span><span class="s4">. &quot;</span>
                        <span class="s4">f&quot;The argument is still accepted, but this behavior &quot;</span>
                        <span class="s4">f&quot;will change in Robot Framework 8.0.&quot;</span>
                    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">EmbeddedArgumentParser</span><span class="s3">:</span>
    <span class="s1">_inline_flag </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;\(\?[aiLmsux]+(-[imsx]+)?\)&quot;</span><span class="s3">)</span>
    <span class="s1">_regexp_group_start </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;(?&lt;!\\)\((.*?)\)&quot;</span><span class="s3">)</span>
    <span class="s1">_escaped_curly </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;(\\+)([{}])&quot;</span><span class="s3">)</span>
    <span class="s1">_regexp_group_escape </span><span class="s3">= </span><span class="s4">r&quot;(?:\1)&quot;</span>
    <span class="s1">_default_pattern </span><span class="s3">= </span><span class="s4">&quot;.*?&quot;</span>

    <span class="s2">def </span><span class="s1">parse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">string</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;EmbeddedArguments|None&quot;</span><span class="s3">:</span>
        <span class="s1">name_parts </span><span class="s3">= []</span>
        <span class="s1">args </span><span class="s3">= []</span>
        <span class="s1">custom_patterns </span><span class="s3">= {}</span>
        <span class="s1">after </span><span class="s3">= </span><span class="s1">string </span><span class="s3">= </span><span class="s4">&quot; &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">string</span><span class="s3">.</span><span class="s1">split</span><span class="s3">())</span>
        <span class="s1">types </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">VariableMatches</span><span class="s3">(</span><span class="s1">string</span><span class="s3">, </span><span class="s1">identifiers</span><span class="s3">=</span><span class="s4">&quot;$&quot;</span><span class="s3">):</span>
            <span class="s1">arg</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">pattern </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_arg</span><span class="s3">(</span><span class="s1">match</span><span class="s3">.</span><span class="s1">base</span><span class="s3">)</span>
            <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">None if </span><span class="s1">typ </span><span class="s2">is None else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_type_info</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">pattern </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">pattern </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_default_pattern</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">custom_patterns</span><span class="s3">[</span><span class="s1">arg</span><span class="s3">] = </span><span class="s1">pattern</span>
                <span class="s1">pattern </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_format_custom_regexp</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)</span>
            <span class="s1">name_parts</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span><span class="s1">match</span><span class="s3">.</span><span class="s1">before</span><span class="s3">), </span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">])</span>
            <span class="s1">after </span><span class="s3">= </span><span class="s1">match</span><span class="s3">.</span><span class="s1">after</span>
        <span class="s2">if not </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s1">name_parts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span><span class="s1">after</span><span class="s3">))</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_regexp</span><span class="s3">(</span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">name_parts</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">EmbeddedArguments</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">custom_patterns</span><span class="s3">, </span><span class="s1">types</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_parse_arg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;tuple[str, str|None, str|None]&quot;</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s4">&quot;:&quot; </span><span class="s2">not in </span><span class="s1">arg</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">arg</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s1">match </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">fullmatch</span><span class="s3">(</span><span class="s4">&quot;([^:]+): ([^:]+)(:(.*))?&quot;</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">match</span><span class="s3">:</span>
            <span class="s1">arg</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">pattern </span><span class="s3">= </span><span class="s1">match</span><span class="s3">.</span><span class="s1">groups</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">pattern</span>
        <span class="s1">arg</span><span class="s3">, </span><span class="s1">pattern </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">&quot;:&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">arg</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">pattern</span>

    <span class="s2">def </span><span class="s1">_format_custom_regexp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">formatter </span><span class="s2">in </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_remove_inline_flags</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_make_groups_non_capturing</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_unescape_curly_braces</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_escape_escapes</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_variable_placeholder_pattern</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s1">pattern </span><span class="s3">= </span><span class="s1">formatter</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">pattern</span>

    <span class="s2">def </span><span class="s1">_remove_inline_flags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0"># Inline flags are included in custom regexp stored separately, but they</span>
        <span class="s0"># must be removed from the full pattern.</span>
        <span class="s1">match </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_inline_flag</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">pattern </span><span class="s2">if </span><span class="s1">match </span><span class="s2">is None else </span><span class="s1">pattern</span><span class="s3">[</span><span class="s1">match</span><span class="s3">.</span><span class="s1">end</span><span class="s3">() :]</span>

    <span class="s2">def </span><span class="s1">_make_groups_non_capturing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_regexp_group_start</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_regexp_group_escape</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_unescape_curly_braces</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0"># Users must escape possible lone curly braces in patters (e.g. `${x:\{}`)</span>
        <span class="s0"># or otherwise the variable syntax is invalid.</span>
        <span class="s2">def </span><span class="s1">unescape</span><span class="s3">(</span><span class="s1">match</span><span class="s3">):</span>
            <span class="s1">backslashes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">match</span><span class="s3">.</span><span class="s1">group</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot; </span><span class="s3">* (</span><span class="s1">backslashes </span><span class="s3">// </span><span class="s6">2 </span><span class="s3">* </span><span class="s6">2</span><span class="s3">) + </span><span class="s1">match</span><span class="s3">.</span><span class="s1">group</span><span class="s3">(</span><span class="s6">2</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_escaped_curly</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">unescape</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_escape_escapes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0"># When keywords are matched, embedded arguments have not yet been</span>
        <span class="s0"># resolved which means possible escapes are still doubled. We thus</span>
        <span class="s0"># need to double them in the pattern as well.</span>
        <span class="s2">return </span><span class="s1">pattern</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">r&quot;\\&quot;</span><span class="s3">, </span><span class="s4">r&quot;\\\\&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_add_variable_placeholder_pattern</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">rf&quot;</span><span class="s2">{</span><span class="s1">pattern</span><span class="s2">}</span><span class="s4">|=</span><span class="s2">{</span><span class="s1">VARIABLE_PLACEHOLDER</span><span class="s2">}</span><span class="s4">-\d+=&quot;</span>

    <span class="s2">def </span><span class="s1">_get_type_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;TypeInfo|None&quot;</span><span class="s3">:</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s4">f&quot;$</span><span class="s2">{{{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}}}</span><span class="s4">&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">TypeInfo</span><span class="s3">.</span><span class="s1">from_variable</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">DataError </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span><span class="s4">f&quot;Invalid embedded argument '</span><span class="s2">{</span><span class="s1">var</span><span class="s2">}</span><span class="s4">': </span><span class="s2">{</span><span class="s1">err</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_compile_regexp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; re</span><span class="s3">.</span><span class="s1">Pattern</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">r&quot;\ &quot;</span><span class="s3">, </span><span class="s4">r&quot;\s&quot;</span><span class="s3">), </span><span class="s1">re</span><span class="s3">.</span><span class="s1">IGNORECASE</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span>
                <span class="s4">f&quot;Compiling embedded arguments regexp failed: </span><span class="s2">{</span><span class="s1">get_error_message</span><span class="s3">()</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
</pre>
</body>
</html>