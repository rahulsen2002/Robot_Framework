<html>
<head>
<title>_config.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_config.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum</span><span class="s2">, </span><span class="s1">auto</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">TypeVar</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s2">.</span><span class="s1">_functions </span><span class="s0">import </span><span class="s1">TypeCheckFailCallback</span>

<span class="s1">T </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;T&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">ForwardRefPolicy</span><span class="s2">(</span><span class="s1">Enum</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Defines how unresolved forward references are handled. 
 
    Members: 
 
    * ``ERROR``: propagate the :exc:`NameError` when the forward reference lookup fails 
    * ``WARN``: emit a :class:`~.TypeHintWarning` if the forward reference lookup fails 
    * ``IGNORE``: silently skip checks for unresolveable forward references 
    &quot;&quot;&quot;</span>

    <span class="s1">ERROR </span><span class="s2">= </span><span class="s1">auto</span><span class="s2">()</span>
    <span class="s1">WARN </span><span class="s2">= </span><span class="s1">auto</span><span class="s2">()</span>
    <span class="s1">IGNORE </span><span class="s2">= </span><span class="s1">auto</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">CollectionCheckStrategy</span><span class="s2">(</span><span class="s1">Enum</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Specifies how thoroughly the contents of collections are type checked. 
 
    This has an effect on the following built-in checkers: 
 
    * ``AbstractSet`` 
    * ``Dict`` 
    * ``List`` 
    * ``Mapping`` 
    * ``Set`` 
    * ``Tuple[&lt;type&gt;, ...]`` (arbitrarily sized tuples) 
 
    Members: 
 
    * ``FIRST_ITEM``: check only the first item 
    * ``ALL_ITEMS``: check all items 
    &quot;&quot;&quot;</span>

    <span class="s1">FIRST_ITEM </span><span class="s2">= </span><span class="s1">auto</span><span class="s2">()</span>
    <span class="s1">ALL_ITEMS </span><span class="s2">= </span><span class="s1">auto</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">iterate_samples</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">collection</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">T</span><span class="s2">]) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">T</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">CollectionCheckStrategy</span><span class="s2">.</span><span class="s1">FIRST_ITEM</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">collection</span><span class="s2">))]</span>
            <span class="s0">except </span><span class="s1">StopIteration</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">collection</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">TypeCheckConfiguration</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
     You can change Typeguard's behavior with these settings. 
 
    .. attribute:: typecheck_fail_callback 
       :type: Callable[[TypeCheckError, TypeCheckMemo], Any] 
 
         Callable that is called when type checking fails. 
 
         Default: ``None`` (the :exc:`~.TypeCheckError` is raised directly) 
 
    .. attribute:: forward_ref_policy 
       :type: ForwardRefPolicy 
 
         Specifies what to do when a forward reference fails to resolve. 
 
         Default: ``WARN`` 
 
    .. attribute:: collection_check_strategy 
       :type: CollectionCheckStrategy 
 
         Specifies how thoroughly the contents of collections (list, dict, etc.) are 
         type checked. 
 
         Default: ``FIRST_ITEM`` 
 
    .. attribute:: debug_instrumentation 
       :type: bool 
 
         If set to ``True``, the code of modules or functions instrumented by typeguard 
         is printed to ``sys.stderr`` after the instrumentation is done 
 
         Requires Python 3.9 or newer. 
 
         Default: ``False`` 
    &quot;&quot;&quot;</span>

    <span class="s1">forward_ref_policy</span><span class="s2">: </span><span class="s1">ForwardRefPolicy </span><span class="s2">= </span><span class="s1">ForwardRefPolicy</span><span class="s2">.</span><span class="s1">WARN</span>
    <span class="s1">typecheck_fail_callback</span><span class="s2">: </span><span class="s1">TypeCheckFailCallback </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">collection_check_strategy</span><span class="s2">: </span><span class="s1">CollectionCheckStrategy </span><span class="s2">= (</span>
        <span class="s1">CollectionCheckStrategy</span><span class="s2">.</span><span class="s1">FIRST_ITEM</span>
    <span class="s2">)</span>
    <span class="s1">debug_instrumentation</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>


<span class="s1">global_config </span><span class="s2">= </span><span class="s1">TypeCheckConfiguration</span><span class="s2">()</span>
</pre>
</body>
</html>