<html>
<head>
<title>Process.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Process.py</font>
</center></td></tr></table>
<pre><span class="s0">#  Copyright 2008-2015 Nokia Networks</span>
<span class="s0">#  Copyright 2016-     Robot Framework Foundation</span>
<span class="s0">#</span>
<span class="s0">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0">#  you may not use this file except in compliance with the License.</span>
<span class="s0">#  You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="s0">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0">#  See the License for the specific language governing permissions and</span>
<span class="s0">#  limitations under the License.</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">signal </span><span class="s2">as </span><span class="s1">signal_module</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">TemporaryFile</span>

<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">api </span><span class="s2">import </span><span class="s1">logger</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">TimeoutExceeded</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">cmdline2list</span><span class="s3">, </span><span class="s1">ConnectionCache</span><span class="s3">, </span><span class="s1">console_decode</span><span class="s3">, </span><span class="s1">console_encode</span><span class="s3">, </span><span class="s1">is_list_like</span><span class="s3">,</span>
    <span class="s1">NormalizedDict</span><span class="s3">, </span><span class="s1">secs_to_timestr</span><span class="s3">, </span><span class="s1">system_decode</span><span class="s3">, </span><span class="s1">system_encode</span><span class="s3">, </span><span class="s1">timestr_to_secs</span><span class="s3">,</span>
    <span class="s1">WINDOWS</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">version </span><span class="s2">import </span><span class="s1">get_version</span>

<span class="s1">LOCALE_ENCODING </span><span class="s3">= </span><span class="s4">&quot;locale&quot; </span><span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">10</span><span class="s3">) </span><span class="s2">else None</span>


<span class="s2">class </span><span class="s1">Process</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Robot Framework library for running processes. 
 
    This library utilizes Python's 
    [http://docs.python.org/library/subprocess.html|subprocess] 
    module and its 
    [http://docs.python.org/library/subprocess.html#popen-constructor|Popen] 
    class. 
 
    The library has following main usages: 
 
    - Running processes in system and waiting for their completion using 
      `Run Process` keyword. 
    - Starting processes on background using `Start Process`. 
    - Waiting started process to complete using `Wait For Process` or 
      stopping them with `Terminate Process` or `Terminate All Processes`. 
 
    == Table of contents == 
 
    %TOC% 
 
    = Specifying command and arguments = 
 
    Both `Run Process` and `Start Process` accept the command to execute and 
    all arguments passed to the command as separate arguments. This makes usage 
    convenient and also allows these keywords to automatically escape possible 
    spaces and other special characters in commands and arguments. Notice that 
    if a command accepts options that themselves accept values, these options 
    and their values must be given as separate arguments. 
 
    When `running processes in shell`, it is also possible to give the whole 
    command to execute as a single string. The command can then contain 
    multiple commands to be run together. When using this approach, the caller 
    is responsible on escaping. 
 
    Examples: 
    | `Run Process` | ${tools}${/}prog.py | argument | second arg with spaces | 
    | `Run Process` | java | -jar | ${jars}${/}example.jar | --option | value | 
    | `Run Process` | prog.py &quot;one arg&quot; &amp;&amp; tool.sh | shell=yes | cwd=${tools} | 
 
    Possible non-string arguments are converted to strings automatically. 
 
    = Process configuration = 
 
    `Run Process` and `Start Process` keywords can be configured using 
    optional configuration arguments. These arguments must be given 
    after other arguments passed to these keywords and must use the 
    ``name=value`` syntax. Available configuration arguments are 
    listed below and discussed further in the subsequent sections. 
 
    |  = Name =   |                  = Explanation =                      | 
    | shell       | Specify whether to run the command in a shell or not. | 
    | cwd         | Specify the working directory.                        | 
    | env         | Specify environment variables given to the process.   | 
    | **env_extra | Override named environment variables using ``env:&lt;name&gt;=&lt;value&gt;`` syntax. | 
    | stdout      | Path to a file where to write standard output.        | 
    | stderr      | Path to a file where to write standard error.         | 
    | stdin       | Configure process standard input. New in RF 4.1.2.    | 
    | output_encoding | Encoding to use when reading command outputs.     | 
    | alias       | A custom name given to the process.                   | 
 
    Note that possible equal signs in other arguments passed to `Run Process` 
    and `Start Process` must be escaped with a backslash like ``name\\=value``. 
    See `Run Process` for an example. 
 
    == Running processes in shell == 
 
    The ``shell`` argument specifies whether to run the process in a shell or 
    not. By default, shell is not used, which means that shell specific commands, 
    like ``copy`` and ``dir`` on Windows, are not available. You can, however, 
    run shell scripts and batch files without using a shell. 
 
    Giving the ``shell`` argument any non-false value, such as ``shell=True``, 
    changes the program to be executed in a shell. It allows using the shell 
    capabilities, but can also make the process invocation operating system 
    dependent. Having a shell between the actually started process and this 
    library can also interfere communication with the process such as stopping 
    it and reading its outputs. Because of these problems, it is recommended 
    to use the shell only when absolutely necessary. 
 
    When using a shell it is possible to give the whole command to execute 
    as a single string. See `Specifying command and arguments` section for 
    examples and more details in general. 
 
    == Current working directory == 
 
    By default, the child process will be executed in the same directory 
    as the parent process, the process running Robot Framework, is executed. This 
    can be changed by giving an alternative location using the ``cwd`` argument. 
    Forward slashes in the given path are automatically converted to 
    backslashes on Windows. 
 
    `Standard output and error streams`, when redirected to files, 
    are also relative to the current working directory possibly set using 
    the ``cwd`` argument. 
 
    Example: 
    | `Run Process` | prog.exe | cwd=${ROOT}/directory | stdout=stdout.txt | 
 
    == Environment variables == 
 
    The child process will get a copy of the parent process's environment 
    variables by default. The ``env`` argument can be used to give the 
    child a custom environment as a Python dictionary. If there is a need 
    to specify only certain environment variable, it is possible to use the 
    ``env:&lt;name&gt;=&lt;value&gt;`` format to set or override only that named variables. 
    It is also possible to use these two approaches together. 
 
    Examples: 
    | `Run Process` | program | env=${environ} | 
    | `Run Process` | program | env:http_proxy=10.144.1.10:8080 | env:PATH=%{PATH}${:}${PROGDIR} | 
    | `Run Process` | program | env=${environ} | env:EXTRA=value | 
 
    == Standard output and error streams == 
 
    By default, processes are run so that their standard output and standard 
    error streams are kept in the memory. This typically works fine, but there 
    can be problems if the amount of output is large or unlimited. Prior to 
    Robot Framework 7.3 the limit was smaller than nowadays and reaching it 
    caused a deadlock. 
 
    To avoid the above-mentioned problems, it is possible to use ``stdout`` 
    and ``stderr`` arguments to specify files on the file system where to 
    redirect the output. This can also be useful if other processes or 
    other keywords need to read or manipulate the output somehow. 
 
    Given ``stdout`` and ``stderr`` paths are relative to the `current working 
    directory`. Forward slashes in the given paths are automatically converted 
    to backslashes on Windows. 
 
    Regardless are outputs redirected to files or not, they are accessible 
    through the `result object` returned when the process ends. Commands are 
    expected to write outputs using the console encoding, but `output encoding` 
    can be configured using the ``output_encoding`` argument if needed. 
 
    As a special feature, it is possible to redirect the standard error to 
    the standard output by using ``stderr=STDOUT``. 
 
    If you are not interested in output at all, you can explicitly ignore it by 
    using a special value ``DEVNULL`` both with ``stdout`` and ``stderr``. For 
    example, ``stdout=DEVNULL`` is the same as redirecting output on console 
    with ``&gt; /dev/null`` on UNIX-like operating systems or ``&gt; NUL`` on Windows. 
    This way even a huge amount of output cannot cause problems, but naturally 
    the output is not available after execution either. 
 
    Examples: 
    | ${result} = | `Run Process` | program | stdout=${TEMPDIR}/stdout.txt | stderr=${TEMPDIR}/stderr.txt | 
    | `Log Many`  | stdout: ${result.stdout} | stderr: ${result.stderr} | 
    | ${result} = | `Run Process` | program | stderr=STDOUT | 
    | `Log`       | all output: ${result.stdout} | 
    | ${result} = | `Run Process` | program | stdout=DEVNULL | stderr=DEVNULL | 
 
    Note that the created output files are not automatically removed after 
    execution. The user is responsible to remove them if needed. 
 
    == Standard input stream == 
 
    The ``stdin`` argument makes it possible to pass information to the standard 
    input stream of the started process. How its value is interpreted is 
    explained in the table below. 
 
    | = Value =        | = Explanation = | 
    | String ``NONE``  | Inherit stdin from the parent process. This is the default. | 
    | String ``PIPE``  | Make stdin a pipe that can be written to. | 
    | Path to a file   | Open the specified file and use it as the stdin. | 
    | Any other string | Create a temporary file with the text as its content and use it as the stdin. | 
    | Any non-string value | Used as-is. Could be a file descriptor, stdout of another process, etc. | 
 
    Values ``PIPE`` and ``NONE`` are case-insensitive and internally mapped to 
    ``subprocess.PIPE`` and ``None``, respectively, when calling 
    [https://docs.python.org/3/library/subprocess.html#subprocess.Popen|subprocess.Popen]. 
 
    Examples: 
    | `Run Process` | command | stdin=PIPE | 
    | `Run Process` | command | stdin=${CURDIR}/stdin.txt | 
    | `Run Process` | command | stdin=Stdin as text. | 
 
    The support to configure ``stdin`` is new in Robot Framework 4.1.2. Its default 
    value used to be ``PIPE`` until Robot Framework 7.0. 
 
    == Output encoding == 
 
    Executed commands are, by default, expected to write outputs to the 
    `standard output and error streams` using the encoding used by the 
    system console. If the command uses some other encoding, that can be 
    configured using the ``output_encoding`` argument. This is especially 
    useful on Windows where the console uses a different encoding than rest 
    of the system, and many commands use the general system encoding instead 
    of the console encoding. 
 
    The value used with the ``output_encoding`` argument must be a valid 
    encoding and must match the encoding actually used by the command. As a 
    convenience, it is possible to use strings ``CONSOLE`` and ``SYSTEM`` 
    to specify that the console or system encoding is used, respectively. 
    If produced outputs use different encoding then configured, values got 
    through the `result object` will be invalid. 
 
    Examples: 
    | `Start Process` | program | output_encoding=UTF-8 | 
    | `Run Process`   | program | stdout=${path} | output_encoding=SYSTEM | 
 
    == Alias == 
 
    A custom name given to the process that can be used when selecting the 
    `active process`. 
 
    Examples: 
    | `Start Process` | program | alias=example | 
    | `Run Process`   | python  | -c | print('hello') | alias=hello | 
 
    = Active process = 
 
    The library keeps record which of the started processes is currently active. 
    By default, it is the latest process started with `Start Process`, 
    but `Switch Process` can be used to activate a different process. Using 
    `Run Process` does not affect the active process. 
 
    The keywords that operate on started processes will use the active process 
    by default, but it is possible to explicitly select a different process 
    using the ``handle`` argument. The handle can be an ``alias`` explicitly 
    given to `Start Process` or the process object returned by it. 
 
    = Result object = 
 
    `Run Process`, `Wait For Process` and `Terminate Process` keywords return a 
    result object that contains information about the process execution as its 
    attributes. The same result object, or some of its attributes, can also 
    be get using `Get Process Result` keyword. Attributes available in the 
    object are documented in the table below. 
 
    | = Attribute = |             = Explanation =               | 
    | rc            | Return code of the process as an integer. | 
    | stdout        | Contents of the standard output stream.   | 
    | stderr        | Contents of the standard error stream.    | 
    | stdout_path   | Path where stdout was redirected or ``None`` if not redirected. | 
    | stderr_path   | Path where stderr was redirected or ``None`` if not redirected. | 
 
    Example: 
    | ${result} =            | `Run Process`         | program               | 
    | `Should Be Equal As Integers` | ${result.rc}   | 0                     | 
    | `Should Match`         | ${result.stdout}      | Some t?xt*            | 
    | `Should Be Empty`      | ${result.stderr}      |                       | 
    | ${stdout} =            | `Get File`            | ${result.stdout_path} | 
    | `Should Be Equal`      | ${stdout}             | ${result.stdout}      | 
    | `File Should Be Empty` | ${result.stderr_path} |                       | 
 
    Notice that in ``stdout`` and ``stderr`` content possible trailing newline 
    is removed and ``\\r\\n`` converted to ``\\n`` automatically. If you 
    need to see the original process output, redirect it to a file using 
    `process configuration` and read it from there. 
 
    = Boolean arguments = 
 
    Some keywords accept arguments that are handled as Boolean values true or 
    false. If such an argument is given as a string, it is considered false if 
    it is an empty string or equal to ``FALSE``, ``NONE``, ``NO``, ``OFF`` or 
    ``0``, case-insensitively. Other strings are considered true regardless 
    their value, and other argument types are tested using the same 
    [http://docs.python.org/library/stdtypes.html#truth|rules as in Python]. 
 
    True examples: 
    | `Terminate Process` | kill=True     | # Strings are generally true.    | 
    | `Terminate Process` | kill=yes      | # Same as the above.             | 
    | `Terminate Process` | kill=${TRUE}  | # Python ``True`` is true.       | 
    | `Terminate Process` | kill=${42}    | # Numbers other than 0 are true. | 
 
    False examples: 
    | `Terminate Process` | kill=False    | # String ``false`` is false.   | 
    | `Terminate Process` | kill=no       | # Also string ``no`` is false. | 
    | `Terminate Process` | kill=${EMPTY} | # Empty string is false.       | 
    | `Terminate Process` | kill=${FALSE} | # Python ``False`` is false.   | 
 
    = Example = 
 
    | ***** Settings ***** 
    | Library           Process 
    | Suite Teardown    `Terminate All Processes`    kill=True 
    | 
    | ***** Test Cases ***** 
    | Example 
    |     `Start Process`    program    arg1    arg2    alias=First 
    |     ${handle} =    `Start Process`    command.sh arg | command2.sh    shell=True    cwd=/path 
    |     ${result} =    `Run Process`    ${CURDIR}/script.py 
    |     `Should Not Contain`    ${result.stdout}    FAIL 
    |     `Terminate Process`    ${handle} 
    |     ${result} =    `Wait For Process`    First 
    |     `Should Be Equal As Integers`    ${result.rc}    0 
    &quot;&quot;&quot;</span>

    <span class="s1">ROBOT_LIBRARY_SCOPE </span><span class="s3">= </span><span class="s4">&quot;GLOBAL&quot;</span>
    <span class="s1">ROBOT_LIBRARY_VERSION </span><span class="s3">= </span><span class="s1">get_version</span><span class="s3">()</span>
    <span class="s1">TERMINATE_TIMEOUT </span><span class="s3">= </span><span class="s5">30</span>
    <span class="s1">KILL_TIMEOUT </span><span class="s3">= </span><span class="s5">10</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes </span><span class="s3">= </span><span class="s1">ConnectionCache</span><span class="s3">(</span><span class="s4">&quot;No active process.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_results </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">run_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">,</span>
        <span class="s3">*</span><span class="s1">arguments</span><span class="s3">,</span>
        <span class="s1">cwd</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">shell</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stderr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stdin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">output_encoding</span><span class="s3">=</span><span class="s4">&quot;CONSOLE&quot;</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">timeout</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">on_timeout</span><span class="s3">=</span><span class="s4">&quot;terminate&quot;</span><span class="s3">,</span>
        <span class="s1">env</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">env_extra</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Runs a process and waits for it to complete. 
 
        ``command`` and ``arguments`` specify the command to execute and 
        arguments passed to it. See `Specifying command and arguments` for 
        more details. 
 
        The started process can be configured using ``cwd``, ``shell``, ``stdout``, 
        ``stderr``, ``stdin``, ``output_encoding``, ``alias``, ``env`` and 
        ``env_extra`` parameters that are documented in the `Process configuration` 
        section. 
 
        Configuration related to waiting for processes consists of ``timeout`` 
        and ``on_timeout`` parameters that have same semantics than with the 
        `Wait For Process` keyword. 
 
        Process outputs are, by default, written into in-memory buffers. 
        This typically works fine, but there can be problems if the amount of 
        output is large or unlimited. To avoid such problems, outputs can be 
        redirected to files using the ``stdout`` and ``stderr`` configuration 
        parameters. For more information see the `Standard output and error streams` 
        section. 
 
        Returns a `result object` containing information about the execution. 
 
        Note that possible equal signs in ``command`` and ``arguments`` must 
        be escaped with a backslash (e.g. ``name\\=value``). 
 
        Examples: 
        | ${result} = | Run Process | python | -c | print('Hello, world!') | 
        | Should Be Equal | ${result.stdout} | Hello, world! | 
        | ${result} = | Run Process | ${command} | stdout=${CURDIR}/stdout.txt | stderr=STDOUT | 
        | ${result} = | Run Process | ${command} | timeout=1min | on_timeout=continue | 
        | ${result} = | Run Process | java -Dname\\=value Example | shell=True | cwd=${EXAMPLE} | 
 
        This keyword does not change the `active process`. 
        &quot;&quot;&quot;</span>
        <span class="s1">current </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">current</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">handle </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_process</span><span class="s3">(</span>
                <span class="s1">command</span><span class="s3">,</span>
                <span class="s3">*</span><span class="s1">arguments</span><span class="s3">,</span>
                <span class="s1">cwd</span><span class="s3">=</span><span class="s1">cwd</span><span class="s3">,</span>
                <span class="s1">shell</span><span class="s3">=</span><span class="s1">shell</span><span class="s3">,</span>
                <span class="s1">stdout</span><span class="s3">=</span><span class="s1">stdout</span><span class="s3">,</span>
                <span class="s1">stderr</span><span class="s3">=</span><span class="s1">stderr</span><span class="s3">,</span>
                <span class="s1">stdin</span><span class="s3">=</span><span class="s1">stdin</span><span class="s3">,</span>
                <span class="s1">output_encoding</span><span class="s3">=</span><span class="s1">output_encoding</span><span class="s3">,</span>
                <span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">,</span>
                <span class="s1">env</span><span class="s3">=</span><span class="s1">env</span><span class="s3">,</span>
                <span class="s3">**</span><span class="s1">env_extra</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">wait_for_process</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">on_timeout</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">current </span><span class="s3">= </span><span class="s1">current</span>

    <span class="s2">def </span><span class="s1">start_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">,</span>
        <span class="s3">*</span><span class="s1">arguments</span><span class="s3">,</span>
        <span class="s1">cwd</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">shell</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stderr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stdin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">output_encoding</span><span class="s3">=</span><span class="s4">&quot;CONSOLE&quot;</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">env</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">env_extra</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Starts a new process on background. 
 
        See `Specifying command and arguments` and `Process configuration` sections 
        for more information about the arguments, and `Run Process` keyword 
        for related examples. This includes information about redirecting 
        process outputs to avoid process handing due to output buffers getting 
        full. 
 
        Makes the started process new `active process`. Returns the created 
        [https://docs.python.org/3/library/subprocess.html#popen-constructor | 
        subprocess.Popen] object which can be used later to activate this 
        process. ``Popen`` attributes like ``pid`` can also be accessed directly. 
 
        Processes are started so that they create a new process group. This 
        allows terminating and sending signals to possible child processes. 
 
        Examples: 
 
        Start process and wait for it to end later using an alias: 
        | `Start Process` | ${command} | alias=example | 
        | # Other keywords | 
        | ${result} = | `Wait For Process` | example | 
 
        Use returned ``Popen`` object: 
        | ${process} = | `Start Process` | ${command} | 
        | `Log` | PID: ${process.pid} | 
        | # Other keywords | 
        | ${result} = | `Terminate Process` | ${process} | 
 
        Use started process in a pipeline with another process: 
        | ${process} = | `Start Process` | python | -c | print('Hello, world!') | 
        | ${result} = | `Run Process` | python | -c | import sys; print(sys.stdin.read().upper().strip()) | stdin=${process.stdout} | 
        | `Wait For Process` | ${process} | 
        | `Should Be Equal` | ${result.stdout} | HELLO, WORLD! | 
 
        Returning a ``subprocess.Popen`` object is new in Robot Framework 5.0. 
        Earlier versions returned a generic handle and getting the process object 
        required using `Get Process Object` separately. 
        &quot;&quot;&quot;</span>
        <span class="s1">conf </span><span class="s3">= </span><span class="s1">ProcessConfiguration</span><span class="s3">(</span>
            <span class="s1">cwd</span><span class="s3">=</span><span class="s1">cwd</span><span class="s3">,</span>
            <span class="s1">shell</span><span class="s3">=</span><span class="s1">shell</span><span class="s3">,</span>
            <span class="s1">stdout</span><span class="s3">=</span><span class="s1">stdout</span><span class="s3">,</span>
            <span class="s1">stderr</span><span class="s3">=</span><span class="s1">stderr</span><span class="s3">,</span>
            <span class="s1">stdin</span><span class="s3">=</span><span class="s1">stdin</span><span class="s3">,</span>
            <span class="s1">output_encoding</span><span class="s3">=</span><span class="s1">output_encoding</span><span class="s3">,</span>
            <span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">,</span>
            <span class="s1">env</span><span class="s3">=</span><span class="s1">env</span><span class="s3">,</span>
            <span class="s3">**</span><span class="s1">env_extra</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">command </span><span class="s3">= </span><span class="s1">conf</span><span class="s3">.</span><span class="s1">get_command</span><span class="s3">(</span><span class="s1">command</span><span class="s3">, </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_log_start</span><span class="s3">(</span><span class="s1">command</span><span class="s3">, </span><span class="s1">conf</span><span class="s3">)</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">Popen</span><span class="s3">(</span><span class="s1">command</span><span class="s3">, **</span><span class="s1">conf</span><span class="s3">.</span><span class="s1">popen_config</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_results</span><span class="s3">[</span><span class="s1">process</span><span class="s3">] = </span><span class="s1">ExecutionResult</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, **</span><span class="s1">conf</span><span class="s3">.</span><span class="s1">result_config</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">register</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">=</span><span class="s1">conf</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">current</span>

    <span class="s2">def </span><span class="s1">_log_start</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">, </span><span class="s1">config</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">command</span><span class="s3">):</span>
            <span class="s1">command </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">join_command_line</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">f&quot;Starting process:</span><span class="s2">\n{</span><span class="s1">system_decode</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;Process configuration:</span><span class="s2">\n{</span><span class="s1">config</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">is_process_running</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Checks is the process running or not. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Returns ``True`` if the process is still running and ``False`` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">].</span><span class="s1">poll</span><span class="s3">() </span><span class="s2">is None</span>

    <span class="s2">def </span><span class="s1">process_should_be_running</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">error_message</span><span class="s3">=</span><span class="s4">&quot;Process is not running.&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Verifies that the process is running. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Fails if the process has stopped. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_process_running</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">error_message</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">process_should_be_stopped</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">error_message</span><span class="s3">=</span><span class="s4">&quot;Process is running.&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Verifies that the process is not running. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Fails if the process is still running. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_process_running</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">error_message</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">wait_for_process</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">on_timeout</span><span class="s3">=</span><span class="s4">&quot;continue&quot;</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Waits for the process to complete or to reach the given timeout. 
 
        The process to wait for must have been started earlier with 
        `Start Process`. If ``handle`` is not given, uses the current 
        `active process`. 
 
        ``timeout`` defines the maximum time to wait for the process. It can be 
        given in 
        [http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format| 
        various time formats] supported by Robot Framework, for example, ``42``, 
        ``42 s``, or ``1 minute 30 seconds``. The timeout is ignored if it is 
        Python ``None`` (default), string ``NONE`` (case-insensitively), zero, 
        or negative. 
 
        ``on_timeout`` defines what to do if the timeout occurs. Possible values 
        and corresponding actions are explained in the table below. Notice 
        that reaching the timeout never fails the test. 
 
        | = Value = |               = Action =               | 
        | continue  | The process is left running (default). | 
        | terminate | The process is gracefully terminated.  | 
        | kill      | The process is forcefully stopped.     | 
 
        See `Terminate Process` keyword for more details how processes are 
        terminated and killed. 
 
        If the process ends before the timeout, or it is terminated or killed, 
        this keyword returns a `result object` containing information about 
        the execution. If the process is left running, Python ``None`` is 
        returned instead. 
 
        Examples: 
        | # Process ends cleanly      |                  |                  | 
        | ${result} =                 | Wait For Process | example          | 
        | Process Should Be Stopped   | example          |                  | 
        | Should Be Equal As Integers | ${result.rc}     | 0                | 
        | # Process does not end      |                  |                  | 
        | ${result} =                 | Wait For Process | timeout=42 secs  | 
        | Process Should Be Running   |                  |                  | 
        | Should Be Equal             | ${result}        | ${NONE}          | 
        | # Kill non-ending process   |                  |                  | 
        | ${result} =                 | Wait For Process | timeout=1min 30s | on_timeout=kill | 
        | Process Should Be Stopped   |                  |                  | 
        | Should Be Equal As Integers | ${result.rc}     | -9               | 
 
        Note: If Robot Framework's test or keyword timeout is exceeded while 
        this keyword is waiting for the process to end, the process is killed 
        to avoid leaving it running on the background. This is new in Robot 
        Framework 7.3. 
        &quot;&quot;&quot;</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">]</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Waiting for process to complete.&quot;</span><span class="s3">)</span>
        <span class="s1">timeout </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_timeout</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">timeout </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_is_stopped</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">):</span>
            <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">f&quot;Process did not complete in </span><span class="s2">{</span><span class="s1">secs_to_timestr</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_manage_process_timeout</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">, </span><span class="s1">on_timeout</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">())</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_wait</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_timeout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">timeout</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">() == </span><span class="s4">&quot;NONE&quot;</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">timeout</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">-</span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">timestr_to_secs</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_manage_process_timeout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">, </span><span class="s1">on_timeout</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">on_timeout </span><span class="s3">== </span><span class="s4">&quot;terminate&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">terminate_process</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">on_timeout </span><span class="s3">== </span><span class="s4">&quot;kill&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">terminate_process</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">, </span><span class="s1">kill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Leaving process intact.&quot;</span><span class="s3">)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_wait</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">process</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_results</span><span class="s3">[</span><span class="s1">process</span><span class="s3">]</span>
        <span class="s0"># Popen.communicate() does not like closed stdin/stdout/stderr PIPEs.</span>
        <span class="s0"># Due to us using a timeout, we only need to care about stdin.</span>
        <span class="s0"># https://github.com/python/cpython/issues/131064</span>
        <span class="s2">if </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdin </span><span class="s2">and </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">.</span><span class="s1">closed</span><span class="s3">:</span>
            <span class="s1">process</span><span class="s3">.</span><span class="s1">stdin </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s0"># Timeout is used with communicate() to support Robot's timeouts.</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">result</span><span class="s3">.</span><span class="s1">stderr </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">communicate</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">TimeoutExpired</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">except </span><span class="s1">TimeoutExceeded</span><span class="s3">:</span>
                <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Timeout exceeded.&quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_kill</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">break</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">rc </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">returncode</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">close_streams</span><span class="s3">()</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Process completed.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">terminate_process</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">kill</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Stops the process gracefully or forcefully. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        By default, first tries to stop the process gracefully. If the process 
        does not stop in 30 seconds, or ``kill`` argument is given a true value, 
        (see `Boolean arguments`) kills the process forcefully. Stops also all 
        the child processes of the originally started process. 
 
        Waits for the process to stop after terminating it. Returns a `result 
        object` containing information about the execution similarly as `Wait 
        For Process`. 
 
        On Unix-like machines graceful termination is done using ``TERM (15)`` 
        signal and killing using ``KILL (9)``. Use `Send Signal To Process` 
        instead if you just want to send either of these signals without 
        waiting for the process to stop. 
 
        On Windows graceful termination is done using ``CTRL_BREAK_EVENT`` 
        event and killing using Win32 API function ``TerminateProcess()``. 
 
        Examples: 
        | ${result} =                 | Terminate Process |     | 
        | Should Be Equal As Integers | ${result.rc}      | -15 | # On Unixes | 
        | Terminate Process           | myproc            | kill=true | 
 
        Limitations: 
        - On Windows forceful kill only stops the main process, not possible 
          child processes. 
        &quot;&quot;&quot;</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s4">&quot;terminate&quot;</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;Terminating processes is not supported by this Python version.&quot;</span>
            <span class="s3">)</span>
        <span class="s1">terminator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_kill </span><span class="s2">if </span><span class="s1">kill </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_terminate</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">terminator</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_is_stopped</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">KILL_TIMEOUT</span><span class="s3">):</span>
                <span class="s2">raise</span>
            <span class="s1">logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;Ignored OSError because process was stopped.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_wait</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_kill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">process</span><span class="s3">):</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Forcefully killing process.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s4">&quot;killpg&quot;</span><span class="s3">):</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">killpg</span><span class="s3">(</span><span class="s1">process</span><span class="s3">.</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">signal_module</span><span class="s3">.</span><span class="s1">SIGKILL</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">process</span><span class="s3">.</span><span class="s1">kill</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_is_stopped</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">KILL_TIMEOUT</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;Failed to kill process.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_terminate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">process</span><span class="s3">):</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Gracefully terminating process.&quot;</span><span class="s3">)</span>
        <span class="s0"># Sends signal to the whole process group both on POSIX and on Windows</span>
        <span class="s0"># if supported by the interpreter.</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s4">&quot;killpg&quot;</span><span class="s3">):</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">killpg</span><span class="s3">(</span><span class="s1">process</span><span class="s3">.</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">signal_module</span><span class="s3">.</span><span class="s1">SIGTERM</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">signal_module</span><span class="s3">, </span><span class="s4">&quot;CTRL_BREAK_EVENT&quot;</span><span class="s3">):</span>
            <span class="s1">process</span><span class="s3">.</span><span class="s1">send_signal</span><span class="s3">(</span><span class="s1">signal_module</span><span class="s3">.</span><span class="s1">CTRL_BREAK_EVENT</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">process</span><span class="s3">.</span><span class="s1">terminate</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_is_stopped</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">TERMINATE_TIMEOUT</span><span class="s3">):</span>
            <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Graceful termination failed.&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_kill</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">terminate_all_processes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kill</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Terminates all still running processes started by this library. 
 
        This keyword can be used in suite teardown or elsewhere to make 
        sure that all processes are stopped, 
 
        Tries to terminate processes gracefully by default, but can be 
        configured to forcefully kill them immediately. See `Terminate Process` 
        that this keyword uses internally for more details. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">handle </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_process_running</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">terminate_process</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">, </span><span class="s1">kill</span><span class="s3">=</span><span class="s1">kill</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">send_signal_to_process</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">signal</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">group</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Sends the given ``signal`` to the specified process. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Signal can be specified either as an integer as a signal name. In the 
        latter case it is possible to give the name both with or without ``SIG`` 
        prefix, but names are case-sensitive. For example, all the examples 
        below send signal ``INT (2)``: 
 
        | Send Signal To Process | 2      |        | # Send to active process | 
        | Send Signal To Process | INT    |        |                          | 
        | Send Signal To Process | SIGINT | myproc | # Send to named process  | 
 
        This keyword is only supported on Unix-like machines, not on Windows. 
        What signals are supported depends on the system. For a list of 
        existing signals on your system, see the Unix man pages related to 
        signal handling (typically ``man signal`` or ``man 7 signal``). 
 
        By default sends the signal only to the parent process, not to possible 
        child processes started by it. Notice that when `running processes in 
        shell`, the shell is the parent process and it depends on the system 
        does the shell propagate the signal to the actual started process. 
 
        To send the signal to the whole process group, ``group`` argument can 
        be set to any true value (see `Boolean arguments`). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">sep </span><span class="s3">== </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;This keyword does not work on Windows.&quot;</span><span class="s3">)</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">]</span>
        <span class="s1">signum </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_signal_number</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">)</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">f&quot;Sending signal </span><span class="s2">{</span><span class="s1">signal</span><span class="s2">} </span><span class="s4">(</span><span class="s2">{</span><span class="s1">signum</span><span class="s2">}</span><span class="s4">).&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">group </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s4">&quot;killpg&quot;</span><span class="s3">):</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">killpg</span><span class="s3">(</span><span class="s1">process</span><span class="s3">.</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">signum</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s4">&quot;send_signal&quot;</span><span class="s3">):</span>
            <span class="s1">process</span><span class="s3">.</span><span class="s1">send_signal</span><span class="s3">(</span><span class="s1">signum</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;Sending signals is not supported by this Python version.&quot;</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_signal_number</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">int_or_name</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">int_or_name</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_convert_signal_name_to_number</span><span class="s3">(</span><span class="s1">int_or_name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_convert_signal_name_to_number</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span>
                <span class="s1">signal_module</span><span class="s3">, </span><span class="s1">name </span><span class="s2">if </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;SIG&quot;</span><span class="s3">) </span><span class="s2">else </span><span class="s4">&quot;SIG&quot; </span><span class="s3">+ </span><span class="s1">name</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">f&quot;Unsupported signal '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_process_id</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Returns the process ID (pid) of the process as an integer. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Starting from Robot Framework 5.0, it is also possible to directly access 
        the ``pid`` attribute of the ``subprocess.Popen`` object returned by 
        `Start Process` like ``${process.pid}``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">].</span><span class="s1">pid</span>

    <span class="s2">def </span><span class="s1">get_process_object</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Return the underlying ``subprocess.Popen`` object. 
 
        If ``handle`` is not given, uses the current `active process`. 
 
        Starting from Robot Framework 5.0, `Start Process` returns the created 
        ``subprocess.Popen`` object, not a generic handle, making this keyword 
        mostly redundant. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">get_process_result</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">handle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">rc</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stderr</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout_path</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stderr_path</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Returns the specified `result object` or some of its attributes. 
 
        The given ``handle`` specifies the process whose results should be 
        returned. If no ``handle`` is given, results of the current `active 
        process` are returned. In either case, the process must have been 
        finishes before this keyword can be used. In practice this means 
        that processes started with `Start Process` must be finished either 
        with `Wait For Process` or `Terminate Process` before using this 
        keyword. 
 
        If no other arguments than the optional ``handle`` are given, a whole 
        `result object` is returned. If one or more of the other arguments 
        are given any true value, only the specified attributes of the 
        `result object` are returned. These attributes are always returned 
        in the same order as arguments are specified in the keyword signature. 
        See `Boolean arguments` section for more details about true and false 
        values. 
 
        Examples: 
        | Run Process           | python             | -c            | print('Hello, world!') | alias=myproc | 
        | # Get result object   |                    |               | 
        | ${result} =           | Get Process Result | myproc        | 
        | Should Be Equal       | ${result.rc}       | ${0}          | 
        | Should Be Equal       | ${result.stdout}   | Hello, world! | 
        | Should Be Empty       | ${result.stderr}   |               | 
        | # Get one attribute   |                    |               | 
        | ${stdout} =           | Get Process Result | myproc        | stdout=true | 
        | Should Be Equal       | ${stdout}          | Hello, world! | 
        | # Multiple attributes |                    |               | 
        | ${stdout}             | ${stderr} =        | Get Process Result |  myproc | stdout=yes | stderr=yes | 
        | Should Be Equal       | ${stdout}          | Hello, world! | 
        | Should Be Empty       | ${stderr}          |               | 
 
        Although getting results of a previously executed process can be handy 
        in general, the main use case for this keyword is returning results 
        over the remote library interface. The remote interface does not 
        support returning the whole result object, but individual attributes 
        can be returned without problems. 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_results</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">handle</span><span class="s3">]]</span>
        <span class="s2">if </span><span class="s1">result</span><span class="s3">.</span><span class="s1">rc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;Getting results of unfinished processes is not supported.&quot;</span>
            <span class="s3">)</span>
        <span class="s1">attributes </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_result_attributes</span><span class="s3">(</span>
            <span class="s1">result</span><span class="s3">,</span>
            <span class="s1">rc</span><span class="s3">,</span>
            <span class="s1">stdout</span><span class="s3">,</span>
            <span class="s1">stderr</span><span class="s3">,</span>
            <span class="s1">stdout_path</span><span class="s3">,</span>
            <span class="s1">stderr_path</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">attributes</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">attributes</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">attributes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">attributes</span>

    <span class="s2">def </span><span class="s1">_get_result_attributes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, *</span><span class="s1">includes</span><span class="s3">):</span>
        <span class="s1">attributes </span><span class="s3">= (</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">rc</span><span class="s3">,</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">,</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">,</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">stdout_path</span><span class="s3">,</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">stderr_path</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">attr </span><span class="s2">for </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">incl </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">attributes</span><span class="s3">, </span><span class="s1">includes</span><span class="s3">) </span><span class="s2">if </span><span class="s1">incl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">switch_process</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Makes the specified process the current `active process`. 
 
        The handle can be an identifier returned by `Start Process` or 
        the ``alias`` given to it explicitly. 
 
        Example: 
        | Start Process  | prog1    | alias=process1 | 
        | Start Process  | prog2    | alias=process2 | 
        | # currently active process is process2 | 
        | Switch Process | process1 | 
        | # now active process is process1 | 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">switch</span><span class="s3">(</span><span class="s1">handle</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_process_is_stopped</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">process</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">):</span>
        <span class="s1">stopped </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">process</span><span class="s3">.</span><span class="s1">poll</span><span class="s3">() </span><span class="s2">is not None</span>
        <span class="s1">max_time </span><span class="s3">= </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() + </span><span class="s1">timeout</span>
        <span class="s2">while </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() &lt;= </span><span class="s1">max_time </span><span class="s2">and not </span><span class="s1">stopped</span><span class="s3">():</span>
            <span class="s1">time</span><span class="s3">.</span><span class="s1">sleep</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">stopped</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">split_command_line</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">escaping</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Splits command line string into a list of arguments. 
 
        String is split from spaces, but argument surrounded in quotes may 
        contain spaces in them. 
 
        If ``escaping`` is given a true value, then backslash is treated as 
        an escape character. It can escape unquoted spaces, quotes inside 
        quotes, and so on, but it also requires using doubling backslashes 
        in Windows paths and elsewhere. 
 
        Examples: 
        | @{cmd} = | Split Command Line | --option &quot;value with spaces&quot; | 
        | Should Be True | $cmd == ['--option', 'value with spaces'] | 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cmdline2list</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">escaping</span><span class="s3">=</span><span class="s1">escaping</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">join_command_line</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Joins arguments into one command line string. 
 
        In resulting command line string arguments are delimited with a space, 
        arguments containing spaces are surrounded with quotes, and possible 
        quotes are escaped with a backslash. 
 
        If this keyword is given only one argument and that is a list-like 
        object, then the values of that list are joined instead. 
 
        Example: 
        | ${cmd} = | Join Command Line | --option | value with spaces | 
        | Should Be Equal | ${cmd} | --option &quot;value with spaces&quot; | 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">list2cmdline</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ExecutionResult</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">process</span><span class="s3">,</span>
        <span class="s1">stdout</span><span class="s3">,</span>
        <span class="s1">stderr</span><span class="s3">,</span>
        <span class="s1">stdin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">rc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">output_encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_process </span><span class="s3">= </span><span class="s1">process</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_path</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_path</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">rc </span><span class="s3">= </span><span class="s1">rc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_output_encoding </span><span class="s3">= </span><span class="s1">output_encoding</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stdout </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stderr </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_custom_streams </span><span class="s3">= [</span>
            <span class="s1">stream</span>
            <span class="s2">for </span><span class="s1">stream </span><span class="s2">in </span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">stdin</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_custom_stream</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_path</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">name </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_custom_stream</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) </span><span class="s2">else None</span>

    <span class="s2">def </span><span class="s1">_is_custom_stream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">stream </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">, </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">STDOUT</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">stdout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stdout </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stdout</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stdout</span>

    <span class="s3">@</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">stdout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stdout </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_format_output</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">stderr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stderr </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stderr</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stderr</span>

    <span class="s3">@</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">stderr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stderr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_format_output</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_read_stdout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stdout </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_path</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_read_stderr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_stderr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_path</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_read_stream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream_path</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stream_path</span><span class="s3">:</span>
            <span class="s1">stream </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">stream_path</span><span class="s3">, </span><span class="s4">&quot;rb&quot;</span><span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_open</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">content </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">IOError</span><span class="s3">:</span>
            <span class="s1">content </span><span class="s3">= </span><span class="s4">&quot;&quot;</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">stream_path</span><span class="s3">:</span>
                <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_format_output</span><span class="s3">(</span><span class="s1">content</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_is_open</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">stream </span><span class="s2">and not </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">closed</span>

    <span class="s2">def </span><span class="s1">_format_output</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">output</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">output </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">console_decode</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_output_encoding</span><span class="s3">)</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">output</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">):</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">close_streams</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">standard_streams </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_and_read_standard_streams</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">stream </span><span class="s2">in </span><span class="s1">standard_streams </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_custom_streams</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_open</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">):</span>
                <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_get_and_read_standard_streams</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">process</span><span class="s3">):</span>
        <span class="s1">stdin</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">, </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stderr</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_open</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stdout</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_open</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_read_stderr</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">stdin</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;result object with rc </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">rc</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">ProcessConfiguration</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cwd</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">shell</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stderr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stdin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">output_encoding</span><span class="s3">=</span><span class="s4">&quot;CONSOLE&quot;</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">env</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">env_extra</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cwd </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">cwd</span><span class="s3">) </span><span class="s2">if </span><span class="s1">cwd </span><span class="s2">else </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">abspath</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shell </span><span class="s3">= </span><span class="s1">shell</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">alias </span><span class="s3">= </span><span class="s1">alias</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">output_encoding </span><span class="s3">= </span><span class="s1">output_encoding</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_stream </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_new_stream</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_stream </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_stderr</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_stream</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stdin_stream </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_stdin</span><span class="s3">(</span><span class="s1">stdin</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">env </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_construct_env</span><span class="s3">(</span><span class="s1">env</span><span class="s3">, </span><span class="s1">env_extra</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_new_stream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;DEVNULL&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">devnull</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">LOCALE_ENCODING</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cwd</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">LOCALE_ENCODING</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span>

    <span class="s2">def </span><span class="s1">_get_stderr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">stdout_stream</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stderr </span><span class="s2">and </span><span class="s1">stderr </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;STDOUT&quot;</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">stdout_stream </span><span class="s3">!= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">stdout_stream</span>
            <span class="s2">return </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">STDOUT</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_new_stream</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_stdin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stdin</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stdin</span><span class="s3">, </span><span class="s1">Path</span><span class="s3">):</span>
            <span class="s1">stdin </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">stdin</span><span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stdin</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">stdin</span>
        <span class="s2">elif </span><span class="s1">stdin</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">() == </span><span class="s4">&quot;NONE&quot;</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">elif </span><span class="s1">stdin </span><span class="s3">== </span><span class="s4">&quot;PIPE&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cwd</span><span class="s3">, </span><span class="s1">stdin</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">LOCALE_ENCODING</span><span class="s3">)</span>
        <span class="s1">stdin_file </span><span class="s3">= </span><span class="s1">TemporaryFile</span><span class="s3">()</span>
        <span class="s1">stdin_file</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">console_encode</span><span class="s3">(</span><span class="s1">stdin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">output_encoding</span><span class="s3">, </span><span class="s1">force</span><span class="s3">=</span><span class="s2">True</span><span class="s3">))</span>
        <span class="s1">stdin_file</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">stdin_file</span>

    <span class="s2">def </span><span class="s1">_construct_env</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">env</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">):</span>
        <span class="s1">env </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_initial_env</span><span class="s3">(</span><span class="s1">env</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">env </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">WINDOWS</span><span class="s3">:</span>
            <span class="s1">env </span><span class="s3">= </span><span class="s1">NormalizedDict</span><span class="s3">(</span><span class="s1">env</span><span class="s3">, </span><span class="s1">spaceless</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_to_env</span><span class="s3">(</span><span class="s1">env</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">WINDOWS</span><span class="s3">:</span>
            <span class="s1">env </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">(): </span><span class="s1">env</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">env</span><span class="s3">}</span>
        <span class="s2">return </span><span class="s1">env</span>

    <span class="s2">def </span><span class="s1">_get_initial_env</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">env</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">env</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">{</span><span class="s1">system_encode</span><span class="s3">(</span><span class="s1">k</span><span class="s3">): </span><span class="s1">system_encode</span><span class="s3">(</span><span class="s1">env</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">env</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">extra</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_add_to_env</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">env</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">extra</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;env:&quot;</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Keyword argument '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' is not supported by this keyword.&quot;</span>
                <span class="s3">)</span>
            <span class="s1">env</span><span class="s3">[</span><span class="s1">system_encode</span><span class="s3">(</span><span class="s1">name</span><span class="s3">[</span><span class="s5">4</span><span class="s3">:])] = </span><span class="s1">system_encode</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">[</span><span class="s1">name</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">get_command</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">):</span>
        <span class="s1">command </span><span class="s3">= [</span><span class="s1">system_encode</span><span class="s3">(</span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s3">(</span><span class="s1">command</span><span class="s3">, *</span><span class="s1">arguments</span><span class="s3">)]</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shell</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">command</span>
        <span class="s2">if </span><span class="s1">arguments</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">list2cmdline</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">command</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">popen_config</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">config </span><span class="s3">= {</span>
            <span class="s4">&quot;stdout&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_stream</span><span class="s3">,</span>
            <span class="s4">&quot;stderr&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_stream</span><span class="s3">,</span>
            <span class="s4">&quot;stdin&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdin_stream</span><span class="s3">,</span>
            <span class="s4">&quot;shell&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shell</span><span class="s3">,</span>
            <span class="s4">&quot;cwd&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cwd</span><span class="s3">,</span>
            <span class="s4">&quot;env&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">env</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_process_group_config</span><span class="s3">(</span><span class="s1">config</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">config</span>

    <span class="s2">def </span><span class="s1">_add_process_group_config</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">config</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s4">&quot;setsid&quot;</span><span class="s3">):</span>
            <span class="s1">config</span><span class="s3">[</span><span class="s4">&quot;start_new_session&quot;</span><span class="s3">] = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">subprocess</span><span class="s3">, </span><span class="s4">&quot;CREATE_NEW_PROCESS_GROUP&quot;</span><span class="s3">):</span>
            <span class="s1">config</span><span class="s3">[</span><span class="s4">&quot;creationflags&quot;</span><span class="s3">] = </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">CREATE_NEW_PROCESS_GROUP</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">result_config</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span>
            <span class="s4">&quot;stdout&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_stream</span><span class="s3">,</span>
            <span class="s4">&quot;stderr&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_stream</span><span class="s3">,</span>
            <span class="s4">&quot;stdin&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdin_stream</span><span class="s3">,</span>
            <span class="s4">&quot;output_encoding&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">output_encoding</span><span class="s3">,</span>
        <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">cwd:     </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cwd</span><span class="s2">}</span>
<span class="s4">shell:   </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shell</span><span class="s2">}</span>
<span class="s4">stdout:  </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stream_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdout_stream</span><span class="s3">)</span><span class="s2">}</span>
<span class="s4">stderr:  </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stream_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stderr_stream</span><span class="s3">)</span><span class="s2">}</span>
<span class="s4">stdin:   </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stream_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stdin_stream</span><span class="s3">)</span><span class="s2">}</span>
<span class="s4">alias:   </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">alias</span><span class="s2">}</span>
<span class="s4">env:     </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">env</span><span class="s2">}</span><span class="s4">&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_stream_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s4">&quot;name&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">return </span><span class="s3">{</span>
            <span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">: </span><span class="s4">&quot;PIPE&quot;</span><span class="s3">,</span>
            <span class="s1">subprocess</span><span class="s3">.</span><span class="s1">STDOUT</span><span class="s3">: </span><span class="s4">&quot;STDOUT&quot;</span><span class="s3">,</span>
            <span class="s2">None</span><span class="s3">: </span><span class="s4">&quot;None&quot;</span><span class="s3">,</span>
        <span class="s3">}.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">)</span>
</pre>
</body>
</html>