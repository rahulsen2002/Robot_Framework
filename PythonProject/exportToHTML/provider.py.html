<html>
<head>
<title>provider.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
provider.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">math</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">Mapping</span><span class="s2">, </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">cache</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pip</span><span class="s2">.</span><span class="s1">_vendor</span><span class="s2">.</span><span class="s1">resolvelib</span><span class="s2">.</span><span class="s1">providers </span><span class="s0">import </span><span class="s1">AbstractProvider</span>

<span class="s0">from </span><span class="s1">pip</span><span class="s2">.</span><span class="s1">_internal</span><span class="s2">.</span><span class="s1">req</span><span class="s2">.</span><span class="s1">req_install </span><span class="s0">import </span><span class="s1">InstallRequirement</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">Candidate</span><span class="s2">, </span><span class="s1">Constraint</span><span class="s2">, </span><span class="s1">Requirement</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">candidates </span><span class="s0">import </span><span class="s1">REQUIRES_PYTHON_IDENTIFIER</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">factory </span><span class="s0">import </span><span class="s1">Factory</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">requirements </span><span class="s0">import </span><span class="s1">ExplicitRequirement</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pip</span><span class="s2">.</span><span class="s1">_vendor</span><span class="s2">.</span><span class="s1">resolvelib</span><span class="s2">.</span><span class="s1">providers </span><span class="s0">import </span><span class="s1">Preference</span>
    <span class="s0">from </span><span class="s1">pip</span><span class="s2">.</span><span class="s1">_vendor</span><span class="s2">.</span><span class="s1">resolvelib</span><span class="s2">.</span><span class="s1">resolvers </span><span class="s0">import </span><span class="s1">RequirementInformation</span>

    <span class="s1">PreferenceInformation </span><span class="s2">= </span><span class="s1">RequirementInformation</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">, </span><span class="s1">Candidate</span><span class="s2">]</span>

    <span class="s1">_ProviderBase </span><span class="s2">= </span><span class="s1">AbstractProvider</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">, </span><span class="s1">Candidate</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">_ProviderBase </span><span class="s2">= </span><span class="s1">AbstractProvider</span>

<span class="s3"># Notes on the relationship between the provider, the factory, and the</span>
<span class="s3"># candidate and requirement classes.</span>
<span class="s3">#</span>
<span class="s3"># The provider is a direct implementation of the resolvelib class. Its role</span>
<span class="s3"># is to deliver the API that resolvelib expects.</span>
<span class="s3">#</span>
<span class="s3"># Rather than work with completely abstract &quot;requirement&quot; and &quot;candidate&quot;</span>
<span class="s3"># concepts as resolvelib does, pip has concrete classes implementing these two</span>
<span class="s3"># ideas. The API of Requirement and Candidate objects are defined in the base</span>
<span class="s3"># classes, but essentially map fairly directly to the equivalent provider</span>
<span class="s3"># methods. In particular, `find_matches` and `is_satisfied_by` are</span>
<span class="s3"># requirement methods, and `get_dependencies` is a candidate method.</span>
<span class="s3">#</span>
<span class="s3"># The factory is the interface to pip's internal mechanisms. It is stateless,</span>
<span class="s3"># and is created by the resolver and held as a property of the provider. It is</span>
<span class="s3"># responsible for creating Requirement and Candidate objects, and provides</span>
<span class="s3"># services to those objects (access to pip's finder and preparer).</span>


<span class="s1">D </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">&quot;D&quot;</span><span class="s2">)</span>
<span class="s1">V </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">&quot;V&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_with_identifier</span><span class="s2">(</span>
    <span class="s1">mapping</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">V</span><span class="s2">],</span>
    <span class="s1">identifier</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">default</span><span class="s2">: </span><span class="s1">D</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; D </span><span class="s2">| </span><span class="s1">V</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;Get item from a package name lookup mapping with a resolver identifier. 
 
    This extra logic is needed when the target mapping is keyed by package 
    name, which cannot be directly looked up with an identifier (which may 
    contain requested extras). Additional logic is added to also look up a value 
    by &quot;cleaning up&quot; the extras from the identifier. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">identifier </span><span class="s0">in </span><span class="s1">mapping</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">identifier</span><span class="s2">]</span>
    <span class="s3"># HACK: Theoretically we should check whether this identifier is a valid</span>
    <span class="s3"># &quot;NAME[EXTRAS]&quot; format, and parse out the name part with packaging or</span>
    <span class="s3"># some regular expression. But since pip's resolver only spits out three</span>
    <span class="s3"># kinds of identifiers: normalized PEP 503 names, normalized names plus</span>
    <span class="s3"># extras, and Requires-Python, we can cheat a bit here.</span>
    <span class="s1">name</span><span class="s2">, </span><span class="s1">open_bracket</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">identifier</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span><span class="s4">&quot;[&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">open_bracket </span><span class="s0">and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">mapping</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">default</span>


<span class="s0">class </span><span class="s1">PipProvider</span><span class="s2">(</span><span class="s1">_ProviderBase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Pip's provider implementation for resolvelib. 
 
    :params constraints: A mapping of constraints specified by the user. Keys 
        are canonicalized project names. 
    :params ignore_dependencies: Whether the user specified ``--no-deps``. 
    :params upgrade_strategy: The user-specified upgrade strategy. 
    :params user_requested: A set of canonicalized package names that the user 
        supplied for pip to install/upgrade. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">factory</span><span class="s2">: </span><span class="s1">Factory</span><span class="s2">,</span>
        <span class="s1">constraints</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Constraint</span><span class="s2">],</span>
        <span class="s1">ignore_dependencies</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">upgrade_strategy</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">user_requested</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_factory </span><span class="s2">= </span><span class="s1">factory</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_constraints </span><span class="s2">= </span><span class="s1">constraints</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ignore_dependencies </span><span class="s2">= </span><span class="s1">ignore_dependencies</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_upgrade_strategy </span><span class="s2">= </span><span class="s1">upgrade_strategy</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_user_requested </span><span class="s2">= </span><span class="s1">user_requested</span>

    <span class="s0">def </span><span class="s1">identify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">requirement_or_candidate</span><span class="s2">: </span><span class="s1">Requirement </span><span class="s2">| </span><span class="s1">Candidate</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">requirement_or_candidate</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">narrow_requirement_selection</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">identifiers</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">str</span><span class="s2">],</span>
        <span class="s1">resolutions</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Candidate</span><span class="s2">],</span>
        <span class="s1">candidates</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">Candidate</span><span class="s2">]],</span>
        <span class="s1">information</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">PreferenceInformation</span><span class="s2">]],</span>
        <span class="s1">backtrack_causes</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">PreferenceInformation</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Produce a subset of identifiers that should be considered before others. 
 
        Currently pip narrows the following selection: 
            * Requires-Python, if present is always returned by itself 
            * Backtrack causes are considered next because they can be identified 
              in linear time here, whereas because get_preference() is called 
              for each identifier, it would be quadratic to check for them there. 
              Further, the current backtrack causes likely need to be resolved 
              before other requirements as a resolution can't be found while 
              there is a conflict. 
        &quot;&quot;&quot;</span>
        <span class="s1">backtrack_identifiers </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">info </span><span class="s0">in </span><span class="s1">backtrack_causes</span><span class="s2">:</span>
            <span class="s1">backtrack_identifiers</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">info</span><span class="s2">.</span><span class="s1">requirement</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">info</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">backtrack_identifiers</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">info</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s1">current_backtrack_causes </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">identifier </span><span class="s0">in </span><span class="s1">identifiers</span><span class="s2">:</span>
            <span class="s3"># Requires-Python has only one candidate and the check is basically</span>
            <span class="s3"># free, so we always do it first to avoid needless work if it fails.</span>
            <span class="s3"># This skips calling get_preference() for all other identifiers.</span>
            <span class="s0">if </span><span class="s1">identifier </span><span class="s2">== </span><span class="s1">REQUIRES_PYTHON_IDENTIFIER</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">identifier</span><span class="s2">]</span>

            <span class="s3"># Check if this identifier is a backtrack cause</span>
            <span class="s0">if </span><span class="s1">identifier </span><span class="s0">in </span><span class="s1">backtrack_identifiers</span><span class="s2">:</span>
                <span class="s1">current_backtrack_causes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">)</span>
                <span class="s0">continue</span>

        <span class="s0">if </span><span class="s1">current_backtrack_causes</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">current_backtrack_causes</span>

        <span class="s0">return </span><span class="s1">identifiers</span>

    <span class="s0">def </span><span class="s1">get_preference</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">identifier</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">resolutions</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Candidate</span><span class="s2">],</span>
        <span class="s1">candidates</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">Candidate</span><span class="s2">]],</span>
        <span class="s1">information</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">PreferenceInformation</span><span class="s2">]],</span>
        <span class="s1">backtrack_causes</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">PreferenceInformation</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; Preference</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Produce a sort key for given requirement based on preference. 
 
        The lower the return value is, the more preferred this group of 
        arguments is. 
 
        Currently pip considers the following in order: 
 
        * Any requirement that is &quot;direct&quot;, e.g., points to an explicit URL. 
        * Any requirement that is &quot;pinned&quot;, i.e., contains the operator ``===`` 
          or ``==`` without a wildcard. 
        * Any requirement that imposes an upper version limit, i.e., contains the 
          operator ``&lt;``, ``&lt;=``, ``~=``, or ``==`` with a wildcard. Because 
          pip prioritizes the latest version, preferring explicit upper bounds 
          can rule out infeasible candidates sooner. This does not imply that 
          upper bounds are good practice; they can make dependency management 
          and resolution harder. 
        * Order user-specified requirements as they are specified, placing 
          other requirements afterward. 
        * Any &quot;non-free&quot; requirement, i.e., one that contains at least one 
          operator, such as ``&gt;=`` or ``!=``. 
        * Alphabetical order for consistency (aids debuggability). 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">information</span><span class="s2">[</span><span class="s1">identifier</span><span class="s2">]))</span>
        <span class="s0">except </span><span class="s1">StopIteration</span><span class="s2">:</span>
            <span class="s3"># There is no information for this identifier, so there's no known</span>
            <span class="s3"># candidates.</span>
            <span class="s1">has_information </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">has_information </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">if not </span><span class="s1">has_information</span><span class="s2">:</span>
            <span class="s1">direct </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">ireqs</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">InstallRequirement </span><span class="s2">| </span><span class="s0">None</span><span class="s2">, ...] = ()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># Go through the information and for each requirement,</span>
            <span class="s3"># check if it's explicit (e.g., a direct link) and get the</span>
            <span class="s3"># InstallRequirement (the second element) from get_candidate_lookup()</span>
            <span class="s1">directs</span><span class="s2">, </span><span class="s1">ireqs </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span>
                <span class="s2">*(</span>
                    <span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">ExplicitRequirement</span><span class="s2">), </span><span class="s1">r</span><span class="s2">.</span><span class="s1">get_candidate_lookup</span><span class="s2">()[</span><span class="s6">1</span><span class="s2">])</span>
                    <span class="s0">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">information</span><span class="s2">[</span><span class="s1">identifier</span><span class="s2">]</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s1">direct </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(</span><span class="s1">directs</span><span class="s2">)</span>

        <span class="s1">operators</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]] = [</span>
            <span class="s2">(</span><span class="s1">specifier</span><span class="s2">.</span><span class="s1">operator</span><span class="s2">, </span><span class="s1">specifier</span><span class="s2">.</span><span class="s1">version</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">specifier_set </span><span class="s0">in </span><span class="s2">(</span><span class="s1">ireq</span><span class="s2">.</span><span class="s1">specifier </span><span class="s0">for </span><span class="s1">ireq </span><span class="s0">in </span><span class="s1">ireqs </span><span class="s0">if </span><span class="s1">ireq</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">specifier </span><span class="s0">in </span><span class="s1">specifier_set</span>
        <span class="s2">]</span>

        <span class="s1">pinned </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(((</span><span class="s1">op</span><span class="s2">[:</span><span class="s6">2</span><span class="s2">] == </span><span class="s4">&quot;==&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s4">&quot;*&quot; </span><span class="s0">not in </span><span class="s1">ver</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">ver </span><span class="s0">in </span><span class="s1">operators</span><span class="s2">)</span>
        <span class="s1">upper_bounded </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(</span>
            <span class="s2">((</span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s4">&quot;&lt;&quot;</span><span class="s2">, </span><span class="s4">&quot;&lt;=&quot;</span><span class="s2">, </span><span class="s4">&quot;~=&quot;</span><span class="s2">)) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">op </span><span class="s2">== </span><span class="s4">&quot;==&quot; </span><span class="s0">and </span><span class="s4">&quot;*&quot; </span><span class="s0">in </span><span class="s1">ver</span><span class="s2">))</span>
            <span class="s0">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">ver </span><span class="s0">in </span><span class="s1">operators</span>
        <span class="s2">)</span>
        <span class="s1">unfree </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">operators</span><span class="s2">)</span>
        <span class="s1">requested_order </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_user_requested</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">, </span><span class="s1">math</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">direct</span><span class="s2">,</span>
            <span class="s0">not </span><span class="s1">pinned</span><span class="s2">,</span>
            <span class="s0">not </span><span class="s1">upper_bounded</span><span class="s2">,</span>
            <span class="s1">requested_order</span><span class="s2">,</span>
            <span class="s0">not </span><span class="s1">unfree</span><span class="s2">,</span>
            <span class="s1">identifier</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">find_matches</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">identifier</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">requirements</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">]],</span>
        <span class="s1">incompatibilities</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">[</span><span class="s1">Candidate</span><span class="s2">]],</span>
    <span class="s2">) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">Candidate</span><span class="s2">]:</span>
        <span class="s0">def </span><span class="s1">_eligible_for_upgrade</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
            <span class="s5">&quot;&quot;&quot;Are upgrades allowed for this project? 
 
            This checks the upgrade strategy, and whether the project was one 
            that the user specified in the command line, in order to decide 
            whether we should upgrade if there's a newer version available. 
 
            (Note that we don't need access to the `--upgrade` flag, because 
            an upgrade strategy of &quot;to-satisfy-only&quot; means that `--upgrade` 
            was not specified). 
            &quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upgrade_strategy </span><span class="s2">== </span><span class="s4">&quot;eager&quot;</span><span class="s2">:</span>
                <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upgrade_strategy </span><span class="s2">== </span><span class="s4">&quot;only-if-needed&quot;</span><span class="s2">:</span>
                <span class="s1">user_order </span><span class="s2">= </span><span class="s1">_get_with_identifier</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_user_requested</span><span class="s2">,</span>
                    <span class="s1">identifier</span><span class="s2">,</span>
                    <span class="s1">default</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">return </span><span class="s1">user_order </span><span class="s0">is not None</span>
            <span class="s0">return False</span>

        <span class="s1">constraint </span><span class="s2">= </span><span class="s1">_get_with_identifier</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_constraints</span><span class="s2">,</span>
            <span class="s1">identifier</span><span class="s2">,</span>
            <span class="s1">default</span><span class="s2">=</span><span class="s1">Constraint</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_factory</span><span class="s2">.</span><span class="s1">find_candidates</span><span class="s2">(</span>
            <span class="s1">identifier</span><span class="s2">=</span><span class="s1">identifier</span><span class="s2">,</span>
            <span class="s1">requirements</span><span class="s2">=</span><span class="s1">requirements</span><span class="s2">,</span>
            <span class="s1">constraint</span><span class="s2">=</span><span class="s1">constraint</span><span class="s2">,</span>
            <span class="s1">prefers_installed</span><span class="s2">=(</span><span class="s0">not </span><span class="s1">_eligible_for_upgrade</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">)),</span>
            <span class="s1">incompatibilities</span><span class="s2">=</span><span class="s1">incompatibilities</span><span class="s2">,</span>
            <span class="s1">is_satisfied_by</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_satisfied_by</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s2">@</span><span class="s1">cache</span>
    <span class="s0">def </span><span class="s1">is_satisfied_by</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">: </span><span class="s1">Requirement</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">: </span><span class="s1">Candidate</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">requirement</span><span class="s2">.</span><span class="s1">is_satisfied_by</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_dependencies</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">: </span><span class="s1">Candidate</span><span class="s2">) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">]:</span>
        <span class="s1">with_requires </span><span class="s2">= </span><span class="s0">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ignore_dependencies</span>
        <span class="s3"># iter_dependencies() can perform nontrivial work so delay until needed.</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">r </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">candidate</span><span class="s2">.</span><span class="s1">iter_dependencies</span><span class="s2">(</span><span class="s1">with_requires</span><span class="s2">) </span><span class="s0">if </span><span class="s1">r </span><span class="s0">is not None</span><span class="s2">)</span>
</pre>
</body>
</html>