<html>
<head>
<title>_funcs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_funcs.py</font>
</center></td></tr></table>
<pre><span class="s0"># SPDX-License-Identifier: MIT</span>


<span class="s2">import </span><span class="s1">copy</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_compat </span><span class="s2">import </span><span class="s1">PY_3_9_PLUS</span><span class="s3">, </span><span class="s1">get_generic_base</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_make </span><span class="s2">import </span><span class="s1">_OBJ_SETATTR</span><span class="s3">, </span><span class="s1">NOTHING</span><span class="s3">, </span><span class="s1">fields</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s1">AttrsAttributeNotFoundError</span>


<span class="s2">def </span><span class="s1">asdict</span><span class="s3">(</span>
    <span class="s1">inst</span><span class="s3">,</span>
    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the *attrs* attribute values of *inst* as a dict. 
 
    Optionally recurse into other *attrs*-decorated classes. 
 
    Args: 
        inst: Instance of an *attrs*-decorated class. 
 
        recurse (bool): Recurse into classes that are also *attrs*-decorated. 
 
        filter (~typing.Callable): 
            A callable whose return code determines whether an attribute or 
            element is included (`True`) or dropped (`False`).  Is called with 
            the `attrs.Attribute` as the first argument and the value as the 
            second argument. 
 
        dict_factory (~typing.Callable): 
            A callable to produce dictionaries from.  For example, to produce 
            ordered dictionaries instead of normal Python dictionaries, pass in 
            ``collections.OrderedDict``. 
 
        retain_collection_types (bool): 
            Do not convert to `list` when encountering an attribute whose type 
            is `tuple` or `set`.  Only meaningful if *recurse* is `True`. 
 
        value_serializer (typing.Callable | None): 
            A hook that is called for every attribute or dict key/value.  It 
            receives the current instance, field and value and must return the 
            (updated) value.  The hook is run *after* the optional *filter* has 
            been applied. 
 
    Returns: 
        Return type of *dict_factory*. 
 
    Raises: 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    ..  versionadded:: 16.0.0 *dict_factory* 
    ..  versionadded:: 16.1.0 *retain_collection_types* 
    ..  versionadded:: 20.3.0 *value_serializer* 
    ..  versionadded:: 21.3.0 
        If a dict has a collection for a key, it is serialized as a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s1">rv </span><span class="s3">= </span><span class="s1">dict_factory</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">filter </span><span class="s2">is not None and not </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">value_serializer </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">value_serializer</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">recurse </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">):</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">asdict</span><span class="s3">(</span>
                    <span class="s1">v</span><span class="s3">,</span>
                    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
                <span class="s1">cf </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain_collection_types </span><span class="s2">is True else </span><span class="s1">list</span>
                <span class="s1">items </span><span class="s3">= [</span>
                    <span class="s1">_asdict_anything</span><span class="s3">(</span>
                        <span class="s1">i</span><span class="s3">,</span>
                        <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                        <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                        <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                        <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                        <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span>
                <span class="s3">]</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">cf</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cf</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                        <span class="s2">raise</span>
                    <span class="s0"># Workaround for TypeError: cf.__new__() missing 1 required</span>
                    <span class="s0"># positional argument (which appears, for a namedturle)</span>
                    <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">cf</span><span class="s3">(*</span><span class="s1">items</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s1">df </span><span class="s3">= </span><span class="s1">dict_factory</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">df</span><span class="s3">(</span>
                    <span class="s3">(</span>
                        <span class="s1">_asdict_anything</span><span class="s3">(</span>
                            <span class="s1">kk</span><span class="s3">,</span>
                            <span class="s1">is_key</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                        <span class="s3">),</span>
                        <span class="s1">_asdict_anything</span><span class="s3">(</span>
                            <span class="s1">vv</span><span class="s3">,</span>
                            <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                        <span class="s3">),</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">v</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">v</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">v</span>
    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">_asdict_anything</span><span class="s3">(</span>
    <span class="s1">val</span><span class="s3">,</span>
    <span class="s1">is_key</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">,</span>
    <span class="s1">dict_factory</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">,</span>
    <span class="s1">value_serializer</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    ``asdict`` only works on attrs instances, this works on anything. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s0"># Attrs class.</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">asdict</span><span class="s3">(</span>
            <span class="s1">val</span><span class="s3">,</span>
            <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">retain_collection_types </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">__class__</span>
        <span class="s2">elif </span><span class="s1">is_key</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">tuple</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">list</span>

        <span class="s1">rv </span><span class="s3">= </span><span class="s1">cf</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">i</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">val</span>
            <span class="s3">]</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">dict_factory</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">df</span><span class="s3">(</span>
            <span class="s3">(</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">kk</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">),</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">vv</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">),</span>
            <span class="s3">)</span>
            <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">val</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">val</span>
        <span class="s2">if </span><span class="s1">value_serializer </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">rv </span><span class="s3">= </span><span class="s1">value_serializer</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">astuple</span><span class="s3">(</span>
    <span class="s1">inst</span><span class="s3">,</span>
    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the *attrs* attribute values of *inst* as a tuple. 
 
    Optionally recurse into other *attrs*-decorated classes. 
 
    Args: 
        inst: Instance of an *attrs*-decorated class. 
 
        recurse (bool): 
            Recurse into classes that are also *attrs*-decorated. 
 
        filter (~typing.Callable): 
            A callable whose return code determines whether an attribute or 
            element is included (`True`) or dropped (`False`).  Is called with 
            the `attrs.Attribute` as the first argument and the value as the 
            second argument. 
 
        tuple_factory (~typing.Callable): 
            A callable to produce tuples from. For example, to produce lists 
            instead of tuples. 
 
        retain_collection_types (bool): 
            Do not convert to `list` or `dict` when encountering an attribute 
            which type is `tuple`, `dict` or `set`. Only meaningful if 
            *recurse* is `True`. 
 
    Returns: 
        Return type of *tuple_factory* 
 
    Raises: 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    ..  versionadded:: 16.2.0 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s1">rv </span><span class="s3">= []</span>
    <span class="s1">retain </span><span class="s3">= </span><span class="s1">retain_collection_types  </span><span class="s0"># Very long. :/</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">filter </span><span class="s2">is not None and not </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">recurse </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">):</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">astuple</span><span class="s3">(</span>
                        <span class="s1">v</span><span class="s3">,</span>
                        <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                        <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                        <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
                <span class="s1">cf </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain </span><span class="s2">is True else </span><span class="s1">list</span>
                <span class="s1">items </span><span class="s3">= [</span>
                    <span class="s3">(</span>
                        <span class="s1">astuple</span><span class="s3">(</span>
                            <span class="s1">j</span><span class="s3">,</span>
                            <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                        <span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">j</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                        <span class="s2">else </span><span class="s1">j</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">v</span>
                <span class="s3">]</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">cf</span><span class="s3">(</span><span class="s1">items</span><span class="s3">))</span>
                <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cf</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                        <span class="s2">raise</span>
                    <span class="s0"># Workaround for TypeError: cf.__new__() missing 1 required</span>
                    <span class="s0"># positional argument (which appears, for a namedturle)</span>
                    <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">cf</span><span class="s3">(*</span><span class="s1">items</span><span class="s3">))</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s1">df </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain </span><span class="s2">is True else </span><span class="s1">dict</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">df</span><span class="s3">(</span>
                        <span class="s3">(</span>
                            <span class="s3">(</span>
                                <span class="s1">astuple</span><span class="s3">(</span>
                                    <span class="s1">kk</span><span class="s3">,</span>
                                    <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                                <span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">kk</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                                <span class="s2">else </span><span class="s1">kk</span>
                            <span class="s3">),</span>
                            <span class="s3">(</span>
                                <span class="s1">astuple</span><span class="s3">(</span>
                                    <span class="s1">vv</span><span class="s3">,</span>
                                    <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                                <span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">vv</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                                <span class="s2">else </span><span class="s1">vv</span>
                            <span class="s3">),</span>
                        <span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">v</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">rv </span><span class="s2">if </span><span class="s1">tuple_factory </span><span class="s2">is </span><span class="s1">list </span><span class="s2">else </span><span class="s1">tuple_factory</span><span class="s3">(</span><span class="s1">rv</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">has</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether *cls* is a class with *attrs* attributes. 
 
    Args: 
        cls (type): Class to introspect. 
 
    Raises: 
        TypeError: If *cls* is not a class. 
 
    Returns: 
        bool: 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return True</span>

    <span class="s0"># No attrs, maybe it's a specialized generic (A[str])?</span>
    <span class="s1">generic_base </span><span class="s3">= </span><span class="s1">get_generic_base</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">generic_base </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">generic_attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">generic_base</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">generic_attrs </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># Stick it on here for speed next time.</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_attrs__ </span><span class="s3">= </span><span class="s1">generic_attrs</span>
        <span class="s2">return </span><span class="s1">generic_attrs </span><span class="s2">is not None</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">assoc</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Copy *inst* and apply *changes*. 
 
    This is different from `evolve` that applies the changes to the arguments 
    that create the new instance. 
 
    `evolve`'s behavior is preferable, but there are `edge cases`_ where it 
    doesn't work. Therefore `assoc` is deprecated, but will not be removed. 
 
    .. _`edge cases`: https://github.com/python-attrs/attrs/issues/251 
 
    Args: 
        inst: Instance of a class with *attrs* attributes. 
 
        changes: Keyword changes in the new copy. 
 
    Returns: 
        A copy of inst with *changes* incorporated. 
 
    Raises: 
        attrs.exceptions.AttrsAttributeNotFoundError: 
            If *attr_name* couldn't be found on *cls*. 
 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    ..  deprecated:: 17.1.0 
        Use `attrs.evolve` instead if you can. This function will not be 
        removed du to the slightly different approach compared to 
        `attrs.evolve`, though. 
    &quot;&quot;&quot;</span>
    <span class="s1">new </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">changes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">NOTHING</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">is </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">} </span><span class="s5">is not an attrs attribute on </span><span class="s2">{</span><span class="s1">new</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s5">.&quot;</span>
            <span class="s2">raise </span><span class="s1">AttrsAttributeNotFoundError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s1">_OBJ_SETATTR</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">new</span>


<span class="s2">def </span><span class="s1">resolve_types</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">attribs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">include_extras</span><span class="s3">=</span><span class="s2">True</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Resolve any strings and forward annotations in type annotations. 
 
    This is only required if you need concrete types in :class:`Attribute`'s 
    *type* field. In other words, you don't need to resolve your types if you 
    only use them for static type checking. 
 
    With no arguments, names will be looked up in the module in which the class 
    was created. If this is not what you want, for example, if the name only 
    exists inside a method, you may pass *globalns* or *localns* to specify 
    other dictionaries in which to look up these names. See the docs of 
    `typing.get_type_hints` for more details. 
 
    Args: 
        cls (type): Class to resolve. 
 
        globalns (dict | None): Dictionary containing global variables. 
 
        localns (dict | None): Dictionary containing local variables. 
 
        attribs (list | None): 
            List of attribs for the given class. This is necessary when calling 
            from inside a ``field_transformer`` since *cls* is not an *attrs* 
            class yet. 
 
        include_extras (bool): 
            Resolve more accurately, if possible. Pass ``include_extras`` to 
            ``typing.get_hints``, if supported by the typing module. On 
            supported Python versions (3.9+), this resolves the types more 
            accurately. 
 
    Raises: 
        TypeError: If *cls* is not a class. 
 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class and you didn't pass any attribs. 
 
        NameError: If types cannot be resolved because of missing variables. 
 
    Returns: 
        *cls* so you can use this function also as a class decorator. Please 
        note that you have to apply it **after** `attrs.define`. That means the 
        decorator has to come in the line **before** `attrs.define`. 
 
    ..  versionadded:: 20.1.0 
    ..  versionadded:: 21.1.0 *attribs* 
    ..  versionadded:: 23.1.0 *include_extras* 
    &quot;&quot;&quot;</span>
    <span class="s0"># Since calling get_type_hints is expensive we cache whether we've</span>
    <span class="s0"># done it already.</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">&quot;__attrs_types_resolved__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) != </span><span class="s1">cls</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">typing</span>

        <span class="s1">kwargs </span><span class="s3">= {</span><span class="s5">&quot;globalns&quot;</span><span class="s3">: </span><span class="s1">globalns</span><span class="s3">, </span><span class="s5">&quot;localns&quot;</span><span class="s3">: </span><span class="s1">localns</span><span class="s3">}</span>

        <span class="s2">if </span><span class="s1">PY_3_9_PLUS</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s5">&quot;include_extras&quot;</span><span class="s3">] = </span><span class="s1">include_extras</span>

        <span class="s1">hints </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">get_type_hints</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s2">if </span><span class="s1">attribs </span><span class="s2">is None else </span><span class="s1">attribs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">hints</span><span class="s3">:</span>
                <span class="s0"># Since fields have been frozen we must work around it.</span>
                <span class="s1">_OBJ_SETATTR</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s5">&quot;type&quot;</span><span class="s3">, </span><span class="s1">hints</span><span class="s3">[</span><span class="s1">field</span><span class="s3">.</span><span class="s1">name</span><span class="s3">])</span>
        <span class="s0"># We store the class we resolved so that subclasses know they haven't</span>
        <span class="s0"># been resolved.</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_types_resolved__ </span><span class="s3">= </span><span class="s1">cls</span>

    <span class="s0"># Return the class so you can use it as a decorator too.</span>
    <span class="s2">return </span><span class="s1">cls</span>
</pre>
</body>
</html>