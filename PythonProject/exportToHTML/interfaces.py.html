<html>
<head>
<title>interfaces.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interfaces.py</font>
</center></td></tr></table>
<pre><span class="s0">#  Copyright 2008-2015 Nokia Networks</span>
<span class="s0">#  Copyright 2016-     Robot Framework Foundation</span>
<span class="s0">#</span>
<span class="s0">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0">#  you may not use this file except in compliance with the License.</span>
<span class="s0">#  You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="s0">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0">#  See the License for the specific language governing permissions and</span>
<span class="s0">#  limitations under the License.</span>

<span class="s2">&quot;&quot;&quot;Optional base classes for libraries and other extensions. 
 
Module contents: 
 
- :class:`DynamicLibrary` for libraries using the `dynamic library API`__. 
- :class:`HybridLibrary` for libraries using the `hybrid library API`__. 
- :class:`ListenerV2` for `listener interface version 2`__. 
- :class:`ListenerV3` for `listener interface version 3`__. 
- :class:`Parser` for `custom parsers`__. Also 
  :class:`~robot.running.builder.settings.TestDefaults` used in ``Parser`` 
  type hints can be imported via this module if needed. 
- Type definitions used by the aforementioned classes. 
 
Main benefit of using these base classes is that editors can provide automatic 
completion, documentation and type information. Their usage is not required. 
Notice also that libraries typically use the static API and do not need any 
base class. 
 
.. note:: These classes are not exposed via the top level :mod:`robot.api` 
          package and need to imported via :mod:`robot.api.interfaces`. 
 
This module is new in Robot Framework 6.1. 
 
__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#dynamic-library-api 
__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#hybrid-library-api 
__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-2 
__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-3 
__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#parser-interface 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABC</span><span class="s4">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">pathlib </span><span class="s3">import </span><span class="s1">Path</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Mapping</span><span class="s4">, </span><span class="s1">Sequence</span><span class="s4">, </span><span class="s1">TypedDict</span><span class="s4">, </span><span class="s1">Union</span>

<span class="s3">if </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">version_info </span><span class="s4">&gt;= (</span><span class="s5">3</span><span class="s4">, </span><span class="s5">10</span><span class="s4">):</span>
    <span class="s3">from </span><span class="s1">types </span><span class="s3">import </span><span class="s1">UnionType</span>
<span class="s3">else</span><span class="s4">:</span>
    <span class="s1">UnionType </span><span class="s4">= </span><span class="s1">type</span>

<span class="s3">from </span><span class="s1">robot </span><span class="s3">import </span><span class="s1">result</span><span class="s4">, </span><span class="s1">running</span>
<span class="s3">from </span><span class="s1">robot</span><span class="s4">.</span><span class="s1">running </span><span class="s3">import </span><span class="s1">TestDefaults</span><span class="s4">, </span><span class="s1">TestSuite</span>

<span class="s0"># Type aliases used by DynamicLibrary and HybridLibrary.</span>
<span class="s1">Name </span><span class="s4">= </span><span class="s1">str</span>
<span class="s1">PositArgs </span><span class="s4">= </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
<span class="s1">NamedArgs </span><span class="s4">= </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
<span class="s1">Documentation </span><span class="s4">= </span><span class="s1">str</span>
<span class="s1">Arguments </span><span class="s4">= </span><span class="s1">Sequence</span><span class="s4">[</span>
    <span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">str</span><span class="s4">,                   </span><span class="s0"># Name with possible default like `&quot;arg&quot;` or `&quot;arg=1&quot;`.</span>
        <span class="s6">&quot;tuple[str]&quot;</span><span class="s4">,          </span><span class="s0"># Name without a default like `(&quot;arg&quot;,)`.</span>
        <span class="s6">&quot;tuple[str, Any]&quot;      </span><span class="s0"># Name and default like `(&quot;arg&quot;, 1)`.</span>
    <span class="s4">]</span>
<span class="s4">]  </span><span class="s0"># fmt: skip</span>
<span class="s1">TypeHint </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">type</span><span class="s4">,                      </span><span class="s0"># Actual type.</span>
    <span class="s1">str</span><span class="s4">,                       </span><span class="s0"># Type name or alias.</span>
    <span class="s1">UnionType</span><span class="s4">,                 </span><span class="s0"># Union syntax (e.g. `int | float`).</span>
    <span class="s6">&quot;tuple[TypeHint, ...]&quot;     </span><span class="s0"># Tuple of type hints. Behaves like a union.</span>
<span class="s4">]  </span><span class="s0"># fmt: skip</span>
<span class="s1">TypeHints </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">TypeHint</span><span class="s4">],    </span><span class="s0"># Types by name.</span>
    <span class="s1">Sequence</span><span class="s4">[</span><span class="s6">&quot;TypeHint|None&quot;</span><span class="s4">]  </span><span class="s0"># Types by position.</span>
<span class="s4">]  </span><span class="s0"># fmt: skip</span>
<span class="s1">Tags </span><span class="s4">= </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
<span class="s1">Source </span><span class="s4">= </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">DynamicLibrary</span><span class="s4">(</span><span class="s1">ABC</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Optional base class for libraries using the dynamic library API. 
 
    The dynamic library API makes it possible to dynamically specify 
    what keywords a library implements and run them by using 
    :meth:`get_keyword_names` and :meth:`run_keyword` methods, respectively. 
    In addition to that it has various optional methods for returning more 
    information about the implemented keywords to Robot Framework. 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">get_keyword_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Name</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return names of the keywords this library implements. 
 
        :return: Keyword names as a list of strings. 
 
        ``name`` passed to other methods is always in the same format as 
        returned by this method. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">run_keyword</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">args</span><span class="s4">: </span><span class="s1">PositArgs</span><span class="s4">, </span><span class="s1">named</span><span class="s4">: </span><span class="s1">NamedArgs</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Execute the specified keyword using the given arguments. 
 
        :param name: Keyword name as a string. 
        :param args: Positional arguments as a list. 
        :param named: Named arguments as a dictionary. 
        :raises: Reporting FAIL or SKIP status. 
        :return: Keyword's return value. 
 
        Reporting status, logging, returning values, etc. is handled the same 
        way as with the normal static library API. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">get_keyword_documentation</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s6">&quot;Documentation|None&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method to return keyword documentation. 
 
        The first logical line of keyword documentation is shown in 
        the execution log under the executed keyword. The whole 
        documentation is shown in documentation generated by Libdoc. 
 
        :param name: Keyword name as a string. 
        :return: Documentation as a string oras ``None`` if there is no 
            documentation. 
 
        This method is also used to get the overall library documentation as 
        well as documentation related to importing the library. They are 
        got by calling this method with special names ``__intro__`` and 
        ``__init__``, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_keyword_arguments</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s6">&quot;Arguments|None&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method to return keyword's argument specification. 
 
        Returned information is used during execution for argument validation. 
        In addition to that, arguments are shown in documentation generated 
        by Libdoc. 
 
        :param name: Keyword name as a string. 
        :return: Argument specification using format explained below. 
 
        Argument specification defines what arguments the keyword accepts. 
        Returning ``None`` means that the keywords accepts any arguments. 
        Accepted arguments are returned as a list using these rules: 
 
        - Normal arguments are specified as a list of strings like 
          ``['arg1', 'arg2']``. An empty list denotes that the keyword 
          accepts no arguments. 
        - Varargs must have a ``*`` prefix like ``['*numbers']``. There can 
          be only one varargs, and it must follow normal arguments. 
        - Arguments after varargs like ``['*items', 'arg']`` are considered 
          named-only arguments. 
        - If keyword does not accept varargs, a lone ``*`` can be used 
          a separator between normal and named-only arguments like 
          ``['normal', '*', 'named']``. 
        - Kwargs must have a ``**``  prefix like ``['**config']``. There can 
          be only one kwargs, and it must be last. 
 
        Both normal arguments and named-only arguments can have default values: 
 
        - Default values can be embedded to argument names so that they are 
          separated with the equal sign like ``name=default``. In this case 
          the default value type is always a string. 
        - Alternatively arguments and their default values can be represented 
          as two-tuples like ``('name', 'default')``. This allows non-string 
          default values and automatic argument conversion based on them. 
        - Arguments without default values can also be specified as tuples 
          containing just the name like ``('name',)``. 
        - With normal arguments, arguments with default values must follow 
          arguments without them. There is no such restriction with named-only 
          arguments. 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_keyword_types</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s6">&quot;TypeHints|None&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method to return keyword's type specification. 
 
        Type information is used for automatic argument conversion during 
        execution. It is also shown in documentation generated by Libdoc. 
 
        :param name: Keyword name as a string. 
        :return: Type specification as a dictionary, as a list, or as ``None`` 
            if type information is not known. 
 
        Type information can be mapped to arguments returned by 
        :meth:`get_keyword_names` either by names using a dictionary or 
        by position using a list. For example, if a keyword has argument 
        specification ``['arg', 'second']``, it would be possible to return 
        types both like ``{'arg': str, 'second': int}`` and ``[str, int]``. 
 
        Regardless of the approach that is used, it is not necessarily to 
        specify types for all arguments. When using a dictionary, some 
        arguments can be omitted altogether. When using a list, it is possible 
        to use ``None`` to mark that a certain argument does not have type 
        information and arguments at the end can be omitted altogether. 
 
        If is possible to specify that an argument has multiple possible types 
        by using unions like ``{'arg': Union[int, float]}`` or tuples like 
        ``{'arg': (int, float)}``. 
 
        In addition to specifying types using classes, it is also possible 
        to use names or aliases like ``{'a': 'int', 'b': 'boolean'}``. 
        For an up-to-date list of supported types, names and aliases see 
        the User Guide. 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_keyword_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s6">&quot;Tags|None&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method to return keyword's tags. 
 
        Tags are shown in the execution log and in documentation generated by 
        Libdoc. Tags can also be used with various command line options. 
 
        :param name: Keyword name as a string. 
        :return: Tags as a list of strings or ``None`` if there are no tags. 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_keyword_source</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s6">&quot;Source|None&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method to return keyword's source path and line number. 
 
        Source information is used by IDEs to provide navigation from 
        keyword usage to implementation. 
 
        :param name: Keyword name as a string. 
        :return: Source as a string in format ``path:lineno`` or ``None`` 
            if source is not known. 
 
        The general format to return the source is ``path:lineno`` like 
        ``/example/Lib.py:42``. If the line number is not known, it is 
        possible to return only the path. If the keyword is in the same 
        file as the main library class, the path can be omitted and only 
        the line number returned like ``:42``. 
 
        The source information of the library itself is got automatically from 
        the imported library class. The library source path is used with all 
        keywords that do not return their own path. 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">HybridLibrary</span><span class="s4">(</span><span class="s1">ABC</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Optional base class for libraries using the hybrid library API. 
 
    Hybrid library API makes it easy to specify what keywords a library 
    implements by using the :meth:`get_keyword_names` method. After getting 
    keyword names, Robot Framework uses ``getattr`` to get the actual keyword 
    methods exactly like it does when using the normal static library API. 
    Keyword name, arguments, documentation, tags, and so on are got directly 
    from the keyword method. 
 
    It is possible to implement keywords also outside the main library class. 
    In such cases the library needs to have a ``__getattr__`` method that 
    returns desired keyword methods. 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">get_keyword_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Name</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return names of the implemented keyword methods as a list or strings. 
 
        Returned names must match names of the implemented keyword methods. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">class </span><span class="s1">StartSuiteAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``start_suite`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">id</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">longname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">doc</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">metadata</span><span class="s4">: </span><span class="s6">&quot;dict[str, str]&quot;</span>
    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">suites</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">tests</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">totaltests</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">starttime</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">EndSuiteAttributes</span><span class="s4">(</span><span class="s1">StartSuiteAttributes</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``end_suite`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">endtime</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">elapsedtime</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">status</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">statistics</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">message</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">StartTestAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``start_test`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">id</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">longname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">originalname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">doc</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">tags</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">template</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">lineno</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">starttime</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">EndTestAttributes</span><span class="s4">(</span><span class="s1">StartTestAttributes</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``end_test`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">endtime</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">elapedtime</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">status</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">message</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">OptionalKeywordAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">, </span><span class="s1">total</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Extra attributes passed to listener v2 ``start/end_keyword`` methods. 
 
    These attributes are included with control structures. For example, with 
    IF structures attributes include ``condition``. 
    &quot;&quot;&quot;</span>

    <span class="s0"># FOR / ITERATION with FOR</span>
    <span class="s1">variables</span><span class="s4">: </span><span class="s6">&quot;list[str]|dict[str, str]&quot;</span>
    <span class="s1">flavor</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">values</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;  </span><span class="s0"># Also RETURN</span>
    <span class="s0"># WHILE and IF</span>
    <span class="s1">condition</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s0"># WHILE</span>
    <span class="s1">limit</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s0"># EXCEPT</span>
    <span class="s1">patterns</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">pattern_type</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">variable</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">StartKeywordAttributes</span><span class="s4">(</span><span class="s1">OptionalKeywordAttributes</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``start_keyword`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">type</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">kwname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">libname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">doc</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">args</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">assign</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">tags</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">lineno</span><span class="s4">: </span><span class="s6">&quot;int|None&quot;</span>
    <span class="s1">status</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">starttime</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">EndKeywordAttributes</span><span class="s4">(</span><span class="s1">StartKeywordAttributes</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``end_keyword`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">endtime</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">elapsedtime</span><span class="s4">: </span><span class="s1">int</span>


<span class="s3">class </span><span class="s1">MessageAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``log_message`` and ``messages`` methods. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">message</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">level</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">timestamp</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">html</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">LibraryAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``library_import`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">args</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">originalname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">importer</span><span class="s4">: </span><span class="s6">&quot;str|None&quot;</span>


<span class="s3">class </span><span class="s1">ResourceAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``resource_import`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">importer</span><span class="s4">: </span><span class="s6">&quot;str|None&quot;</span>


<span class="s3">class </span><span class="s1">VariablesAttributes</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Attributes passed to listener v2 ``variables_import`` method. 
 
    See the User Guide for more information. 
    &quot;&quot;&quot;</span>

    <span class="s1">args</span><span class="s4">: </span><span class="s6">&quot;list[str]&quot;</span>
    <span class="s1">source</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">importer</span><span class="s4">: </span><span class="s6">&quot;str|None&quot;</span>


<span class="s3">class </span><span class="s1">ListenerV2</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Optional base class for listeners using the listener API version 2.&quot;&quot;&quot;</span>

    <span class="s1">ROBOT_LISTENER_API_VERSION </span><span class="s4">= </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">start_suite</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">StartSuiteAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a suite starts.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">end_suite</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">EndSuiteAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a suite end.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">start_test</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">StartTestAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a test or task starts.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">end_test</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">EndTestAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a test or task ends.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">start_keyword</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">StartKeywordAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a keyword or a control structure like IF starts. 
 
        The type of the started item is in ``attributes['type']``. Control 
        structures can contain extra attributes that are only relevant to them. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">end_keyword</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">EndKeywordAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a keyword or a control structure like IF ends. 
 
        The type of the started item is in ``attributes['type']``. Control 
        structures can contain extra attributes that are only relevant to them. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">log_message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">message</span><span class="s4">: </span><span class="s1">MessageAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a normal log message are emitted. 
 
        The messages are typically logged by keywords, but also the framework 
        itself logs some messages. These messages end up to output.xml and 
        log.html. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">message</span><span class="s4">: </span><span class="s1">MessageAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when framework's internal messages are emitted. 
 
        Only logged by the framework itself. These messages end up to the syslog 
        if it is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">library_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">LibraryAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a library has been imported.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">resource_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">ResourceAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a resource file has been imported.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">variables_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">: </span><span class="s1">VariablesAttributes</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a variable file has been imported.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">output_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the output file has been created. 
 
        ``path`` is an absolute path to the output file or 
        a string ``None`` if creating the output file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">log_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the log file has been created. 
 
        ``path`` is an absolute path to the log file. 
        Not called if creating the log file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">report_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the report file has been created. 
 
        ``path`` is an absolute path to the report file. 
        Not called if creating the report file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">xunit_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the xunit compatible output file has been created. 
 
        ``path`` is an absolute path to the xunit file. 
        Only called if creating the xunit file is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">debug_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the debug file has been created. 
 
        ``path`` is an absolute path to the debug file. 
        Only called if creating the debug file is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when the whole execution ends. 
 
        With library listeners called when the library goes out of scope. 
        &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ListenerV3</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Optional base class for listeners using the listener API version 3.&quot;&quot;&quot;</span>

    <span class="s1">ROBOT_LISTENER_API_VERSION </span><span class="s4">= </span><span class="s5">3</span>

    <span class="s3">def </span><span class="s1">start_suite</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TestSuite</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TestSuite</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a suite starts.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">end_suite</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TestSuite</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TestSuite</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a suite ends.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">start_test</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TestCase</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TestCase</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a test or task starts.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">end_test</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TestCase</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TestCase</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a test or tasks ends.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">start_keyword</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a keyword starts by default. 
 
        This method is called, by default, with user keywords, library keywords 
        and when a keyword call is invalid. It is not called, however, if a more 
        specific :meth:`start_user_keyword`, :meth:`start_library_keyword` or 
        :meth:`start_invalid_keyword` method is implemented. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_keyword</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a keyword ends by default. 
 
        This method is called, by default, with user keywords, library keywords 
        and when a keyword call is invalid. It is not called, however, if a more 
        specific :meth:`end_user_keyword`, :meth:`end_library_keyword` or 
        :meth:`end_invalid_keyword` method is implemented. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_user_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">UserKeyword</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a user keyword starts. 
 
        The default implementation calls :meth:`start_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_user_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">UserKeyword</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a user keyword ends. 
 
        The default implementation calls :meth:`end_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_library_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">LibraryKeyword</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a library keyword starts. 
 
        The default implementation calls :meth:`start_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_library_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">LibraryKeyword</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a library keyword ends. 
 
        The default implementation calls :meth:`start_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_invalid_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">KeywordImplementation</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an invalid keyword call starts. 
 
        Keyword may not have been found, there could have been multiple matches, 
        or the keyword call itself could have been invalid. 
 
        The default implementation calls :meth:`start_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_invalid_keyword</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
        <span class="s1">implementation</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">KeywordImplementation</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Keyword</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an invalid keyword call ends. 
 
        Keyword may not have been found, there could have been multiple matches, 
        or the keyword call itself could have been invalid. 
 
        The default implementation calls :meth:`end_keyword`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_keyword</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_for</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">For</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">For</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a FOR loop starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_for</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">For</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">For</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a FOR loop ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_for_iteration</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">ForIteration</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">ForIteration</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a FOR loop iteration starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_for_iteration</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">ForIteration</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">ForIteration</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a FOR loop iteration ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_while</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">While</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">While</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a WHILE loop starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_while</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">While</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">While</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a WHILE loop ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_while_iteration</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">WhileIteration</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">WhileIteration</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a WHILE loop iteration starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_while_iteration</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">WhileIteration</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">WhileIteration</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a WHILE loop iteration ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Group</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Group</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a GROUP starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.2. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Group</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Group</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a GROUP ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.2. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_if</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">If</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">If</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an IF/ELSE structure starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_if</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">If</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">If</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an IF/ELSE structure ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_if_branch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">IfBranch</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">IfBranch</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an individual IF/ELSE branch starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_if_branch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">IfBranch</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">IfBranch</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an individual IF/ELSE branch ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_try</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Try</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Try</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a TRY/EXCEPT structure starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_try</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Try</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Try</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a TRY/EXCEPT structure ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_try_branch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TryBranch</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TryBranch</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an individual TRY/EXCEPT branch starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_try_branch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TryBranch</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">TryBranch</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when an individual TRY/EXCEPT branch ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_var</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Var</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Var</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when VAR starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_var</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Var</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Var</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when VAR ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_break</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Break</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Break</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when BREAK starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_break</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Break</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Break</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when BREAK ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_continue</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Continue</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Continue</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when CONTINUE starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_continue</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Continue</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Continue</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when CONTINUE ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_return</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Return</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Return</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when RETURN starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_return</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Return</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Return</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when RETURN ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_error</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Error</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Error</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when encountered invalid syntax starts. 
 
        The default implementation calls :meth:`start_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">end_error</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Error</span><span class="s4">, </span><span class="s1">result</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Error</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when encountered invalid syntax ends. 
 
        The default implementation calls :meth:`end_body_item`. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">start_body_item</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called by default when a keyword or a control structure starts. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">end_body_item</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">result</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called by default when a keyword or a control structure ends. 
 
        New in Robot Framework 7.0. 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">log_message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">message</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Message</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when a normal log message are emitted. 
 
        The messages are typically logged by keywords, but also the framework 
        itself logs some messages. These messages end up to output.xml and 
        log.html. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">message</span><span class="s4">: </span><span class="s1">result</span><span class="s4">.</span><span class="s1">Message</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when framework's internal messages are emitted. 
 
        Only logged by the framework itself. These messages end up to the syslog 
        if it is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">library_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">library</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">TestLibrary</span><span class="s4">, </span><span class="s1">importer</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Import</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a library has been imported. 
 
        ``library`` represents the imported library. It can be inspected and 
        also modified. ``importer`` contains information about the location where 
        the library was imported. 
 
        New in Robot Framework 7.1. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">resource_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">resource</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">ResourceFile</span><span class="s4">, </span><span class="s1">importer</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Import</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a resource file has been imported. 
 
        ``resource`` represents the imported resource file. It can be inspected and 
        also modified. ``importer`` contains information about the location where 
        the resource was imported. 
 
        New in Robot Framework 7.1. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">variables_import</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">attrs</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">, </span><span class="s1">importer</span><span class="s4">: </span><span class="s1">running</span><span class="s4">.</span><span class="s1">Import</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after a variable file has been imported. 
 
        ``attrs`` contains information about the imported variable file. It can be 
        inspected, but modifications to it have no effect. `importer`` contains 
        information about the location where the variable file was imported. 
 
        New in Robot Framework 7.1. This method will be changed in the future 
        so that the ``attrs`` dictionary is replaced with an object representing 
        the imported variable file. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">output_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s6">&quot;Path|None&quot;</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the output file has been created. 
 
        ``path`` is an absolute path to the output file or 
        ``None`` if creating the output file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">log_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the log file has been created. 
 
        ``path`` is an absolute path to the log file. 
        Not called if creating the log file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">report_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the report file has been created. 
 
        ``path`` is an absolute path to the report file. 
        Not called if creating the report file is disabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">xunit_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the xunit compatible output file has been created. 
 
        ``path`` is an absolute path to the xunit file. 
        Only called if creating the xunit file is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">debug_file</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called after the debug file has been created. 
 
        ``path`` is an absolute path to the debug file. 
        Only called if creating the debug file is enabled. 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Called when the whole execution ends. 
 
        With library listeners called when the library goes out of scope. 
        &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Parser</span><span class="s4">(</span><span class="s1">ABC</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Optional base class for custom parsers. 
 
    Parsers do not need to explicitly extend this class and in simple cases 
    it is possible to implement them as modules. Regardless how a parser is 
    implemented, it must have :attr:`extension` attribute and :meth:`parse` 
    method. The :meth:`parse_init` method is optional and only needed if 
    a parser supports parsing suite initialization files. 
 
    The mandatory :attr:`extension` attribute specifies what file extension or 
    extensions a parser supports. It can be set either as a class or instance 
    attribute, and it can be either a string or a sequence of strings. The 
    attribute can also be named ``EXTENSION``, which typically works better 
    when a parser is implemented as a module. 
 
    Example:: 
 
        from pathlib import Path 
        from robot.api import TestSuite 
        from robot.api.interfaces import Parser, TestDefaults 
 
 
        class ExampleParser(Parser): 
            extension = '.example' 
 
            def parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite: 
                suite = TestSuite(TestSuite.name_from_source(source), source=source) 
                # parse the source file and add tests to the created suite 
                return suite 
 
    The support for custom parsers is new in Robot Framework 6.1. 
    &quot;&quot;&quot;</span>

    <span class="s1">extension</span><span class="s4">: </span><span class="s6">&quot;str|Sequence[str]&quot;</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">parse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">source</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">, </span><span class="s1">defaults</span><span class="s4">: </span><span class="s1">TestDefaults</span><span class="s4">) </span><span class="s1">-&gt; TestSuite</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Mandatory method for parsing suite files. 
 
        :param source: Path to the file to parse. 
        :param defaults: Default values set for test in init files. 
 
        The ``defaults`` argument is optional. It is possible to implement 
        this method also so that it accepts only ``source``. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">parse_init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">source</span><span class="s4">: </span><span class="s1">Path</span><span class="s4">, </span><span class="s1">defaults</span><span class="s4">: </span><span class="s1">TestDefaults</span><span class="s4">) </span><span class="s1">-&gt; TestSuite</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Optional method for parsing suite initialization files. 
 
        :param source: Path to the file to parse. 
        :param defaults: Default values to used with tests in child suites. 
 
        The ``defaults`` argument is optional. It is possible to implement 
        this method also so that it accepts only ``source``. 
 
        If this method is not implemented, possible initialization files cause 
        an error. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>
</pre>
</body>
</html>