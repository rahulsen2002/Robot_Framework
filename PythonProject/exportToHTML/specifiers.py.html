<html>
<head>
<title>specifiers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
specifiers.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is dual licensed under the terms of the Apache License, Version</span>
<span class="s0"># 2.0, and the BSD License. See the LICENSE file in the root of this repository</span>
<span class="s0"># for complete details.</span>
<span class="s2">&quot;&quot;&quot; 
.. testsetup:: 
 
    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier 
    from packaging.version import Version 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">abc</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">, </span><span class="s1">Iterator</span><span class="s4">, </span><span class="s1">TypeVar</span><span class="s4">, </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">.</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">canonicalize_version</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">version </span><span class="s3">import </span><span class="s1">Version</span>

<span class="s1">UnparsedVersion </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Version</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]</span>
<span class="s1">UnparsedVersionVar </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;UnparsedVersionVar&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">UnparsedVersion</span><span class="s4">)</span>
<span class="s1">CallableOperator </span><span class="s4">= </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Version</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], </span><span class="s1">bool</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_coerce_version</span><span class="s4">(</span><span class="s1">version</span><span class="s4">: </span><span class="s1">UnparsedVersion</span><span class="s4">) </span><span class="s1">-&gt; Version</span><span class="s4">:</span>
    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">version</span><span class="s4">, </span><span class="s1">Version</span><span class="s4">):</span>
        <span class="s1">version </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">version</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">version</span>


<span class="s3">class </span><span class="s1">InvalidSpecifier</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Raised when attempting to create a :class:`Specifier` with a specifier 
    string that is invalid. 
 
    &gt;&gt;&gt; Specifier(&quot;lolwat&quot;) 
    Traceback (most recent call last): 
        ... 
    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat' 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">BaseSpecifier</span><span class="s4">(</span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">ABCMeta</span><span class="s4">):</span>
    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the str representation of this Specifier-like object. This 
        should be representative of the Specifier itself. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a hash value for this Specifier-like object. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a boolean representing whether or not the two Specifier-like 
        objects are equal. 
 
        :param other: The other object to check against. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool </span><span class="s4">| </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Whether or not pre-releases as a whole are allowed. 
 
        This can be set to either ``True`` or ``False`` to explicitly enable or disable 
        prereleases or it can be set to ``None`` (the default) to use default semantics. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">prereleases</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Setter for :attr:`prereleases`. 
 
        :param value: The value to set. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">contains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">item</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Determines if the given item is contained within this specifier. 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abc</span><span class="s4">.</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">iterable</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">], </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Takes an iterable of items and filters them so that only items which 
        are contained within this specifier are allowed in it. 
        &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Specifier</span><span class="s4">(</span><span class="s1">BaseSpecifier</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;This class abstracts handling of version specifiers. 
 
    .. tip:: 
 
        It is generally not required to instantiate this manually. You should instead 
        prefer to work with :class:`SpecifierSet` instead, which can parse 
        comma-separated version specifiers (which is what package metadata contains). 
    &quot;&quot;&quot;</span>

    <span class="s1">_operator_regex_str </span><span class="s4">= </span><span class="s5">r&quot;&quot;&quot; 
        (?P&lt;operator&gt;(~=|==|!=|&lt;=|&gt;=|&lt;|&gt;|===)) 
        &quot;&quot;&quot;</span>
    <span class="s1">_version_regex_str </span><span class="s4">= </span><span class="s5">r&quot;&quot;&quot; 
        (?P&lt;version&gt; 
            (?: 
                # The identity operators allow for an escape hatch that will 
                # do an exact string match of the version you wish to install. 
                # This will not be parsed by PEP 440 and we cannot determine 
                # any semantic meaning from it. This operator is discouraged 
                # but included entirely as an escape hatch. 
                (?&lt;====)  # Only match for the identity operator 
                \s* 
                [^\s;)]*  # The arbitrary version can be just about anything, 
                          # we match everything except for whitespace, a 
                          # semi-colon for marker support, and a closing paren 
                          # since versions can be enclosed in them. 
            ) 
            | 
            (?: 
                # The (non)equality operators allow for wild card and local 
                # versions to be specified so we have to define these two 
                # operators separately to enable that. 
                (?&lt;===|!=)            # Only match for equals and not equals 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)*   # release 
 
                # You cannot use a wild card and a pre-release, post-release, a dev or 
                # local version together so group them with a | and make them optional. 
                (?: 
                    \.\*  # Wild card syntax of .* 
                    | 
                    (?:                                  # pre release 
                        [-_\.]? 
                        (alpha|beta|preview|pre|a|b|c|rc) 
                        [-_\.]? 
                        [0-9]* 
                    )? 
                    (?:                                  # post release 
                        (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                    )? 
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release 
                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local 
                )? 
            ) 
            | 
            (?: 
                # The compatible operator requires at least two digits in the 
                # release segment. 
                (?&lt;=~=)               # Only match for the compatible operator 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *) 
                (?:                   # pre release 
                    [-_\.]? 
                    (alpha|beta|preview|pre|a|b|c|rc) 
                    [-_\.]? 
                    [0-9]* 
                )? 
                (?:                                   # post release 
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                )? 
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release 
            ) 
            | 
            (?: 
                # All other operators only allow a sub set of what the 
                # (non)equality operators do. Specifically they do not allow 
                # local versions to be specified nor do they allow the prefix 
                # matching wild cards. 
                (?&lt;!==|!=|~=)         # We have special cases for these 
                                      # operators so we want to make sure they 
                                      # don't match here. 
 
                \s* 
                v? 
                (?:[0-9]+!)?          # epoch 
                [0-9]+(?:\.[0-9]+)*   # release 
                (?:                   # pre release 
                    [-_\.]? 
                    (alpha|beta|preview|pre|a|b|c|rc) 
                    [-_\.]? 
                    [0-9]* 
                )? 
                (?:                                   # post release 
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*) 
                )? 
                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release 
            ) 
        ) 
        &quot;&quot;&quot;</span>

    <span class="s1">_regex </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s5">r&quot;^\s*&quot; </span><span class="s4">+ </span><span class="s1">_operator_regex_str </span><span class="s4">+ </span><span class="s1">_version_regex_str </span><span class="s4">+ </span><span class="s5">r&quot;\s*$&quot;</span><span class="s4">,</span>
        <span class="s1">re</span><span class="s4">.</span><span class="s1">VERBOSE </span><span class="s4">| </span><span class="s1">re</span><span class="s4">.</span><span class="s1">IGNORECASE</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s1">_operators </span><span class="s4">= {</span>
        <span class="s5">&quot;~=&quot;</span><span class="s4">: </span><span class="s5">&quot;compatible&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;==&quot;</span><span class="s4">: </span><span class="s5">&quot;equal&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;!=&quot;</span><span class="s4">: </span><span class="s5">&quot;not_equal&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;&lt;=&quot;</span><span class="s4">: </span><span class="s5">&quot;less_than_equal&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;&gt;=&quot;</span><span class="s4">: </span><span class="s5">&quot;greater_than_equal&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;&lt;&quot;</span><span class="s4">: </span><span class="s5">&quot;less_than&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;&gt;&quot;</span><span class="s4">: </span><span class="s5">&quot;greater_than&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;===&quot;</span><span class="s4">: </span><span class="s5">&quot;arbitrary&quot;</span><span class="s4">,</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;&quot;</span><span class="s4">, </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Initialize a Specifier instance. 
 
        :param spec: 
            The string representation of a specifier which will be parsed and 
            normalized before use. 
        :param prereleases: 
            This tells the specifier if it should accept prerelease versions if 
            applicable or not. The default of ``None`` will autodetect it from the 
            given specifiers. 
        :raises InvalidSpecifier: 
            If the given specifier is invalid (i.e. bad syntax). 
        &quot;&quot;&quot;</span>
        <span class="s1">match </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regex</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">match</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">InvalidSpecifier</span><span class="s4">(</span><span class="s5">f&quot;Invalid specifier: </span><span class="s3">{</span><span class="s1">spec</span><span class="s3">!r}</span><span class="s5">&quot;</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">: </span><span class="s1">tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = (</span>
            <span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">(),</span>
            <span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">&quot;version&quot;</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">(),</span>
        <span class="s4">)</span>

        <span class="s0"># Store whether or not this Specifier should accept prereleases</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">prereleases</span>

    <span class="s0"># https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515</span>
    <span class="s4">@</span><span class="s1">property  </span><span class="s0"># type: ignore[override]</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># If there is an explicit prereleases set for this, then we'll just</span>
        <span class="s0"># blindly use that.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases</span>

        <span class="s0"># Look at all of our specifiers and determine if they are inclusive</span>
        <span class="s0"># operators, and if they are if they are including an explicit</span>
        <span class="s0"># prerelease.</span>
        <span class="s1">operator</span><span class="s4">, </span><span class="s1">version </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span>
        <span class="s3">if </span><span class="s1">operator </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;==&quot;</span><span class="s4">, </span><span class="s5">&quot;&gt;=&quot;</span><span class="s4">, </span><span class="s5">&quot;&lt;=&quot;</span><span class="s4">, </span><span class="s5">&quot;~=&quot;</span><span class="s4">, </span><span class="s5">&quot;===&quot;</span><span class="s4">, </span><span class="s5">&quot;&gt;&quot;</span><span class="s4">, </span><span class="s5">&quot;&lt;&quot;</span><span class="s4">]:</span>
            <span class="s0"># The == specifier can include a trailing .*, if it does we</span>
            <span class="s0"># want to remove before parsing.</span>
            <span class="s3">if </span><span class="s1">operator </span><span class="s4">== </span><span class="s5">&quot;==&quot; </span><span class="s3">and </span><span class="s1">version</span><span class="s4">.</span><span class="s1">endswith</span><span class="s4">(</span><span class="s5">&quot;.*&quot;</span><span class="s4">):</span>
                <span class="s1">version </span><span class="s4">= </span><span class="s1">version</span><span class="s4">[:-</span><span class="s6">2</span><span class="s4">]</span>

            <span class="s0"># Parse the version, and if it is a pre-release than this</span>
            <span class="s0"># specifier allows pre-releases.</span>
            <span class="s3">if </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">version</span><span class="s4">).</span><span class="s1">is_prerelease</span><span class="s4">:</span>
                <span class="s3">return True</span>

        <span class="s3">return False</span>

    <span class="s4">@</span><span class="s1">prereleases</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">value</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">operator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;The operator of this specifier. 
 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;).operator 
        '==' 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">version</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;The version of this specifier. 
 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;).version 
        '1.2.3' 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A representation of the Specifier that shows all internal state. 
 
        &gt;&gt;&gt; Specifier('&gt;=1.0.0') 
        &lt;Specifier('&gt;=1.0.0')&gt; 
        &gt;&gt;&gt; Specifier('&gt;=1.0.0', prereleases=False) 
        &lt;Specifier('&gt;=1.0.0', prereleases=False)&gt; 
        &gt;&gt;&gt; Specifier('&gt;=1.0.0', prereleases=True) 
        &lt;Specifier('&gt;=1.0.0', prereleases=True)&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">pre </span><span class="s4">= (</span>
            <span class="s5">f&quot;, prereleases=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span><span class="s3">!r}</span><span class="s5">&quot;</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s5">&quot;&quot;</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s5">f&quot;&lt;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">(</span><span class="s3">{</span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span><span class="s3">!r}{</span><span class="s1">pre</span><span class="s3">}</span><span class="s5">)&gt;&quot;</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A string representation of the Specifier that can be round-tripped. 
 
        &gt;&gt;&gt; str(Specifier('&gt;=1.0.0')) 
        '&gt;=1.0.0' 
        &gt;&gt;&gt; str(Specifier('&gt;=1.0.0', prereleases=False)) 
        '&gt;=1.0.0' 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">&quot;{}{}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_canonical_spec</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s1">canonical_version </span><span class="s4">= </span><span class="s1">canonicalize_version</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">strip_trailing_zero</span><span class="s4">=(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s5">&quot;~=&quot;</span><span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">canonical_version</span>

    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_canonical_spec</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Whether or not the two Specifier-like objects are equal. 
 
        :param other: The other object to check against. 
 
        The value of :attr:`prereleases` is ignored. 
 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;== 1.2.3.0&quot;) 
        True 
        &gt;&gt;&gt; (Specifier(&quot;==1.2.3&quot;, prereleases=False) == 
        ...  Specifier(&quot;==1.2.3&quot;, prereleases=True)) 
        True 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == &quot;==1.2.3&quot; 
        True 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;==1.2.4&quot;) 
        False 
        &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;~=1.2.3&quot;) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">other </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">))</span>
            <span class="s3">except </span><span class="s1">InvalidSpecifier</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_canonical_spec </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_canonical_spec</span>

    <span class="s3">def </span><span class="s1">_get_operator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; CallableOperator</span><span class="s4">:</span>
        <span class="s1">operator_callable</span><span class="s4">: </span><span class="s1">CallableOperator </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s5">f&quot;_compare_</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operators</span><span class="s4">[</span><span class="s1">op</span><span class="s4">]</span><span class="s3">}</span><span class="s5">&quot;</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">operator_callable</span>

    <span class="s3">def </span><span class="s1">_compare_compatible</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># Compatible releases have an equivalent combination of &gt;= and ==. That</span>
        <span class="s0"># is that ~=2.2 is equivalent to &gt;=2.2,==2.*. This allows us to</span>
        <span class="s0"># implement this in terms of the other specifiers instead of</span>
        <span class="s0"># implementing it ourselves. The only thing we need to do is construct</span>
        <span class="s0"># the other specifiers.</span>

        <span class="s0"># We want everything but the last item in the version, but we want to</span>
        <span class="s0"># ignore suffix segments.</span>
        <span class="s1">prefix </span><span class="s4">= </span><span class="s1">_version_join</span><span class="s4">(</span>
            <span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s1">_is_not_suffix</span><span class="s4">, </span><span class="s1">_version_split</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)))[:-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s4">)</span>

        <span class="s0"># Add the prefix notation to the end of our string</span>
        <span class="s1">prefix </span><span class="s4">+= </span><span class="s5">&quot;.*&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_operator</span><span class="s4">(</span><span class="s5">&quot;&gt;=&quot;</span><span class="s4">)(</span><span class="s1">prospective</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_operator</span><span class="s4">(</span><span class="s5">&quot;==&quot;</span><span class="s4">)(</span>
            <span class="s1">prospective</span><span class="s4">, </span><span class="s1">prefix</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compare_equal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># We need special logic to handle prefix matching</span>
        <span class="s3">if </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">endswith</span><span class="s4">(</span><span class="s5">&quot;.*&quot;</span><span class="s4">):</span>
            <span class="s0"># In the case of prefix matching we want to ignore local segment.</span>
            <span class="s1">normalized_prospective </span><span class="s4">= </span><span class="s1">canonicalize_version</span><span class="s4">(</span>
                <span class="s1">prospective</span><span class="s4">.</span><span class="s1">public</span><span class="s4">, </span><span class="s1">strip_trailing_zero</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
            <span class="s0"># Get the normalized version string ignoring the trailing .*</span>
            <span class="s1">normalized_spec </span><span class="s4">= </span><span class="s1">canonicalize_version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[:-</span><span class="s6">2</span><span class="s4">], </span><span class="s1">strip_trailing_zero</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s0"># Split the spec out by bangs and dots, and pretend that there is</span>
            <span class="s0"># an implicit dot in between a release segment and a pre-release segment.</span>
            <span class="s1">split_spec </span><span class="s4">= </span><span class="s1">_version_split</span><span class="s4">(</span><span class="s1">normalized_spec</span><span class="s4">)</span>

            <span class="s0"># Split the prospective version out by bangs and dots, and pretend</span>
            <span class="s0"># that there is an implicit dot in between a release segment and</span>
            <span class="s0"># a pre-release segment.</span>
            <span class="s1">split_prospective </span><span class="s4">= </span><span class="s1">_version_split</span><span class="s4">(</span><span class="s1">normalized_prospective</span><span class="s4">)</span>

            <span class="s0"># 0-pad the prospective version before shortening it to get the correct</span>
            <span class="s0"># shortened version.</span>
            <span class="s1">padded_prospective</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_pad_version</span><span class="s4">(</span><span class="s1">split_prospective</span><span class="s4">, </span><span class="s1">split_spec</span><span class="s4">)</span>

            <span class="s0"># Shorten the prospective version to be the same length as the spec</span>
            <span class="s0"># so that we can determine if the specifier is a prefix of the</span>
            <span class="s0"># prospective version or not.</span>
            <span class="s1">shortened_prospective </span><span class="s4">= </span><span class="s1">padded_prospective</span><span class="s4">[: </span><span class="s1">len</span><span class="s4">(</span><span class="s1">split_spec</span><span class="s4">)]</span>

            <span class="s3">return </span><span class="s1">shortened_prospective </span><span class="s4">== </span><span class="s1">split_spec</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># Convert our spec string into a Version</span>
            <span class="s1">spec_version </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)</span>

            <span class="s0"># If the specifier does not have a local segment, then we want to</span>
            <span class="s0"># act as if the prospective version also does not have a local</span>
            <span class="s0"># segment.</span>
            <span class="s3">if not </span><span class="s1">spec_version</span><span class="s4">.</span><span class="s1">local</span><span class="s4">:</span>
                <span class="s1">prospective </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">public</span><span class="s4">)</span>

            <span class="s3">return </span><span class="s1">prospective </span><span class="s4">== </span><span class="s1">spec_version</span>

    <span class="s3">def </span><span class="s1">_compare_not_equal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compare_equal</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compare_less_than_equal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># NB: Local version identifiers are NOT permitted in the version</span>
        <span class="s0"># specifier, so local version labels can be universally removed from</span>
        <span class="s0"># the prospective version.</span>
        <span class="s3">return </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">public</span><span class="s4">) &lt;= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compare_greater_than_equal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># NB: Local version identifiers are NOT permitted in the version</span>
        <span class="s0"># specifier, so local version labels can be universally removed from</span>
        <span class="s0"># the prospective version.</span>
        <span class="s3">return </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">public</span><span class="s4">) &gt;= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compare_less_than</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec_str</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># Convert our spec to a Version instance, since we'll want to work with</span>
        <span class="s0"># it as a version.</span>
        <span class="s1">spec </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec_str</span><span class="s4">)</span>

        <span class="s0"># Check to see if the prospective version is less than the spec</span>
        <span class="s0"># version. If it's not we can short circuit and just return False now</span>
        <span class="s0"># instead of doing extra unneeded work.</span>
        <span class="s3">if not </span><span class="s1">prospective </span><span class="s4">&lt; </span><span class="s1">spec</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s0"># This special case is here so that, unless the specifier itself</span>
        <span class="s0"># includes is a pre-release version, that we do not accept pre-release</span>
        <span class="s0"># versions for the version mentioned in the specifier (e.g. &lt;3.1 should</span>
        <span class="s0"># not match 3.1.dev0, but should match 3.0.dev0).</span>
        <span class="s3">if not </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">is_prerelease </span><span class="s3">and </span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">is_prerelease</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">) == </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">):</span>
                <span class="s3">return False</span>

        <span class="s0"># If we've gotten to here, it means that prospective version is both</span>
        <span class="s0"># less than the spec version *and* it's not a pre-release of the same</span>
        <span class="s0"># version in the spec.</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_compare_greater_than</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec_str</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0"># Convert our spec to a Version instance, since we'll want to work with</span>
        <span class="s0"># it as a version.</span>
        <span class="s1">spec </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec_str</span><span class="s4">)</span>

        <span class="s0"># Check to see if the prospective version is greater than the spec</span>
        <span class="s0"># version. If it's not we can short circuit and just return False now</span>
        <span class="s0"># instead of doing extra unneeded work.</span>
        <span class="s3">if not </span><span class="s1">prospective </span><span class="s4">&gt; </span><span class="s1">spec</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s0"># This special case is here so that, unless the specifier itself</span>
        <span class="s0"># includes is a post-release version, that we do not accept</span>
        <span class="s0"># post-release versions for the version mentioned in the specifier</span>
        <span class="s0"># (e.g. &gt;3.1 should not match 3.0.post0, but should match 3.2.post0).</span>
        <span class="s3">if not </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">is_postrelease </span><span class="s3">and </span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">is_postrelease</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">) == </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">):</span>
                <span class="s3">return False</span>

        <span class="s0"># Ensure that we do not allow a local version of the version mentioned</span>
        <span class="s0"># in the specifier, which is technically greater than, to match.</span>
        <span class="s3">if </span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">local </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">) == </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">):</span>
                <span class="s3">return False</span>

        <span class="s0"># If we've gotten to here, it means that prospective version is both</span>
        <span class="s0"># greater than the spec version *and* it's not a pre-release of the</span>
        <span class="s0"># same version in the spec.</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_compare_arbitrary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">prospective</span><span class="s4">: </span><span class="s1">Version</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">prospective</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">() == </span><span class="s1">str</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__contains__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">item</span><span class="s4">: </span><span class="s1">str </span><span class="s4">| </span><span class="s1">Version</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether or not the item is contained in this specifier. 
 
        :param item: The item to check for. 
 
        This is used for the ``in`` operator and behaves the same as 
        :meth:`contains` with no ``prereleases`` argument passed. 
 
        &gt;&gt;&gt; &quot;1.2.3&quot; in Specifier(&quot;&gt;=1.2.3&quot;) 
        True 
        &gt;&gt;&gt; Version(&quot;1.2.3&quot;) in Specifier(&quot;&gt;=1.2.3&quot;) 
        True 
        &gt;&gt;&gt; &quot;1.0.0&quot; in Specifier(&quot;&gt;=1.2.3&quot;) 
        False 
        &gt;&gt;&gt; &quot;1.3.0a1&quot; in Specifier(&quot;&gt;=1.2.3&quot;) 
        False 
        &gt;&gt;&gt; &quot;1.3.0a1&quot; in Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True) 
        True 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">contains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">item</span><span class="s4">: </span><span class="s1">UnparsedVersion</span><span class="s4">, </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether or not the item is contained in this specifier. 
 
        :param item: 
            The item to check for, which can be a version string or a 
            :class:`Version` instance. 
        :param prereleases: 
            Whether or not to match prereleases with this Specifier. If set to 
            ``None`` (the default), it uses :attr:`prereleases` to determine 
            whether or not prereleases are allowed. 
 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.2.3&quot;) 
        True 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(Version(&quot;1.2.3&quot;)) 
        True 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.0.0&quot;) 
        False 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.3.0a1&quot;) 
        False 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True).contains(&quot;1.3.0a1&quot;) 
        True 
        &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.3.0a1&quot;, prereleases=True) 
        True 
        &quot;&quot;&quot;</span>

        <span class="s0"># Determine if prereleases are to be allowed or not.</span>
        <span class="s3">if </span><span class="s1">prereleases </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">prereleases </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span>

        <span class="s0"># Normalize item to a Version, this allows us to have a shortcut for</span>
        <span class="s0"># &quot;2.0&quot; in Specifier(&quot;&gt;=2&quot;)</span>
        <span class="s1">normalized_item </span><span class="s4">= </span><span class="s1">_coerce_version</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

        <span class="s0"># Determine if we should be supporting prereleases in this specifier</span>
        <span class="s0"># or not, if we do not support prereleases than we can short circuit</span>
        <span class="s0"># logic if this version is a prereleases.</span>
        <span class="s3">if </span><span class="s1">normalized_item</span><span class="s4">.</span><span class="s1">is_prerelease </span><span class="s3">and not </span><span class="s1">prereleases</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s0"># Actually do the comparison to determine if this item is contained</span>
        <span class="s0"># within this Specifier or not.</span>
        <span class="s1">operator_callable</span><span class="s4">: </span><span class="s1">CallableOperator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_operator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">operator_callable</span><span class="s4">(</span><span class="s1">normalized_item</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">iterable</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">], </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Filter items in the given iterable, that match the specifier. 
 
        :param iterable: 
            An iterable that can contain version strings and :class:`Version` instances. 
            The items in the iterable will be filtered according to the specifier. 
        :param prereleases: 
            Whether or not to allow prereleases in the returned iterator. If set to 
            ``None`` (the default), it will be intelligently decide whether to allow 
            prereleases or not (based on the :attr:`prereleases` attribute, and 
            whether the only versions matching are prereleases). 
 
        This method is smarter than just ``filter(Specifier().contains, [...])`` 
        because it implements the rule from :pep:`440` that a prerelease item 
        SHOULD be accepted if no other versions match the given specifier. 
 
        &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3'] 
        &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.2.3&quot;, &quot;1.3&quot;, Version(&quot;1.4&quot;)])) 
        ['1.2.3', '1.3', &lt;Version('1.4')&gt;] 
        &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.5a1&quot;])) 
        ['1.5a1'] 
        &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True)) 
        ['1.3', '1.5a1'] 
        &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3', '1.5a1'] 
        &quot;&quot;&quot;</span>

        <span class="s1">yielded </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">found_prereleases </span><span class="s4">= []</span>

        <span class="s1">kw </span><span class="s4">= {</span><span class="s5">&quot;prereleases&quot;</span><span class="s4">: </span><span class="s1">prereleases </span><span class="s3">if </span><span class="s1">prereleases </span><span class="s3">is not None else True</span><span class="s4">}</span>

        <span class="s0"># Attempt to iterate over all the values in the iterable and if any of</span>
        <span class="s0"># them match, yield them.</span>
        <span class="s3">for </span><span class="s1">version </span><span class="s3">in </span><span class="s1">iterable</span><span class="s4">:</span>
            <span class="s1">parsed_version </span><span class="s4">= </span><span class="s1">_coerce_version</span><span class="s4">(</span><span class="s1">version</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">parsed_version</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
                <span class="s0"># If our version is a prerelease, and we were not set to allow</span>
                <span class="s0"># prereleases, then we'll store it for later in case nothing</span>
                <span class="s0"># else matches this specifier.</span>
                <span class="s3">if </span><span class="s1">parsed_version</span><span class="s4">.</span><span class="s1">is_prerelease </span><span class="s3">and not </span><span class="s4">(</span>
                    <span class="s1">prereleases </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span>
                <span class="s4">):</span>
                    <span class="s1">found_prereleases</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">version</span><span class="s4">)</span>
                <span class="s0"># Either this is not a prerelease, or we should have been</span>
                <span class="s0"># accepting prereleases from the beginning.</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">yielded </span><span class="s4">= </span><span class="s3">True</span>
                    <span class="s3">yield </span><span class="s1">version</span>

        <span class="s0"># Now that we've iterated over everything, determine if we've yielded</span>
        <span class="s0"># any values, and if we have not and we have any prereleases stored up</span>
        <span class="s0"># then we will go ahead and yield the prereleases.</span>
        <span class="s3">if not </span><span class="s1">yielded </span><span class="s3">and </span><span class="s1">found_prereleases</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">version </span><span class="s3">in </span><span class="s1">found_prereleases</span><span class="s4">:</span>
                <span class="s3">yield </span><span class="s1">version</span>


<span class="s1">_prefix_regex </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;^([0-9]+)((?:a|b|c|rc)[0-9]+)$&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_version_split</span><span class="s4">(</span><span class="s1">version</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Split version into components. 
 
    The split components are intended for version comparison. The logic does 
    not attempt to retain the original version string, so joining the 
    components back with :func:`_version_join` may not produce the original 
    version string. 
    &quot;&quot;&quot;</span>
    <span class="s1">result</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = []</span>

    <span class="s1">epoch</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">rest </span><span class="s4">= </span><span class="s1">version</span><span class="s4">.</span><span class="s1">rpartition</span><span class="s4">(</span><span class="s5">&quot;!&quot;</span><span class="s4">)</span>
    <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">epoch </span><span class="s3">or </span><span class="s5">&quot;0&quot;</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rest</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;.&quot;</span><span class="s4">):</span>
        <span class="s1">match </span><span class="s4">= </span><span class="s1">_prefix_regex</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">match</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">match</span><span class="s4">.</span><span class="s1">groups</span><span class="s4">())</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_version_join</span><span class="s4">(</span><span class="s1">components</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Join split version components into a version string. 
 
    This function assumes the input came from :func:`_version_split`, where the 
    first component must be the epoch (either empty or numeric), and all other 
    components numeric. 
    &quot;&quot;&quot;</span>
    <span class="s1">epoch</span><span class="s4">, *</span><span class="s1">rest </span><span class="s4">= </span><span class="s1">components</span>
    <span class="s3">return </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">epoch</span><span class="s3">}</span><span class="s5">!</span><span class="s3">{</span><span class="s5">'.'</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">rest</span><span class="s4">)</span><span class="s3">}</span><span class="s5">&quot;</span>


<span class="s3">def </span><span class="s1">_is_not_suffix</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s3">return not </span><span class="s1">any</span><span class="s4">(</span>
        <span class="s1">segment</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s1">prefix</span><span class="s4">) </span><span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;dev&quot;</span><span class="s4">, </span><span class="s5">&quot;a&quot;</span><span class="s4">, </span><span class="s5">&quot;b&quot;</span><span class="s4">, </span><span class="s5">&quot;rc&quot;</span><span class="s4">, </span><span class="s5">&quot;post&quot;</span><span class="s4">)</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_pad_version</span><span class="s4">(</span><span class="s1">left</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">right</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">list</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]:</span>
    <span class="s1">left_split</span><span class="s4">, </span><span class="s1">right_split </span><span class="s4">= [], []</span>

    <span class="s0"># Get the release segment of our versions</span>
    <span class="s1">left_split</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">x</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">(), </span><span class="s1">left</span><span class="s4">)))</span>
    <span class="s1">right_split</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">x</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">(), </span><span class="s1">right</span><span class="s4">)))</span>

    <span class="s0"># Get the rest of our versions</span>
    <span class="s1">left_split</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">left</span><span class="s4">[</span><span class="s1">len</span><span class="s4">(</span><span class="s1">left_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) :])</span>
    <span class="s1">right_split</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">right</span><span class="s4">[</span><span class="s1">len</span><span class="s4">(</span><span class="s1">right_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) :])</span>

    <span class="s0"># Insert our padding</span>
    <span class="s1">left_split</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, [</span><span class="s5">&quot;0&quot;</span><span class="s4">] * </span><span class="s1">max</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">right_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) - </span><span class="s1">len</span><span class="s4">(</span><span class="s1">left_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])))</span>
    <span class="s1">right_split</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, [</span><span class="s5">&quot;0&quot;</span><span class="s4">] * </span><span class="s1">max</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">left_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) - </span><span class="s1">len</span><span class="s4">(</span><span class="s1">right_split</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])))</span>

    <span class="s3">return </span><span class="s4">(</span>
        <span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span><span class="s1">left_split</span><span class="s4">)),</span>
        <span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span><span class="s1">right_split</span><span class="s4">)),</span>
    <span class="s4">)</span>


<span class="s3">class </span><span class="s1">SpecifierSet</span><span class="s4">(</span><span class="s1">BaseSpecifier</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;This class abstracts handling of a set of version specifiers. 
 
    It can be passed a single specifier (``&gt;=3.0``), a comma-separated list of 
    specifiers (``&gt;=3.0,!=3.1``), or no specifier at all. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">specifiers</span><span class="s4">: </span><span class="s1">str </span><span class="s4">| </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Specifier</span><span class="s4">] = </span><span class="s5">&quot;&quot;</span><span class="s4">,</span>
        <span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Initialize a SpecifierSet instance. 
 
        :param specifiers: 
            The string representation of a specifier or a comma-separated list of 
            specifiers which will be parsed and normalized before use. 
            May also be an iterable of ``Specifier`` instances, which will be used 
            as is. 
        :param prereleases: 
            This tells the SpecifierSet if it should accept prerelease versions if 
            applicable or not. The default of ``None`` will autodetect it from the 
            given specifiers. 
 
        :raises InvalidSpecifier: 
            If the given ``specifiers`` are not parseable than this exception will be 
            raised. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">specifiers</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s0"># Split on `,` to break each individual specifier into its own item, and</span>
            <span class="s0"># strip each item to remove leading/trailing whitespace.</span>
            <span class="s1">split_specifiers </span><span class="s4">= [</span><span class="s1">s</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">specifiers</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;,&quot;</span><span class="s4">) </span><span class="s3">if </span><span class="s1">s</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()]</span>

            <span class="s0"># Make each individual specifier a Specifier and save in a frozen set</span>
            <span class="s0"># for later.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_specs </span><span class="s4">= </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">map</span><span class="s4">(</span><span class="s1">Specifier</span><span class="s4">, </span><span class="s1">split_specifiers</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># Save the supplied specifiers in a frozen set.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_specs </span><span class="s4">= </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">specifiers</span><span class="s4">)</span>

        <span class="s0"># Store our prereleases value so we can use it later to determine if</span>
        <span class="s0"># we accept prereleases or not.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">prereleases</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool </span><span class="s4">| </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0"># If we have been given an explicit prerelease modifier, then we'll</span>
        <span class="s0"># pass that through here.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases</span>

        <span class="s0"># If we don't have any specifiers, and we don't have a forced value,</span>
        <span class="s0"># then we'll just return None since we don't know if this should have</span>
        <span class="s0"># pre-releases or not.</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s0"># Otherwise we'll see if any of the given specifiers accept</span>
        <span class="s0"># prereleases, if any of them do we'll return True, otherwise False.</span>
        <span class="s3">return </span><span class="s1">any</span><span class="s4">(</span><span class="s1">s</span><span class="s4">.</span><span class="s1">prereleases </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">prereleases</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">prereleases</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A representation of the specifier set that shows all internal state. 
 
        Note that the ordering of the individual specifiers within the set may not 
        match the input string. 
 
        &gt;&gt;&gt; SpecifierSet('&gt;=1.0.0,!=2.0.0') 
        &lt;SpecifierSet('!=2.0.0,&gt;=1.0.0')&gt; 
        &gt;&gt;&gt; SpecifierSet('&gt;=1.0.0,!=2.0.0', prereleases=False) 
        &lt;SpecifierSet('!=2.0.0,&gt;=1.0.0', prereleases=False)&gt; 
        &gt;&gt;&gt; SpecifierSet('&gt;=1.0.0,!=2.0.0', prereleases=True) 
        &lt;SpecifierSet('!=2.0.0,&gt;=1.0.0', prereleases=True)&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">pre </span><span class="s4">= (</span>
            <span class="s5">f&quot;, prereleases=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span><span class="s3">!r}</span><span class="s5">&quot;</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s5">&quot;&quot;</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s5">f&quot;&lt;SpecifierSet(</span><span class="s3">{</span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span><span class="s3">!r}{</span><span class="s1">pre</span><span class="s3">}</span><span class="s5">)&gt;&quot;</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A string representation of the specifier set that can be round-tripped. 
 
        Note that the ordering of the individual specifiers within the set may not 
        match the input string. 
 
        &gt;&gt;&gt; str(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)) 
        '!=1.0.1,&gt;=1.0.0' 
        &gt;&gt;&gt; str(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=False)) 
        '!=1.0.1,&gt;=1.0.0' 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">&quot;,&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">s</span><span class="s4">) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__and__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">SpecifierSet </span><span class="s4">| </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; SpecifierSet</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a SpecifierSet which is a combination of the two sets. 
 
        :param other: The other object to combine with. 
 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) &amp; '&lt;=2.0.0,!=2.0.1' 
        &lt;SpecifierSet('!=1.0.1,!=2.0.1,&lt;=2.0.0,&gt;=1.0.0')&gt; 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) &amp; SpecifierSet('&lt;=2.0.0,!=2.0.1') 
        &lt;SpecifierSet('!=1.0.1,!=2.0.1,&lt;=2.0.0,&gt;=1.0.0')&gt; 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">SpecifierSet</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>
        <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">SpecifierSet</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s1">specifier </span><span class="s4">= </span><span class="s1">SpecifierSet</span><span class="s4">()</span>
        <span class="s1">specifier</span><span class="s4">.</span><span class="s1">_specs </span><span class="s4">= </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs </span><span class="s4">| </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is None and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">specifier</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_prereleases</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is not None and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">specifier</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_prereleases</span><span class="s4">:</span>
            <span class="s1">specifier</span><span class="s4">.</span><span class="s1">_prereleases </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prereleases</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Cannot combine SpecifierSets with True and False prerelease &quot;</span>
                <span class="s5">&quot;overrides.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">specifier</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Whether or not the two SpecifierSet-like objects are equal. 
 
        :param other: The other object to check against. 
 
        The value of :attr:`prereleases` is ignored. 
 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) 
        True 
        &gt;&gt;&gt; (SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=False) == 
        ...  SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True)) 
        True 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == &quot;&gt;=1.0.0,!=1.0.1&quot; 
        True 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0&quot;) 
        False 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0,!=1.0.2&quot;) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, (</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Specifier</span><span class="s4">)):</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">SpecifierSet</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">))</span>
        <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">SpecifierSet</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_specs</span>

    <span class="s3">def </span><span class="s1">__len__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Returns the number of specifiers in this specifier set.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Specifier</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns an iterator over all the underlying :class:`Specifier` instances 
        in this specifier set. 
 
        &gt;&gt;&gt; sorted(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;), key=str) 
        [&lt;Specifier('!=1.0.1')&gt;, &lt;Specifier('&gt;=1.0.0')&gt;] 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__contains__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">item</span><span class="s4">: </span><span class="s1">UnparsedVersion</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether or not the item is contained in this specifier. 
 
        :param item: The item to check for. 
 
        This is used for the ``in`` operator and behaves the same as 
        :meth:`contains` with no ``prereleases`` argument passed. 
 
        &gt;&gt;&gt; &quot;1.2.3&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) 
        True 
        &gt;&gt;&gt; Version(&quot;1.2.3&quot;) in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) 
        True 
        &gt;&gt;&gt; &quot;1.0.1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) 
        False 
        &gt;&gt;&gt; &quot;1.3.0a1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) 
        False 
        &gt;&gt;&gt; &quot;1.3.0a1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True) 
        True 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">contains</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">item</span><span class="s4">: </span><span class="s1">UnparsedVersion</span><span class="s4">,</span>
        <span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">installed</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether or not the item is contained in this SpecifierSet. 
 
        :param item: 
            The item to check for, which can be a version string or a 
            :class:`Version` instance. 
        :param prereleases: 
            Whether or not to match prereleases with this SpecifierSet. If set to 
            ``None`` (the default), it uses :attr:`prereleases` to determine 
            whether or not prereleases are allowed. 
 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.2.3&quot;) 
        True 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(Version(&quot;1.2.3&quot;)) 
        True 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.0.1&quot;) 
        False 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.3.0a1&quot;) 
        False 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True).contains(&quot;1.3.0a1&quot;) 
        True 
        &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.3.0a1&quot;, prereleases=True) 
        True 
        &quot;&quot;&quot;</span>
        <span class="s0"># Ensure that our item is a Version instance.</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">item</span><span class="s4">, </span><span class="s1">Version</span><span class="s4">):</span>
            <span class="s1">item </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

        <span class="s0"># Determine if we're forcing a prerelease or not, if we're not forcing</span>
        <span class="s0"># one for this particular filter call, then we'll use whatever the</span>
        <span class="s0"># SpecifierSet thinks for whether or not we should support prereleases.</span>
        <span class="s3">if </span><span class="s1">prereleases </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">prereleases </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span>

        <span class="s0"># We can determine if we're going to allow pre-releases by looking to</span>
        <span class="s0"># see if any of the underlying items supports them. If none of them do</span>
        <span class="s0"># and this item is a pre-release then we do not allow it and we can</span>
        <span class="s0"># short circuit that here.</span>
        <span class="s0"># Note: This means that 1.0.dev1 would not be contained in something</span>
        <span class="s0">#       like &gt;=1.0.devabc however it would be in &gt;=1.0.debabc,&gt;0.0.dev0</span>
        <span class="s3">if not </span><span class="s1">prereleases </span><span class="s3">and </span><span class="s1">item</span><span class="s4">.</span><span class="s1">is_prerelease</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s3">if </span><span class="s1">installed </span><span class="s3">and </span><span class="s1">item</span><span class="s4">.</span><span class="s1">is_prerelease</span><span class="s4">:</span>
            <span class="s1">item </span><span class="s4">= </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">item</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">)</span>

        <span class="s0"># We simply dispatch to the underlying specs here to make sure that the</span>
        <span class="s0"># given version is contained within all of them.</span>
        <span class="s0"># Note: This use of all() here means that an empty set of specifiers</span>
        <span class="s0">#       will always return True, this is an explicit design decision.</span>
        <span class="s3">return </span><span class="s1">all</span><span class="s4">(</span><span class="s1">s</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">item</span><span class="s4">, </span><span class="s1">prereleases</span><span class="s4">=</span><span class="s1">prereleases</span><span class="s4">) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">iterable</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">], </span><span class="s1">prereleases</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Filter items in the given iterable, that match the specifiers in this set. 
 
        :param iterable: 
            An iterable that can contain version strings and :class:`Version` instances. 
            The items in the iterable will be filtered according to the specifier. 
        :param prereleases: 
            Whether or not to allow prereleases in the returned iterator. If set to 
            ``None`` (the default), it will be intelligently decide whether to allow 
            prereleases or not (based on the :attr:`prereleases` attribute, and 
            whether the only versions matching are prereleases). 
 
        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])`` 
        because it implements the rule from :pep:`440` that a prerelease item 
        SHOULD be accepted if no other versions match the given specifier. 
 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3'] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, Version(&quot;1.4&quot;)])) 
        ['1.3', &lt;Version('1.4')&gt;] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.5a1&quot;])) 
        [] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True)) 
        ['1.3', '1.5a1'] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3', '1.5a1'] 
 
        An &quot;empty&quot; SpecifierSet will filter items based on the presence of prerelease 
        versions in the set. 
 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3'] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.5a1&quot;])) 
        ['1.5a1'] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;])) 
        ['1.3', '1.5a1'] 
        &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True)) 
        ['1.3', '1.5a1'] 
        &quot;&quot;&quot;</span>
        <span class="s0"># Determine if we're forcing a prerelease or not, if we're not forcing</span>
        <span class="s0"># one for this particular filter call, then we'll use whatever the</span>
        <span class="s0"># SpecifierSet thinks for whether or not we should support prereleases.</span>
        <span class="s3">if </span><span class="s1">prereleases </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">prereleases </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">prereleases</span>

        <span class="s0"># If we have any specifiers, then we want to wrap our iterable in the</span>
        <span class="s0"># filter method for each one, this will act as a logical AND amongst</span>
        <span class="s0"># each specifier.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">spec </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_specs</span><span class="s4">:</span>
                <span class="s1">iterable </span><span class="s4">= </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">, </span><span class="s1">prereleases</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">(</span><span class="s1">prereleases</span><span class="s4">))</span>
            <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">)</span>
        <span class="s0"># If we do not have any specifiers, then we need to have a rough filter</span>
        <span class="s0"># which will filter out any pre-releases, unless there are no final</span>
        <span class="s0"># releases.</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">filtered</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">] = []</span>
            <span class="s1">found_prereleases</span><span class="s4">: </span><span class="s1">list</span><span class="s4">[</span><span class="s1">UnparsedVersionVar</span><span class="s4">] = []</span>

            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">iterable</span><span class="s4">:</span>
                <span class="s1">parsed_version </span><span class="s4">= </span><span class="s1">_coerce_version</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

                <span class="s0"># Store any item which is a pre-release for later unless we've</span>
                <span class="s0"># already found a final version or we are accepting prereleases</span>
                <span class="s3">if </span><span class="s1">parsed_version</span><span class="s4">.</span><span class="s1">is_prerelease </span><span class="s3">and not </span><span class="s1">prereleases</span><span class="s4">:</span>
                    <span class="s3">if not </span><span class="s1">filtered</span><span class="s4">:</span>
                        <span class="s1">found_prereleases</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">filtered</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

            <span class="s0"># If we've found no items except for pre-releases, then we'll go</span>
            <span class="s0"># ahead and use the pre-releases</span>
            <span class="s3">if not </span><span class="s1">filtered </span><span class="s3">and </span><span class="s1">found_prereleases </span><span class="s3">and </span><span class="s1">prereleases </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">found_prereleases</span><span class="s4">)</span>

            <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">filtered</span><span class="s4">)</span>
</pre>
</body>
</html>