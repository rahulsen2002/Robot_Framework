<html>
<head>
<title>formats.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
formats.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The functions in this module are used to validate schemas with the 
`format JSON Schema keyword 
&lt;https://json-schema.org/understanding-json-schema/reference/string#format&gt;`_. 
 
The correspondence is given by replacing the ``_`` character in the name of the 
function with a ``-`` to obtain the format name and vice versa. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">builtins</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain </span><span class="s2">as </span><span class="s1">_chain</span>

<span class="s2">if </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s1">_logger </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s1">__name__</span><span class="s3">)</span>

<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># PEP 440</span>

<span class="s1">VERSION_PATTERN </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot; 
    v? 
    (?: 
        (?:(?P&lt;epoch&gt;[0-9]+)!)?                           # epoch 
        (?P&lt;release&gt;[0-9]+(?:\.[0-9]+)*)                  # release segment 
        (?P&lt;pre&gt;                                          # pre-release 
            [-_\.]? 
            (?P&lt;pre_l&gt;alpha|a|beta|b|preview|pre|c|rc) 
            [-_\.]? 
            (?P&lt;pre_n&gt;[0-9]+)? 
        )? 
        (?P&lt;post&gt;                                         # post release 
            (?:-(?P&lt;post_n1&gt;[0-9]+)) 
            | 
            (?: 
                [-_\.]? 
                (?P&lt;post_l&gt;post|rev|r) 
                [-_\.]? 
                (?P&lt;post_n2&gt;[0-9]+)? 
            ) 
        )? 
        (?P&lt;dev&gt;                                          # dev release 
            [-_\.]? 
            (?P&lt;dev_l&gt;dev) 
            [-_\.]? 
            (?P&lt;dev_n&gt;[0-9]+)? 
        )? 
    ) 
    (?:\+(?P&lt;local&gt;[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version 
&quot;&quot;&quot;</span>

<span class="s1">VERSION_REGEX </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r&quot;^\s*&quot; </span><span class="s3">+ </span><span class="s1">VERSION_PATTERN </span><span class="s3">+ </span><span class="s5">r&quot;\s*$&quot;</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">X </span><span class="s3">| </span><span class="s1">re</span><span class="s3">.</span><span class="s1">I</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pep440</span><span class="s3">(</span><span class="s1">version</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;See :ref:`PyPA's version specification &lt;pypa:version-specifiers&gt;` 
    (initially introduced in :pep:`440`). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">VERSION_REGEX</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">version</span><span class="s3">) </span><span class="s2">is not None</span>


<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># PEP 508</span>

<span class="s1">PEP508_IDENTIFIER_PATTERN </span><span class="s3">= </span><span class="s5">r&quot;([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])&quot;</span>
<span class="s1">PEP508_IDENTIFIER_REGEX </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">f&quot;^</span><span class="s2">{</span><span class="s1">PEP508_IDENTIFIER_PATTERN</span><span class="s2">}</span><span class="s5">$&quot;</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">I</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pep508_identifier</span><span class="s3">(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;See :ref:`PyPA's name specification &lt;pypa:name-format&gt;` 
    (initially introduced in :pep:`508#names`). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">PEP508_IDENTIFIER_REGEX</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) </span><span class="s2">is not None</span>


<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">packaging </span><span class="s2">import </span><span class="s1">requirements </span><span class="s2">as </span><span class="s1">_req</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s4"># let's try setuptools vendored version</span>
        <span class="s2">from </span><span class="s1">setuptools</span><span class="s3">.</span><span class="s1">_vendor</span><span class="s3">.</span><span class="s1">packaging </span><span class="s2">import </span><span class="s3">(  </span><span class="s4"># type: ignore[no-redef]</span>
            <span class="s1">requirements </span><span class="s2">as </span><span class="s1">_req</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">pep508</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;See :ref:`PyPA's dependency specifiers &lt;pypa:dependency-specifiers&gt;` 
        (initially introduced in :pep:`508`). 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">_req</span><span class="s3">.</span><span class="s1">Requirement</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">_req</span><span class="s3">.</span><span class="s1">InvalidRequirement</span><span class="s3">:</span>
            <span class="s2">return False</span>

<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s1">_logger</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
        <span class="s5">&quot;Could not find an installation of `packaging`. Requirements, dependencies and &quot;</span>
        <span class="s5">&quot;versions might not be validated. &quot;</span>
        <span class="s5">&quot;To enforce validation, please install `packaging`.&quot;</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">pep508</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">pep508_versionspec</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Expression that can be used to specify/lock versions (including ranges) 
    See ``versionspec`` in :ref:`PyPA's dependency specifiers 
    &lt;pypa:dependency-specifiers&gt;` (initially introduced in :pep:`508`). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">c </span><span class="s2">in </span><span class="s1">value </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s3">(</span><span class="s5">&quot;;&quot;</span><span class="s3">, </span><span class="s5">&quot;]&quot;</span><span class="s3">, </span><span class="s5">&quot;@&quot;</span><span class="s3">)):</span>
        <span class="s4"># In PEP 508:</span>
        <span class="s4"># conditional markers, extras and URL specs are not included in the</span>
        <span class="s4"># versionspec</span>
        <span class="s2">return False</span>
    <span class="s4"># Let's pretend we have a dependency called `requirement` with the given</span>
    <span class="s4"># version spec, then we can reuse the pep508 function for validation:</span>
    <span class="s2">return </span><span class="s1">pep508</span><span class="s3">(</span><span class="s5">f&quot;requirement</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>


<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># PEP 517</span>


<span class="s2">def </span><span class="s1">pep517_backend_reference</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;See PyPA's specification for defining build-backend references 
    introduced in :pep:`517#source-trees`. 
 
    This is similar to an entry-point reference (e.g., ``package.module:object``). 
    &quot;&quot;&quot;</span>
    <span class="s1">module</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">partition</span><span class="s3">(</span><span class="s5">&quot;:&quot;</span><span class="s3">)</span>
    <span class="s1">identifiers </span><span class="s3">= (</span><span class="s1">i</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">_chain</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">), </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)))</span>
    <span class="s2">return </span><span class="s1">all</span><span class="s3">(</span><span class="s1">python_identifier</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">identifiers </span><span class="s2">if </span><span class="s1">i</span><span class="s3">)</span>


<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># Classifiers - PEP 301</span>


<span class="s2">def </span><span class="s1">_download_classifiers</span><span class="s3">() </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">ssl</span>
    <span class="s2">from </span><span class="s1">email</span><span class="s3">.</span><span class="s1">message </span><span class="s2">import </span><span class="s1">Message</span>
    <span class="s2">from </span><span class="s1">urllib</span><span class="s3">.</span><span class="s1">request </span><span class="s2">import </span><span class="s1">urlopen</span>

    <span class="s1">url </span><span class="s3">= </span><span class="s5">&quot;https://pypi.org/pypi?:action=list_classifiers&quot;</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s1">ssl</span><span class="s3">.</span><span class="s1">create_default_context</span><span class="s3">()</span>
    <span class="s2">with </span><span class="s1">urlopen</span><span class="s3">(</span><span class="s1">url</span><span class="s3">, </span><span class="s1">context</span><span class="s3">=</span><span class="s1">context</span><span class="s3">) </span><span class="s2">as </span><span class="s1">response</span><span class="s3">:  </span><span class="s4"># noqa: S310 (audit URLs)</span>
        <span class="s1">headers </span><span class="s3">= </span><span class="s1">Message</span><span class="s3">()</span>
        <span class="s1">headers</span><span class="s3">[</span><span class="s5">&quot;content_type&quot;</span><span class="s3">] = </span><span class="s1">response</span><span class="s3">.</span><span class="s1">getheader</span><span class="s3">(</span><span class="s5">&quot;content-type&quot;</span><span class="s3">, </span><span class="s5">&quot;text/plain&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">response</span><span class="s3">.</span><span class="s1">read</span><span class="s3">().</span><span class="s1">decode</span><span class="s3">(</span><span class="s1">headers</span><span class="s3">.</span><span class="s1">get_param</span><span class="s3">(</span><span class="s5">&quot;charset&quot;</span><span class="s3">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s3">))  </span><span class="s4"># type: ignore[no-any-return]</span>


<span class="s2">class </span><span class="s1">_TroveClassifier</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;The ``trove_classifiers`` package is the official way of validating classifiers, 
    however this package might not be always available. 
    As a workaround we can still download a list from PyPI. 
    We also don't want to be over strict about it, so simply skipping silently is an 
    option (classifiers will be validated anyway during the upload to PyPI). 
    &quot;&quot;&quot;</span>

    <span class="s1">downloaded</span><span class="s3">: </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s5">&quot;Literal[False]&quot;</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">Set</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]]</span>
    <span class="s5">&quot;&quot;&quot; 
    None =&gt; not cached yet 
    False =&gt; unavailable 
    set =&gt; cached values 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_download </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s5">&quot;trove_classifier&quot;  </span><span class="s4"># Emulate a public function</span>

    <span class="s2">def </span><span class="s1">_disable_download</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4"># This is a private API. Only setuptools has the consent of using it.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_download </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s2">is False or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_download </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">return True</span>

        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getenv</span><span class="s3">(</span><span class="s5">&quot;NO_NETWORK&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getenv</span><span class="s3">(</span><span class="s5">&quot;VALIDATE_PYPROJECT_NO_NETWORK&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">msg </span><span class="s3">= (</span>
                <span class="s5">&quot;Install ``trove-classifiers`` to ensure proper validation. &quot;</span>
                <span class="s5">&quot;Skipping download of classifiers list from PyPI (NO_NETWORK).&quot;</span>
            <span class="s3">)</span>
            <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s2">return True</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span>
                <span class="s5">&quot;Install ``trove-classifiers`` to ensure proper validation. &quot;</span>
                <span class="s5">&quot;Meanwhile a list of classifiers will be downloaded from PyPI.&quot;</span>
            <span class="s3">)</span>
            <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">_download_classifiers</span><span class="s3">().</span><span class="s1">splitlines</span><span class="s3">())</span>
            <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">&quot;Problem with download, skipping validation&quot;</span><span class="s3">)</span>
                <span class="s2">return True</span>

        <span class="s2">return </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">downloaded </span><span class="s2">or </span><span class="s1">value</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">().</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;private ::&quot;</span><span class="s3">)</span>


<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">trove_classifiers </span><span class="s2">import </span><span class="s1">classifiers </span><span class="s2">as </span><span class="s1">_trove_classifiers</span>

    <span class="s2">def </span><span class="s1">trove_classifier</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;See https://pypi.org/classifiers/&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">value </span><span class="s2">in </span><span class="s1">_trove_classifiers </span><span class="s2">or </span><span class="s1">value</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">().</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;private ::&quot;</span><span class="s3">)</span>

<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s1">trove_classifier </span><span class="s3">= </span><span class="s1">_TroveClassifier</span><span class="s3">()</span>


<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># Stub packages - PEP 561</span>


<span class="s2">def </span><span class="s1">pep561_stub_name</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Name of a directory containing type stubs. 
    It must follow the name scheme ``&lt;package&gt;-stubs`` as defined in 
    :pep:`561#stub-only-packages`. 
    &quot;&quot;&quot;</span>
    <span class="s1">top</span><span class="s3">, *</span><span class="s1">children </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">top</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;-stubs&quot;</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">python_module_name</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">top</span><span class="s3">[: -</span><span class="s1">len</span><span class="s3">(</span><span class="s5">&quot;-stubs&quot;</span><span class="s3">)], *</span><span class="s1">children</span><span class="s3">]))</span>


<span class="s4"># -------------------------------------------------------------------------------------</span>
<span class="s4"># Non-PEP related</span>


<span class="s2">def </span><span class="s1">url</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Valid URL (validation uses :obj:`urllib.parse`). 
    For maximum compatibility please make sure to include a ``scheme`` prefix 
    in your URL (e.g. ``http://``). 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">urllib</span><span class="s3">.</span><span class="s1">parse </span><span class="s2">import </span><span class="s1">urlparse</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">parts </span><span class="s3">= </span><span class="s1">urlparse</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">parts</span><span class="s3">.</span><span class="s1">scheme</span><span class="s3">:</span>
            <span class="s1">_logger</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
                <span class="s5">&quot;For maximum compatibility please make sure to include a &quot;</span>
                <span class="s5">&quot;`scheme` prefix in your URL (e.g. 'http://'). &quot;</span>
                <span class="s5">f&quot;Given value: </span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s3">)</span>
            <span class="s2">if not </span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;/&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">value</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\\</span><span class="s5">&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s5">&quot;@&quot; </span><span class="s2">in </span><span class="s1">value</span><span class="s3">):</span>
                <span class="s1">parts </span><span class="s3">= </span><span class="s1">urlparse</span><span class="s3">(</span><span class="s5">f&quot;http://</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">.</span><span class="s1">scheme </span><span class="s2">and </span><span class="s1">parts</span><span class="s3">.</span><span class="s1">netloc</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
        <span class="s2">return False</span>


<span class="s4"># https://packaging.python.org/specifications/entry-points/</span>
<span class="s1">ENTRYPOINT_PATTERN </span><span class="s3">= </span><span class="s5">r&quot;[^\[\s=]([^=]*[^\s=])?&quot;</span>
<span class="s1">ENTRYPOINT_REGEX </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">f&quot;^</span><span class="s2">{</span><span class="s1">ENTRYPOINT_PATTERN</span><span class="s2">}</span><span class="s5">$&quot;</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">I</span><span class="s3">)</span>
<span class="s1">RECOMMEDED_ENTRYPOINT_PATTERN </span><span class="s3">= </span><span class="s5">r&quot;[\w.-]+&quot;</span>
<span class="s1">RECOMMEDED_ENTRYPOINT_REGEX </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">f&quot;^</span><span class="s2">{</span><span class="s1">RECOMMEDED_ENTRYPOINT_PATTERN</span><span class="s2">}</span><span class="s5">$&quot;</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">I</span><span class="s3">)</span>
<span class="s1">ENTRYPOINT_GROUP_PATTERN </span><span class="s3">= </span><span class="s5">r&quot;\w+(\.\w+)*&quot;</span>
<span class="s1">ENTRYPOINT_GROUP_REGEX </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">f&quot;^</span><span class="s2">{</span><span class="s1">ENTRYPOINT_GROUP_PATTERN</span><span class="s2">}</span><span class="s5">$&quot;</span><span class="s3">, </span><span class="s1">re</span><span class="s3">.</span><span class="s1">I</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">python_identifier</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Can be used as identifier in Python. 
    (Validation uses :obj:`str.isidentifier`). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s3">.</span><span class="s1">isidentifier</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">python_qualified_identifier</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Python &quot;dotted identifier&quot;, i.e. a sequence of :obj:`python_identifier` 
    concatenated with ``&quot;.&quot;`` (e.g.: ``package.module.submodule``). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">all</span><span class="s3">(</span><span class="s1">python_identifier</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">value</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">python_module_name</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Module name that can be used in an ``import``-statement in Python. 
    See :obj:`python_qualified_identifier`. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">python_qualified_identifier</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">python_module_name_relaxed</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Similar to :obj:`python_module_name`, but relaxed to also accept 
    dash characters (``-``) and cover special cases like ``pip-run``. 
 
    It is recommended, however, that beginners avoid dash characters, 
    as they require advanced knowledge about Python internals. 
 
    The following are disallowed: 
 
    * names starting/ending in dashes, 
    * names ending in ``-stubs`` (potentially collide with :obj:`pep561_stub_name`). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;-&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;-&quot;</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;-stubs&quot;</span><span class="s3">):</span>
        <span class="s2">return False  </span><span class="s4"># Avoid collision with PEP 561</span>
    <span class="s2">return </span><span class="s1">python_module_name</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">&quot;-&quot;</span><span class="s3">, </span><span class="s5">&quot;_&quot;</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">python_entrypoint_group</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;See ``Data model &gt; group`` in the :ref:`PyPA's entry-points specification 
    &lt;pypa:entry-points&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ENTRYPOINT_GROUP_REGEX</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) </span><span class="s2">is not None</span>


<span class="s2">def </span><span class="s1">python_entrypoint_name</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;See ``Data model &gt; name`` in the :ref:`PyPA's entry-points specification 
    &lt;pypa:entry-points&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">ENTRYPOINT_REGEX</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">if not </span><span class="s1">RECOMMEDED_ENTRYPOINT_REGEX</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">f&quot;Entry point `</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">` does not follow recommended pattern: &quot;</span>
        <span class="s1">msg </span><span class="s3">+= </span><span class="s1">RECOMMEDED_ENTRYPOINT_PATTERN</span>
        <span class="s1">_logger</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">python_entrypoint_reference</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Reference to a Python object using in the format:: 
 
        importable.module:object.attr 
 
    See ``Data model &gt;object reference`` in the :ref:`PyPA's entry-points specification 
    &lt;pypa:entry-points&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s1">module</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">rest </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">partition</span><span class="s3">(</span><span class="s5">&quot;:&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s5">&quot;[&quot; </span><span class="s2">in </span><span class="s1">rest</span><span class="s3">:</span>
        <span class="s1">obj</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">extras_ </span><span class="s3">= </span><span class="s1">rest</span><span class="s3">.</span><span class="s1">partition</span><span class="s3">(</span><span class="s5">&quot;[&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">extras_</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s5">&quot;]&quot;</span><span class="s3">:</span>
            <span class="s2">return False</span>
        <span class="s1">extras </span><span class="s3">= (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">extras_</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">(</span><span class="s1">string</span><span class="s3">.</span><span class="s1">whitespace </span><span class="s3">+ </span><span class="s5">&quot;[]&quot;</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;,&quot;</span><span class="s3">))</span>
        <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">pep508_identifier</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">extras</span><span class="s3">):</span>
            <span class="s2">return False</span>
        <span class="s1">_logger</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s5">f&quot;`</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">` - using extras for entry points is not recommended&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">obj </span><span class="s3">= </span><span class="s1">rest</span>

    <span class="s1">module_parts </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)</span>
    <span class="s1">identifiers </span><span class="s3">= </span><span class="s1">_chain</span><span class="s3">(</span><span class="s1">module_parts</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)) </span><span class="s2">if </span><span class="s1">rest </span><span class="s2">else </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">module_parts</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">all</span><span class="s3">(</span><span class="s1">python_identifier</span><span class="s3">(</span><span class="s1">i</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">identifiers</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">uint8</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">builtins</span><span class="s3">.</span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">r&quot;&quot;&quot;Unsigned 8-bit integer (:math:`0 \leq x &lt; 2^8`)&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s6">0 </span><span class="s3">&lt;= </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">**</span><span class="s6">8</span>


<span class="s2">def </span><span class="s1">uint16</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">builtins</span><span class="s3">.</span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">r&quot;&quot;&quot;Unsigned 16-bit integer (:math:`0 \leq x &lt; 2^{16}`)&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s6">0 </span><span class="s3">&lt;= </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">**</span><span class="s6">16</span>


<span class="s2">def </span><span class="s1">uint</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">builtins</span><span class="s3">.</span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">r&quot;&quot;&quot;Unsigned 64-bit integer (:math:`0 \leq x &lt; 2^{64}`)&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s6">0 </span><span class="s3">&lt;= </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">**</span><span class="s6">64</span>


<span class="s2">def </span><span class="s1">int</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">builtins</span><span class="s3">.</span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">r&quot;&quot;&quot;Signed 64-bit integer (:math:`-2^{63} \leq x &lt; 2^{63}`)&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">-(</span><span class="s6">2</span><span class="s3">**</span><span class="s6">63</span><span class="s3">) &lt;= </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">**</span><span class="s6">63</span>


<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">packaging </span><span class="s2">import </span><span class="s1">licenses </span><span class="s2">as </span><span class="s1">_licenses</span>

    <span class="s2">def </span><span class="s1">SPDX</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;See :ref:`PyPA's License-Expression specification 
        &lt;pypa:core-metadata-license-expression&gt;` (added in :pep:`639`). 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">_licenses</span><span class="s3">.</span><span class="s1">canonicalize_license_expression</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">_licenses</span><span class="s3">.</span><span class="s1">InvalidLicenseExpression</span><span class="s3">:</span>
            <span class="s2">return False</span>

<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s1">_logger</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
        <span class="s5">&quot;Could not find an up-to-date installation of `packaging`. &quot;</span>
        <span class="s5">&quot;License expressions might not be validated. &quot;</span>
        <span class="s5">&quot;To enforce validation, please install `packaging&gt;=24.2`.&quot;</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">SPDX</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return True</span>
</pre>
</body>
</html>