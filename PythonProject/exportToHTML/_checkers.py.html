<html>
<head>
<title>_checkers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_checkers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">Parameter</span><span class="s2">, </span><span class="s1">isclass</span><span class="s2">, </span><span class="s1">isfunction</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BufferedIOBase</span><span class="s2">, </span><span class="s1">IOBase</span><span class="s2">, </span><span class="s1">RawIOBase</span><span class="s2">, </span><span class="s1">TextIOBase</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">indent</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">IO</span><span class="s2">,</span>
    <span class="s1">AbstractSet</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">BinaryIO</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">ForwardRef</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">MutableMapping</span><span class="s2">,</span>
    <span class="s1">NewType</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">,</span>
    <span class="s1">TextIO</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">mock </span><span class="s0">import </span><span class="s1">Mock</span>
<span class="s0">from </span><span class="s1">weakref </span><span class="s0">import </span><span class="s1">WeakKeyDictionary</span>

<span class="s0">try</span><span class="s2">:</span>
    <span class="s0">import </span><span class="s1">typing_extensions</span>
<span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
    <span class="s1">typing_extensions </span><span class="s2">= </span><span class="s0">None  </span><span class="s3"># type: ignore[assignment]</span>

<span class="s3"># Must use this because typing.is_typeddict does not recognize</span>
<span class="s3"># TypedDict from typing_extensions, and as of version 4.12.0</span>
<span class="s3"># typing_extensions.TypedDict is different from typing.TypedDict</span>
<span class="s3"># on all versions.</span>
<span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">is_typeddict</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_config </span><span class="s0">import </span><span class="s1">ForwardRefPolicy</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">TypeCheckError</span><span class="s2">, </span><span class="s1">TypeHintWarning</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_memo </span><span class="s0">import </span><span class="s1">TypeCheckMemo</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_utils </span><span class="s0">import </span><span class="s1">evaluate_forwardref</span><span class="s2">, </span><span class="s1">get_stacklevel</span><span class="s2">, </span><span class="s1">get_type_name</span><span class="s2">, </span><span class="s1">qualified_name</span>

<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">11</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Annotated</span><span class="s2">,</span>
        <span class="s1">NotRequired</span><span class="s2">,</span>
        <span class="s1">TypeAlias</span><span class="s2">,</span>
        <span class="s1">get_args</span><span class="s2">,</span>
        <span class="s1">get_origin</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">SubclassableAny </span><span class="s2">= </span><span class="s1">Any</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Annotated</span><span class="s2">,</span>
        <span class="s1">NotRequired</span><span class="s2">,</span>
        <span class="s1">TypeAlias</span><span class="s2">,</span>
        <span class="s1">get_args</span><span class="s2">,</span>
        <span class="s1">get_origin</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Any </span><span class="s0">as </span><span class="s1">SubclassableAny</span>

<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">importlib</span><span class="s2">.</span><span class="s1">metadata </span><span class="s0">import </span><span class="s1">entry_points</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">ParamSpec</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">importlib_metadata </span><span class="s0">import </span><span class="s1">entry_points</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">ParamSpec</span>

<span class="s1">TypeCheckerCallable</span><span class="s2">: </span><span class="s1">TypeAlias </span><span class="s2">= </span><span class="s1">Callable</span><span class="s2">[</span>
    <span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">TypeCheckMemo</span><span class="s2">], </span><span class="s1">Any</span>
<span class="s2">]</span>
<span class="s1">TypeCheckLookupCallback</span><span class="s2">: </span><span class="s1">TypeAlias </span><span class="s2">= </span><span class="s1">Callable</span><span class="s2">[</span>
    <span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]], </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">TypeCheckerCallable</span><span class="s2">]</span>
<span class="s2">]</span>

<span class="s1">checker_lookup_functions</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">TypeCheckLookupCallback</span><span class="s2">] = []</span>
<span class="s1">generic_alias_types</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, ...] = (</span><span class="s1">type</span><span class="s2">(</span><span class="s1">List</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">List</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]))</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
    <span class="s1">generic_alias_types </span><span class="s2">+= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">,)</span>

<span class="s1">protocol_check_cache</span><span class="s2">: </span><span class="s1">WeakKeyDictionary</span><span class="s2">[</span>
    <span class="s1">type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">TypeCheckError </span><span class="s2">| </span><span class="s0">None</span><span class="s2">]</span>
<span class="s2">] = </span><span class="s1">WeakKeyDictionary</span><span class="s2">()</span>

<span class="s3"># Sentinel</span>
<span class="s1">_missing </span><span class="s2">= </span><span class="s1">object</span><span class="s2">()</span>

<span class="s3"># Lifted from mypy.sharedparse</span>
<span class="s1">BINARY_MAGIC_METHODS </span><span class="s2">= {</span>
    <span class="s5">&quot;__add__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__and__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__cmp__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__divmod__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__div__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__eq__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__floordiv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ge__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__gt__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__iadd__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__iand__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__idiv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ifloordiv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ilshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__imatmul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__imod__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__imul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ior__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ipow__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__irshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__isub__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__itruediv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ixor__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__le__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__lshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__lt__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__matmul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__mod__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__mul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ne__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__or__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__pow__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__radd__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rand__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rdiv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rfloordiv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rlshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rmatmul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rmod__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rmul__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__ror__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rpow__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rrshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rshift__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rsub__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rtruediv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__rxor__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__sub__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__truediv__&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;__xor__&quot;</span><span class="s2">,</span>
<span class="s2">}</span>


<span class="s0">def </span><span class="s1">check_callable</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not callable&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">signature </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s0">return</span>

        <span class="s1">argument_types </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">argument_types</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">any</span><span class="s2">(</span>
            <span class="s1">type</span><span class="s2">(</span><span class="s1">item</span><span class="s2">) </span><span class="s0">is </span><span class="s1">ParamSpec </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">argument_types</span>
        <span class="s2">):</span>
            <span class="s3"># The callable must not have keyword-only arguments without defaults</span>
            <span class="s1">unfulfilled_kwonlyargs </span><span class="s2">= [</span>
                <span class="s1">param</span><span class="s2">.</span><span class="s1">name</span>
                <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">signature</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">param</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">KEYWORD_ONLY</span>
                <span class="s0">and </span><span class="s1">param</span><span class="s2">.</span><span class="s1">default </span><span class="s2">== </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">empty</span>
            <span class="s2">]</span>
            <span class="s0">if </span><span class="s1">unfulfilled_kwonlyargs</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;has mandatory keyword-only arguments in its declaration: &quot;</span>
                    <span class="s5">f'</span><span class="s0">{</span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">unfulfilled_kwonlyargs</span><span class="s2">)</span><span class="s0">}</span><span class="s5">'</span>
                <span class="s2">)</span>

            <span class="s1">num_positional_args </span><span class="s2">= </span><span class="s1">num_mandatory_pos_args </span><span class="s2">= </span><span class="s4">0</span>
            <span class="s1">has_varargs </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">signature</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">param</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s2">(</span>
                    <span class="s1">Parameter</span><span class="s2">.</span><span class="s1">POSITIONAL_ONLY</span><span class="s2">,</span>
                    <span class="s1">Parameter</span><span class="s2">.</span><span class="s1">POSITIONAL_OR_KEYWORD</span><span class="s2">,</span>
                <span class="s2">):</span>
                    <span class="s1">num_positional_args </span><span class="s2">+= </span><span class="s4">1</span>
                    <span class="s0">if </span><span class="s1">param</span><span class="s2">.</span><span class="s1">default </span><span class="s0">is </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">:</span>
                        <span class="s1">num_mandatory_pos_args </span><span class="s2">+= </span><span class="s4">1</span>
                <span class="s0">elif </span><span class="s1">param</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">VAR_POSITIONAL</span><span class="s2">:</span>
                    <span class="s1">has_varargs </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">num_mandatory_pos_args </span><span class="s2">&gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument_types</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;has too many mandatory positional arguments in its declaration; &quot;</span>
                    <span class="s5">f&quot;expected </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument_types</span><span class="s2">)</span><span class="s0">} </span><span class="s5">but </span><span class="s0">{</span><span class="s1">num_mandatory_pos_args</span><span class="s0">} </span><span class="s5">&quot;</span>
                    <span class="s5">f&quot;mandatory positional argument(s) declared&quot;</span>
                <span class="s2">)</span>
            <span class="s0">elif not </span><span class="s1">has_varargs </span><span class="s0">and </span><span class="s1">num_positional_args </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument_types</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;has too few arguments in its declaration; expected &quot;</span>
                    <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument_types</span><span class="s2">)</span><span class="s0">} </span><span class="s5">but </span><span class="s0">{</span><span class="s1">num_positional_args</span><span class="s0">} </span><span class="s5">argument(s) &quot;</span>
                    <span class="s5">f&quot;declared&quot;</span>
                <span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_mapping</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">Dict </span><span class="s0">or </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">dict</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a dict&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">MutableMapping </span><span class="s0">or </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">MutableMapping</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">MutableMapping</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a mutable mapping&quot;</span><span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a mapping&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s1">key_type</span><span class="s2">, </span><span class="s1">value_type </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">key_type </span><span class="s0">is not </span><span class="s1">Any </span><span class="s0">or </span><span class="s1">value_type </span><span class="s0">is not </span><span class="s1">Any</span><span class="s2">:</span>
            <span class="s1">samples </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">collection_check_strategy</span><span class="s2">.</span><span class="s1">iterate_samples</span><span class="s2">(</span>
                <span class="s1">value</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">key_type</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                    <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;key </span><span class="s0">{</span><span class="s1">k</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>
                    <span class="s0">raise</span>

                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">value_type</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                    <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;value of key </span><span class="s0">{</span><span class="s1">k</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>
                    <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_typed_dict</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a dict&quot;</span><span class="s2">)</span>

    <span class="s1">declared_keys </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__annotations__</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;__required_keys__&quot;</span><span class="s2">):</span>
        <span class="s1">required_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__required_keys__</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s3"># py3.8 and lower</span>
        <span class="s1">required_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">declared_keys</span><span class="s2">) </span><span class="s0">if </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__total__ </span><span class="s0">else </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s1">existing_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s1">extra_keys </span><span class="s2">= </span><span class="s1">existing_keys </span><span class="s2">- </span><span class="s1">declared_keys</span>
    <span class="s0">if </span><span class="s1">extra_keys</span><span class="s2">:</span>
        <span class="s1">keys_formatted </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">f'&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s5">&quot;' </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">extra_keys</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">repr</span><span class="s2">))</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;has unexpected extra key(s): </span><span class="s0">{</span><span class="s1">keys_formatted</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

    <span class="s3"># Detect NotRequired fields which are hidden by get_type_hints()</span>
    <span class="s1">type_hints</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">type</span><span class="s2">] = {}</span>
    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__annotations__</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">):</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">evaluate_forwardref</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">) </span><span class="s0">is </span><span class="s1">NotRequired</span><span class="s2">:</span>
                <span class="s1">required_keys</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
                <span class="s1">annotation </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>

        <span class="s1">type_hints</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">annotation</span>

    <span class="s1">missing_keys </span><span class="s2">= </span><span class="s1">required_keys </span><span class="s2">- </span><span class="s1">existing_keys</span>
    <span class="s0">if </span><span class="s1">missing_keys</span><span class="s2">:</span>
        <span class="s1">keys_formatted </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">f'&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s5">&quot;' </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">missing_keys</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">repr</span><span class="s2">))</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is missing required key(s): </span><span class="s0">{</span><span class="s1">keys_formatted</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">argtype </span><span class="s0">in </span><span class="s1">type_hints</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">argvalue </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">_missing</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">argvalue </span><span class="s0">is not </span><span class="s1">_missing</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">argvalue</span><span class="s2">, </span><span class="s1">argtype</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;value of key </span><span class="s0">{</span><span class="s1">key</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_list</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a list&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args </span><span class="s2">!= (</span><span class="s1">Any</span><span class="s2">,):</span>
        <span class="s1">samples </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">collection_check_strategy</span><span class="s2">.</span><span class="s1">iterate_samples</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">samples</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;item </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_sequence</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a sequence&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args </span><span class="s2">!= (</span><span class="s1">Any</span><span class="s2">,):</span>
        <span class="s1">samples </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">collection_check_strategy</span><span class="s2">.</span><span class="s1">iterate_samples</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">samples</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;item </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_set</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">frozenset</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">frozenset</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a frozenset&quot;</span><span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">AbstractSet</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a set&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args </span><span class="s2">!= (</span><span class="s1">Any</span><span class="s2">,):</span>
        <span class="s1">samples </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">collection_check_strategy</span><span class="s2">.</span><span class="s1">iterate_samples</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;[</span><span class="s0">{</span><span class="s1">v</span><span class="s0">}</span><span class="s5">]&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_tuple</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s3"># Specialized check for NamedTuples</span>
    <span class="s0">if </span><span class="s1">field_types </span><span class="s2">:= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;__annotations__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                <span class="s5">f&quot;is not a named tuple of type </span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">field_type </span><span class="s0">in </span><span class="s1">field_types</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">name</span><span class="s2">), </span><span class="s1">field_type</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;attribute </span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>

        <span class="s0">return</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a tuple&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s1">use_ellipsis </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">] </span><span class="s0">is </span><span class="s1">Ellipsis</span>
        <span class="s1">tuple_params </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[: -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">use_ellipsis </span><span class="s0">else None</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># Unparametrized Tuple or plain tuple</span>
        <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">use_ellipsis</span><span class="s2">:</span>
        <span class="s1">element_type </span><span class="s2">= </span><span class="s1">tuple_params</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">samples </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">collection_check_strategy</span><span class="s2">.</span><span class="s1">iterate_samples</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">element </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">samples</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">element_type</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;item </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>
    <span class="s0">elif </span><span class="s1">tuple_params </span><span class="s2">== ((),):</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s2">!= ():</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not an empty tuple&quot;</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">tuple_params</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                <span class="s5">f&quot;has wrong number of elements (expected </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">tuple_params</span><span class="s2">)</span><span class="s0">}</span><span class="s5">, got &quot;</span>
                <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span><span class="s0">} </span><span class="s5">instead)&quot;</span>
            <span class="s2">)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, (</span><span class="s1">element</span><span class="s2">, </span><span class="s1">element_type</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">tuple_params</span><span class="s2">)):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">element_type</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">append_path_element</span><span class="s2">(</span><span class="s5">f&quot;item </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">check_union</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">errors</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">TypeCheckError</span><span class="s2">] = {}</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">type_ </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
                <span class="s0">return</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">[</span><span class="s1">get_type_name</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)] = </span><span class="s1">exc</span>

        <span class="s1">formatted_errors </span><span class="s2">= </span><span class="s1">indent</span><span class="s2">(</span>
            <span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s5">: </span><span class="s0">{</span><span class="s1">error</span><span class="s0">}</span><span class="s5">&quot; </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">error </span><span class="s0">in </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()), </span><span class="s5">&quot;  &quot;</span>
        <span class="s2">)</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s0">del </span><span class="s1">errors  </span><span class="s3"># avoid creating ref cycle</span>
    <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;did not match any element in the union:</span><span class="s0">\n{</span><span class="s1">formatted_errors</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_uniontype</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">errors</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">TypeCheckError</span><span class="s2">] = {}</span>
    <span class="s0">for </span><span class="s1">type_ </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">type_</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">return</span>
        <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
            <span class="s1">errors</span><span class="s2">[</span><span class="s1">get_type_name</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">)] = </span><span class="s1">exc</span>

    <span class="s1">formatted_errors </span><span class="s2">= </span><span class="s1">indent</span><span class="s2">(</span>
        <span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s5">: </span><span class="s0">{</span><span class="s1">error</span><span class="s0">}</span><span class="s5">&quot; </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">error </span><span class="s0">in </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()), </span><span class="s5">&quot;  &quot;</span>
    <span class="s2">)</span>
    <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;did not match any element in the union:</span><span class="s0">\n{</span><span class="s1">formatted_errors</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_class</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">generic_alias_types</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a class&quot;</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">ForwardRef</span><span class="s2">):</span>
        <span class="s1">expected_class </span><span class="s2">= </span><span class="s1">evaluate_forwardref</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">memo</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">expected_class </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">expected_class </span><span class="s0">is </span><span class="s1">Any</span><span class="s2">:</span>
        <span class="s0">return</span>
    <span class="s0">elif </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">expected_class</span><span class="s2">, </span><span class="s5">&quot;_is_protocol&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
        <span class="s1">check_protocol</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">expected_class</span><span class="s2">, (), </span><span class="s1">memo</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_class</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">):</span>
        <span class="s1">check_typevar</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">expected_class</span><span class="s2">, (), </span><span class="s1">memo</span><span class="s2">, </span><span class="s1">subclass_check</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">expected_class</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Union</span><span class="s2">:</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">TypeCheckError</span><span class="s2">] = {}</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">expected_class</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is </span><span class="s1">Any</span><span class="s2">:</span>
                <span class="s0">return</span>

            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_class</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, (</span><span class="s1">arg</span><span class="s2">,), </span><span class="s1">memo</span><span class="s2">)</span>
                <span class="s0">return</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">errors</span><span class="s2">[</span><span class="s1">get_type_name</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)] = </span><span class="s1">exc</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">formatted_errors </span><span class="s2">= </span><span class="s1">indent</span><span class="s2">(</span>
                <span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s5">: </span><span class="s0">{</span><span class="s1">error</span><span class="s0">}</span><span class="s5">&quot; </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">error </span><span class="s0">in </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()), </span><span class="s5">&quot;  &quot;</span>
            <span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                <span class="s5">f&quot;did not match any element in the union:</span><span class="s0">\n{</span><span class="s1">formatted_errors</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">expected_class</span><span class="s2">):  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is not a subclass of </span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">expected_class</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_newtype</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__supertype__</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_instance</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is not an instance of </span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_typevar</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">subclass_check</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__bound__ </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">annotation </span><span class="s2">= (</span>
            <span class="s1">Type</span><span class="s2">[</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__bound__</span><span class="s2">] </span><span class="s0">if </span><span class="s1">subclass_check </span><span class="s0">else </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__bound__</span>
        <span class="s2">)</span>
        <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__constraints__</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">constraint </span><span class="s0">in </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__constraints__</span><span class="s2">:</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">constraint</span><span class="s2">] </span><span class="s0">if </span><span class="s1">subclass_check </span><span class="s0">else </span><span class="s1">constraint</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">formatted_constraints </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
                <span class="s1">get_type_name</span><span class="s2">(</span><span class="s1">constraint</span><span class="s2">) </span><span class="s0">for </span><span class="s1">constraint </span><span class="s0">in </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__constraints__</span>
            <span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                <span class="s5">f&quot;does not match any of the constraints &quot; f&quot;(</span><span class="s0">{</span><span class="s1">formatted_constraints</span><span class="s0">}</span><span class="s5">)&quot;</span>
            <span class="s2">)</span>


<span class="s0">if </span><span class="s1">typing_extensions </span><span class="s0">is None</span><span class="s2">:</span>

    <span class="s0">def </span><span class="s1">_is_literal_type</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">: </span><span class="s1">object</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Literal</span>

<span class="s0">else</span><span class="s2">:</span>

    <span class="s0">def </span><span class="s1">_is_literal_type</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">: </span><span class="s1">object</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Literal </span><span class="s0">or </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">typing_extensions</span><span class="s2">.</span><span class="s1">Literal</span>


<span class="s0">def </span><span class="s1">check_literal</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">get_literal_args</span><span class="s2">(</span><span class="s1">literal_args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]:</span>
        <span class="s1">retval</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">literal_args</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">_is_literal_type</span><span class="s2">(</span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)):</span>
                <span class="s1">retval</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">get_literal_args</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">))</span>
            <span class="s0">elif </span><span class="s1">arg </span><span class="s0">is None or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Enum</span><span class="s2">)):</span>
                <span class="s1">retval</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s5">f&quot;Illegal literal value: </span><span class="s0">{</span><span class="s1">arg</span><span class="s0">}</span><span class="s5">&quot;</span>
                <span class="s2">)  </span><span class="s3"># TypeError here is deliberate</span>

        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">)</span>

    <span class="s1">final_args </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">get_literal_args</span><span class="s2">(</span><span class="s1">args</span><span class="s2">))</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">final_args</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">final_args</span><span class="s2">[</span><span class="s1">index</span><span class="s2">]) </span><span class="s0">is </span><span class="s1">type</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
            <span class="s0">return</span>

    <span class="s1">formatted_args </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">final_args</span><span class="s2">)</span>
    <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is not any of (</span><span class="s0">{</span><span class="s1">formatted_args</span><span class="s0">}</span><span class="s5">)&quot;</span><span class="s2">) </span><span class="s0">from None</span>


<span class="s0">def </span><span class="s1">check_literal_string</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_typeguard</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">check_type_internal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_none</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">value </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not None&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_number</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">complex </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">complex</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">int</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is neither complex, float or int&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">float </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">float</span><span class="s2">, </span><span class="s1">int</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is neither float or int&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_io</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">TextIO </span><span class="s0">or </span><span class="s2">(</span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">IO </span><span class="s0">and </span><span class="s1">args </span><span class="s2">== (</span><span class="s1">str</span><span class="s2">,)):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">TextIOBase</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a text based I/O object&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">BinaryIO </span><span class="s0">or </span><span class="s2">(</span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">IO </span><span class="s0">and </span><span class="s1">args </span><span class="s2">== (</span><span class="s1">bytes</span><span class="s2">,)):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">RawIOBase</span><span class="s2">, </span><span class="s1">BufferedIOBase</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not a binary I/O object&quot;</span><span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">IOBase</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not an I/O object&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_protocol</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">subject</span><span class="s2">: </span><span class="s1">type</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">] = </span><span class="s1">value </span><span class="s0">if </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">else </span><span class="s1">type</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">subject </span><span class="s0">in </span><span class="s1">protocol_check_cache</span><span class="s2">:</span>
        <span class="s1">result_map </span><span class="s2">= </span><span class="s1">protocol_check_cache</span><span class="s2">[</span><span class="s1">subject</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">in </span><span class="s1">result_map</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">exc </span><span class="s2">:= </span><span class="s1">result_map</span><span class="s2">[</span><span class="s1">origin_type</span><span class="s2">]:</span>
                <span class="s0">raise </span><span class="s1">exc</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return</span>

    <span class="s3"># Collect a set of methods and non-method attributes present in the protocol</span>
    <span class="s1">ignored_attrs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">dir</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">)) | {</span>
        <span class="s5">&quot;__annotations__&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;__non_callable_proto_members__&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s1">expected_methods</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]] = {}</span>
    <span class="s1">expected_noncallable_members</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
    <span class="s0">for </span><span class="s1">attrname </span><span class="s0">in </span><span class="s1">dir</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">):</span>
        <span class="s3"># Skip attributes present in typing.Protocol</span>
        <span class="s0">if </span><span class="s1">attrname </span><span class="s0">in </span><span class="s1">ignored_attrs</span><span class="s2">:</span>
            <span class="s0">continue</span>

        <span class="s1">member </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s1">attrname</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">member</span><span class="s2">):</span>
            <span class="s1">signature </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">member</span><span class="s2">)</span>
            <span class="s1">argtypes </span><span class="s2">= [</span>
                <span class="s2">(</span><span class="s1">p</span><span class="s2">.</span><span class="s1">annotation </span><span class="s0">if </span><span class="s1">p</span><span class="s2">.</span><span class="s1">annotation </span><span class="s0">is not </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">empty </span><span class="s0">else </span><span class="s1">Any</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">signature</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">p</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">is not </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">KEYWORD_ONLY</span>
            <span class="s2">] </span><span class="s0">or </span><span class="s1">Ellipsis</span>
            <span class="s1">return_annotation </span><span class="s2">= (</span>
                <span class="s1">signature</span><span class="s2">.</span><span class="s1">return_annotation</span>
                <span class="s0">if </span><span class="s1">signature</span><span class="s2">.</span><span class="s1">return_annotation </span><span class="s0">is not </span><span class="s1">Parameter</span><span class="s2">.</span><span class="s1">empty</span>
                <span class="s0">else </span><span class="s1">Any</span>
            <span class="s2">)</span>
            <span class="s1">expected_methods</span><span class="s2">[</span><span class="s1">attrname</span><span class="s2">] = </span><span class="s1">argtypes</span><span class="s2">, </span><span class="s1">return_annotation</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">expected_noncallable_members</span><span class="s2">[</span><span class="s1">attrname</span><span class="s2">] = </span><span class="s1">member</span>

    <span class="s0">for </span><span class="s1">attrname</span><span class="s2">, </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_type_hints</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">).</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">expected_noncallable_members</span><span class="s2">[</span><span class="s1">attrname</span><span class="s2">] = </span><span class="s1">annotation</span>

    <span class="s1">subject_annotations </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_type_hints</span><span class="s2">(</span><span class="s1">subject</span><span class="s2">)</span>

    <span class="s3"># Check that all required methods are present and their signatures are compatible</span>
    <span class="s1">result_map </span><span class="s2">= </span><span class="s1">protocol_check_cache</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">subject</span><span class="s2">, {})</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">attrname</span><span class="s2">, </span><span class="s1">callable_args </span><span class="s0">in </span><span class="s1">expected_methods</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">method </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">subject</span><span class="s2">, </span><span class="s1">attrname</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">attrname </span><span class="s0">in </span><span class="s1">subject_annotations</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                        <span class="s5">f&quot;is not compatible with the </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">} </span><span class="s5">protocol &quot;</span>
                        <span class="s5">f&quot;because its </span><span class="s0">{</span><span class="s1">attrname</span><span class="s0">!r} </span><span class="s5">attribute is not a method&quot;</span>
                    <span class="s2">) </span><span class="s0">from None</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                        <span class="s5">f&quot;is not compatible with the </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">} </span><span class="s5">protocol &quot;</span>
                        <span class="s5">f&quot;because it has no method named </span><span class="s0">{</span><span class="s1">attrname</span><span class="s0">!r}</span><span class="s5">&quot;</span>
                    <span class="s2">) </span><span class="s0">from None</span>

            <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">method</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;is not compatible with the </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">} </span><span class="s5">protocol &quot;</span>
                    <span class="s5">f&quot;because its </span><span class="s0">{</span><span class="s1">attrname</span><span class="s0">!r} </span><span class="s5">attribute is not a callable&quot;</span>
                <span class="s2">)</span>

            <span class="s3"># TODO: raise exception on added keyword-only arguments without defaults</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_callable</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">callable_args</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;is not compatible with the </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">} </span><span class="s5">protocol &quot;</span>
                    <span class="s5">f&quot;because its </span><span class="s0">{</span><span class="s1">attrname</span><span class="s0">!r} </span><span class="s5">method </span><span class="s0">{</span><span class="s1">exc</span><span class="s0">}</span><span class="s5">&quot;</span>
                <span class="s2">) </span><span class="s0">from None</span>

        <span class="s3"># Check that all required non-callable members are present</span>
        <span class="s0">for </span><span class="s1">attrname </span><span class="s0">in </span><span class="s1">expected_noncallable_members</span><span class="s2">:</span>
            <span class="s3"># TODO: implement assignability checks for non-callable members</span>
            <span class="s0">if </span><span class="s1">attrname </span><span class="s0">not in </span><span class="s1">subject_annotations </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">subject</span><span class="s2">, </span><span class="s1">attrname</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                    <span class="s5">f&quot;is not compatible with the </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">} </span><span class="s5">protocol &quot;</span>
                    <span class="s5">f&quot;because it has no attribute named </span><span class="s0">{</span><span class="s1">attrname</span><span class="s0">!r}</span><span class="s5">&quot;</span>
                <span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeCheckError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s1">result_map</span><span class="s2">[</span><span class="s1">origin_type</span><span class="s2">] = </span><span class="s1">exc</span>
        <span class="s0">raise</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">result_map</span><span class="s2">[</span><span class="s1">origin_type</span><span class="s2">] = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">check_byteslike</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">bytearray</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">memoryview</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;is not bytes-like&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_self</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">self_type </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">&quot;cannot be checked against Self outside of a method call&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">self_type</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
                <span class="s5">f&quot;is not an instance of the self type &quot;</span>
                <span class="s5">f&quot;(</span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">self_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">)&quot;</span>
            <span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">self_type</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span>
            <span class="s5">f&quot;is not an instance of the self type (</span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">self_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">)&quot;</span>
        <span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_paramspec</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">pass  </span><span class="s3"># No-op for now</span>


<span class="s0">def </span><span class="s1">check_instanceof</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...],</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is not an instance of </span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_type_internal</span><span class="s2">(</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">annotation</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">memo</span><span class="s2">: </span><span class="s1">TypeCheckMemo</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot; 
    Check that the given object is compatible with the given type annotation. 
 
    This function should only be used by type checker callables. Applications should use 
    :func:`~.check_type` instead. 
 
    :param value: the value to check 
    :param annotation: the type annotation to check against 
    :param memo: a memo object containing configuration and information necessary for 
        looking up forward references 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">evaluate_forwardref</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">NameError</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">forward_ref_policy </span><span class="s0">is </span><span class="s1">ForwardRefPolicy</span><span class="s2">.</span><span class="s1">ERROR</span><span class="s2">:</span>
                <span class="s0">raise</span>
            <span class="s0">elif </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">forward_ref_policy </span><span class="s0">is </span><span class="s1">ForwardRefPolicy</span><span class="s2">.</span><span class="s1">WARN</span><span class="s2">:</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s5">f&quot;Cannot resolve forward reference </span><span class="s0">{</span><span class="s1">annotation</span><span class="s2">.</span><span class="s1">__forward_arg__</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">,</span>
                    <span class="s1">TypeHintWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">get_stacklevel</span><span class="s2">(),</span>
                <span class="s2">)</span>

            <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">annotation </span><span class="s0">is </span><span class="s1">Any </span><span class="s0">or </span><span class="s1">annotation </span><span class="s0">is </span><span class="s1">SubclassableAny </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">Mock</span><span class="s2">):</span>
        <span class="s0">return</span>

    <span class="s3"># Skip type checks if value is an instance of a class that inherits from Any</span>
    <span class="s0">if not </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">and </span><span class="s1">SubclassableAny </span><span class="s0">in </span><span class="s1">type</span><span class="s2">(</span><span class="s1">value</span><span class="s2">).</span><span class="s1">__bases__</span><span class="s2">:</span>
        <span class="s0">return</span>

    <span class="s1">extras</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]</span>
    <span class="s1">origin_type </span><span class="s2">= </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is </span><span class="s1">Annotated</span><span class="s2">:</span>
        <span class="s1">annotation</span><span class="s2">, *</span><span class="s1">extras_ </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>
        <span class="s1">extras </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">extras_</span><span class="s2">)</span>
        <span class="s1">origin_type </span><span class="s2">= </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">extras </span><span class="s2">= ()</span>

    <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">)</span>

        <span class="s3"># Compatibility hack to distinguish between unparametrized and empty tuple</span>
        <span class="s3"># (tuple[()]), necessary due to https://github.com/python/cpython/issues/91137</span>
        <span class="s0">if </span><span class="s1">origin_type </span><span class="s0">in </span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">annotation </span><span class="s0">is not </span><span class="s1">Tuple </span><span class="s0">and not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s1">args </span><span class="s2">= ((),)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">origin_type </span><span class="s2">= </span><span class="s1">annotation</span>
        <span class="s1">args </span><span class="s2">= ()</span>

    <span class="s0">for </span><span class="s1">lookup_func </span><span class="s0">in </span><span class="s1">checker_lookup_functions</span><span class="s2">:</span>
        <span class="s1">checker </span><span class="s2">= </span><span class="s1">lookup_func</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">extras</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">checker</span><span class="s2">:</span>
            <span class="s1">checker</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">)</span>
            <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">origin_type</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeCheckError</span><span class="s2">(</span><span class="s5">f&quot;is not an instance of </span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">type</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">) </span><span class="s0">is </span><span class="s1">str</span><span class="s2">:  </span><span class="s3"># noqa: E721</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s5">f&quot;Skipping type check against </span><span class="s0">{</span><span class="s1">origin_type</span><span class="s0">!r}</span><span class="s5">; this looks like a &quot;</span>
            <span class="s5">f&quot;string-form forward reference imported from another module&quot;</span><span class="s2">,</span>
            <span class="s1">TypeHintWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">get_stacklevel</span><span class="s2">(),</span>
        <span class="s2">)</span>


<span class="s3"># Equality checks are applied to these</span>
<span class="s1">origin_type_checkers </span><span class="s2">= {</span>
    <span class="s1">bytes</span><span class="s2">: </span><span class="s1">check_byteslike</span><span class="s2">,</span>
    <span class="s1">AbstractSet</span><span class="s2">: </span><span class="s1">check_set</span><span class="s2">,</span>
    <span class="s1">BinaryIO</span><span class="s2">: </span><span class="s1">check_io</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">: </span><span class="s1">check_callable</span><span class="s2">,</span>
    <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">: </span><span class="s1">check_callable</span><span class="s2">,</span>
    <span class="s1">complex</span><span class="s2">: </span><span class="s1">check_number</span><span class="s2">,</span>
    <span class="s1">dict</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s1">float</span><span class="s2">: </span><span class="s1">check_number</span><span class="s2">,</span>
    <span class="s1">frozenset</span><span class="s2">: </span><span class="s1">check_set</span><span class="s2">,</span>
    <span class="s1">IO</span><span class="s2">: </span><span class="s1">check_io</span><span class="s2">,</span>
    <span class="s1">list</span><span class="s2">: </span><span class="s1">check_list</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">: </span><span class="s1">check_list</span><span class="s2">,</span>
    <span class="s1">typing</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">: </span><span class="s1">check_literal</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s1">MutableMapping</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s0">None</span><span class="s2">: </span><span class="s1">check_none</span><span class="s2">,</span>
    <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">MutableMapping</span><span class="s2">: </span><span class="s1">check_mapping</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">: </span><span class="s1">check_sequence</span><span class="s2">,</span>
    <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">: </span><span class="s1">check_sequence</span><span class="s2">,</span>
    <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Set</span><span class="s2">: </span><span class="s1">check_set</span><span class="s2">,</span>
    <span class="s1">set</span><span class="s2">: </span><span class="s1">check_set</span><span class="s2">,</span>
    <span class="s1">Set</span><span class="s2">: </span><span class="s1">check_set</span><span class="s2">,</span>
    <span class="s1">TextIO</span><span class="s2">: </span><span class="s1">check_io</span><span class="s2">,</span>
    <span class="s1">tuple</span><span class="s2">: </span><span class="s1">check_tuple</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">: </span><span class="s1">check_tuple</span><span class="s2">,</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s1">check_class</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">: </span><span class="s1">check_class</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">: </span><span class="s1">check_union</span><span class="s2">,</span>
<span class="s2">}</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">):</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">] = </span><span class="s1">check_uniontype</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeGuard</span><span class="s2">] = </span><span class="s1">check_typeguard</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">11</span><span class="s2">):</span>
    <span class="s1">origin_type_checkers</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
        <span class="s2">{</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">LiteralString</span><span class="s2">: </span><span class="s1">check_literal_string</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Self</span><span class="s2">: </span><span class="s1">check_self</span><span class="s2">}</span>
    <span class="s2">)</span>
<span class="s0">if </span><span class="s1">typing_extensions </span><span class="s0">is not None</span><span class="s2">:</span>
    <span class="s3"># On some Python versions, these may simply be re-exports from typing,</span>
    <span class="s3"># but exactly which Python versions is subject to change,</span>
    <span class="s3"># so it's best to err on the safe side</span>
    <span class="s3"># and update the dictionary on all Python versions</span>
    <span class="s3"># if typing_extensions is installed</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">typing_extensions</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">] = </span><span class="s1">check_literal</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">typing_extensions</span><span class="s2">.</span><span class="s1">LiteralString</span><span class="s2">] = </span><span class="s1">check_literal_string</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">typing_extensions</span><span class="s2">.</span><span class="s1">Self</span><span class="s2">] = </span><span class="s1">check_self</span>
    <span class="s1">origin_type_checkers</span><span class="s2">[</span><span class="s1">typing_extensions</span><span class="s2">.</span><span class="s1">TypeGuard</span><span class="s2">] = </span><span class="s1">check_typeguard</span>


<span class="s0">def </span><span class="s1">builtin_checker_lookup</span><span class="s2">(</span>
    <span class="s1">origin_type</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">args</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...], </span><span class="s1">extras</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, ...]</span>
<span class="s2">) </span><span class="s1">-&gt; TypeCheckerCallable </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">checker </span><span class="s2">= </span><span class="s1">origin_type_checkers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">checker </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">checker</span>
    <span class="s0">elif </span><span class="s1">is_typeddict</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">check_typed_dict</span>
    <span class="s0">elif </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span>
        <span class="s1">origin_type</span><span class="s2">,</span>
        <span class="s1">Tuple</span><span class="s2">,  </span><span class="s3"># type: ignore[arg-type]</span>
    <span class="s2">):</span>
        <span class="s3"># NamedTuple</span>
        <span class="s0">return </span><span class="s1">check_tuple</span>
    <span class="s0">elif </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;_is_protocol&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">check_protocol</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">check_paramspec</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">check_typevar</span>
    <span class="s0">elif </span><span class="s1">origin_type</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">NewType</span><span class="s2">:</span>
        <span class="s3"># typing.NewType on Python 3.10+</span>
        <span class="s0">return </span><span class="s1">check_newtype</span>
    <span class="s0">elif </span><span class="s2">(</span>
        <span class="s1">isfunction</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;__module__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) == </span><span class="s5">&quot;typing&quot;</span>
        <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;__qualname__&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">).</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">&quot;NewType.&quot;</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">origin_type</span><span class="s2">, </span><span class="s5">&quot;__supertype__&quot;</span><span class="s2">)</span>
    <span class="s2">):</span>
        <span class="s3"># typing.NewType on Python 3.9 and below</span>
        <span class="s0">return </span><span class="s1">check_newtype</span>

    <span class="s0">return None</span>


<span class="s1">checker_lookup_functions</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">builtin_checker_lookup</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">load_plugins</span><span class="s2">() </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot; 
    Load all type checker lookup functions from entry points. 
 
    All entry points from the ``typeguard.checker_lookup`` group are loaded, and the 
    returned lookup functions are added to :data:`typeguard.checker_lookup_functions`. 
 
    .. note:: This function is called implicitly on import, unless the 
        ``TYPEGUARD_DISABLE_PLUGIN_AUTOLOAD`` environment variable is present. 
    &quot;&quot;&quot;</span>

    <span class="s0">for </span><span class="s1">ep </span><span class="s0">in </span><span class="s1">entry_points</span><span class="s2">(</span><span class="s1">group</span><span class="s2">=</span><span class="s5">&quot;typeguard.checker_lookup&quot;</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">plugin </span><span class="s2">= </span><span class="s1">ep</span><span class="s2">.</span><span class="s1">load</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s5">f&quot;Failed to load plugin </span><span class="s0">{</span><span class="s1">ep</span><span class="s2">.</span><span class="s1">name</span><span class="s0">!r}</span><span class="s5">: &quot; f&quot;</span><span class="s0">{</span><span class="s1">qualified_name</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">)</span><span class="s0">}</span><span class="s5">: </span><span class="s0">{</span><span class="s1">exc</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s0">continue</span>

        <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">plugin</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s5">f&quot;Plugin </span><span class="s0">{</span><span class="s1">ep</span><span class="s0">} </span><span class="s5">returned a non-callable object: </span><span class="s0">{</span><span class="s1">plugin</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span>
            <span class="s2">)</span>
            <span class="s0">continue</span>

        <span class="s1">checker_lookup_functions</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">)</span>
</pre>
</body>
</html>