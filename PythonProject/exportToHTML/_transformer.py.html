<html>
<head>
<title>_transformer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_transformer.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">ast</span>
<span class="s0">import </span><span class="s1">builtins</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">from </span><span class="s1">ast </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">AST</span><span class="s2">,</span>
    <span class="s1">Add</span><span class="s2">,</span>
    <span class="s1">AnnAssign</span><span class="s2">,</span>
    <span class="s1">Assign</span><span class="s2">,</span>
    <span class="s1">AsyncFunctionDef</span><span class="s2">,</span>
    <span class="s1">Attribute</span><span class="s2">,</span>
    <span class="s1">AugAssign</span><span class="s2">,</span>
    <span class="s1">BinOp</span><span class="s2">,</span>
    <span class="s1">BitAnd</span><span class="s2">,</span>
    <span class="s1">BitOr</span><span class="s2">,</span>
    <span class="s1">BitXor</span><span class="s2">,</span>
    <span class="s1">Call</span><span class="s2">,</span>
    <span class="s1">ClassDef</span><span class="s2">,</span>
    <span class="s1">Constant</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Div</span><span class="s2">,</span>
    <span class="s1">Expr</span><span class="s2">,</span>
    <span class="s1">Expression</span><span class="s2">,</span>
    <span class="s1">FloorDiv</span><span class="s2">,</span>
    <span class="s1">FunctionDef</span><span class="s2">,</span>
    <span class="s1">If</span><span class="s2">,</span>
    <span class="s1">Import</span><span class="s2">,</span>
    <span class="s1">ImportFrom</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Load</span><span class="s2">,</span>
    <span class="s1">LShift</span><span class="s2">,</span>
    <span class="s1">MatMult</span><span class="s2">,</span>
    <span class="s1">Mod</span><span class="s2">,</span>
    <span class="s1">Module</span><span class="s2">,</span>
    <span class="s1">Mult</span><span class="s2">,</span>
    <span class="s1">Name</span><span class="s2">,</span>
    <span class="s1">NamedExpr</span><span class="s2">,</span>
    <span class="s1">NodeTransformer</span><span class="s2">,</span>
    <span class="s1">NodeVisitor</span><span class="s2">,</span>
    <span class="s1">Pass</span><span class="s2">,</span>
    <span class="s1">Pow</span><span class="s2">,</span>
    <span class="s1">Return</span><span class="s2">,</span>
    <span class="s1">RShift</span><span class="s2">,</span>
    <span class="s1">Starred</span><span class="s2">,</span>
    <span class="s1">Store</span><span class="s2">,</span>
    <span class="s1">Sub</span><span class="s2">,</span>
    <span class="s1">Subscript</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Yield</span><span class="s2">,</span>
    <span class="s1">YieldFrom</span><span class="s2">,</span>
    <span class="s1">alias</span><span class="s2">,</span>
    <span class="s1">copy_location</span><span class="s2">,</span>
    <span class="s1">expr</span><span class="s2">,</span>
    <span class="s1">fix_missing_locations</span><span class="s2">,</span>
    <span class="s1">keyword</span><span class="s2">,</span>
    <span class="s1">walk</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Generator</span><span class="s2">, </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span><span class="s2">, </span><span class="s1">field</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">ClassVar</span><span class="s2">, </span><span class="s1">cast</span><span class="s2">, </span><span class="s1">overload</span>

<span class="s1">generator_names </span><span class="s2">= (</span>
    <span class="s3">&quot;typing.Generator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.Generator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing.Iterator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.Iterator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing.Iterable&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.Iterable&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing.AsyncIterator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.AsyncIterator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing.AsyncIterable&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.AsyncIterable&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing.AsyncGenerator&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;collections.abc.AsyncGenerator&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s1">anytype_names </span><span class="s2">= (</span>
    <span class="s3">&quot;typing.Any&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing_extensions.Any&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s1">literal_names </span><span class="s2">= (</span>
    <span class="s3">&quot;typing.Literal&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing_extensions.Literal&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s1">annotated_names </span><span class="s2">= (</span>
    <span class="s3">&quot;typing.Annotated&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing_extensions.Annotated&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s1">ignore_decorators </span><span class="s2">= (</span>
    <span class="s3">&quot;typing.no_type_check&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typeguard.typeguard_ignore&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s1">aug_assign_functions </span><span class="s2">= {</span>
    <span class="s1">Add</span><span class="s2">: </span><span class="s3">&quot;iadd&quot;</span><span class="s2">,</span>
    <span class="s1">Sub</span><span class="s2">: </span><span class="s3">&quot;isub&quot;</span><span class="s2">,</span>
    <span class="s1">Mult</span><span class="s2">: </span><span class="s3">&quot;imul&quot;</span><span class="s2">,</span>
    <span class="s1">MatMult</span><span class="s2">: </span><span class="s3">&quot;imatmul&quot;</span><span class="s2">,</span>
    <span class="s1">Div</span><span class="s2">: </span><span class="s3">&quot;itruediv&quot;</span><span class="s2">,</span>
    <span class="s1">FloorDiv</span><span class="s2">: </span><span class="s3">&quot;ifloordiv&quot;</span><span class="s2">,</span>
    <span class="s1">Mod</span><span class="s2">: </span><span class="s3">&quot;imod&quot;</span><span class="s2">,</span>
    <span class="s1">Pow</span><span class="s2">: </span><span class="s3">&quot;ipow&quot;</span><span class="s2">,</span>
    <span class="s1">LShift</span><span class="s2">: </span><span class="s3">&quot;ilshift&quot;</span><span class="s2">,</span>
    <span class="s1">RShift</span><span class="s2">: </span><span class="s3">&quot;irshift&quot;</span><span class="s2">,</span>
    <span class="s1">BitAnd</span><span class="s2">: </span><span class="s3">&quot;iand&quot;</span><span class="s2">,</span>
    <span class="s1">BitXor</span><span class="s2">: </span><span class="s3">&quot;ixor&quot;</span><span class="s2">,</span>
    <span class="s1">BitOr</span><span class="s2">: </span><span class="s3">&quot;ior&quot;</span><span class="s2">,</span>
<span class="s2">}</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">TransformMemo</span><span class="s2">:</span>
    <span class="s1">node</span><span class="s2">: </span><span class="s1">Module </span><span class="s2">| </span><span class="s1">ClassDef </span><span class="s2">| </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef </span><span class="s2">| </span><span class="s0">None</span>
    <span class="s1">parent</span><span class="s2">: </span><span class="s1">TransformMemo </span><span class="s2">| </span><span class="s0">None</span>
    <span class="s1">path</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...]</span>
    <span class="s1">joined_path</span><span class="s2">: </span><span class="s1">Constant </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">return_annotation</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">yield_annotation</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">send_annotation</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">is_async</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">local_names</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s1">set</span><span class="s2">)</span>
    <span class="s1">imported_names</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">)</span>
    <span class="s1">ignored_names</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s1">set</span><span class="s2">)</span>
    <span class="s1">load_names</span><span class="s2">: </span><span class="s1">defaultdict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">]] = </span><span class="s1">field</span><span class="s2">(</span>
        <span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">dict</span><span class="s2">)</span>
    <span class="s2">)</span>
    <span class="s1">has_yield_expressions</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">has_return_expressions</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">memo_var_name</span><span class="s2">: </span><span class="s1">Name </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">should_instrument</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">variable_annotations</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">)</span>
    <span class="s1">configuration_overrides</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default_factory</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">)</span>
    <span class="s1">code_inject_index</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__post_init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">elements</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = []</span>
        <span class="s1">memo </span><span class="s2">= </span><span class="s1">self</span>
        <span class="s0">while </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">ClassDef</span><span class="s2">, </span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)):</span>
            <span class="s1">elements</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">:</span>
                <span class="s0">break</span>

            <span class="s1">memo </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">parent</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)):</span>
                <span class="s1">elements</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;&lt;locals&gt;&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">joined_path </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s3">&quot;.&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">))</span>

        <span class="s5"># Figure out where to insert instrumentation code</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">node</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">child </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">child</span><span class="s2">, </span><span class="s1">ImportFrom</span><span class="s2">) </span><span class="s0">and </span><span class="s1">child</span><span class="s2">.</span><span class="s1">module </span><span class="s2">== </span><span class="s3">&quot;__future__&quot;</span><span class="s2">:</span>
                    <span class="s5"># (module only) __future__ imports must come first</span>
                    <span class="s0">continue</span>
                <span class="s0">elif </span><span class="s2">(</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">child</span><span class="s2">, </span><span class="s1">Expr</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">child</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">child</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s0">continue  </span><span class="s5"># docstring</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">code_inject_index </span><span class="s2">= </span><span class="s1">index</span>
                <span class="s0">break</span>

    <span class="s0">def </span><span class="s1">get_unused_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s1">memo</span><span class="s2">: </span><span class="s1">TransformMemo </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s1">self</span>
        <span class="s0">while </span><span class="s1">memo </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">:</span>
                <span class="s1">memo </span><span class="s2">= </span><span class="s1">self</span>
                <span class="s1">name </span><span class="s2">+= </span><span class="s3">&quot;_&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">memo </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">parent</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s1">Expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s1">top_expression </span><span class="s2">= (</span>
            <span class="s1">expression</span><span class="s2">.</span><span class="s1">value </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">else </span><span class="s1">expression</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Attribute</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">top_expression</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">Name</span>
        <span class="s2">):</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">id</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s1">memo</span><span class="s2">: </span><span class="s1">TransformMemo </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s1">self</span>
        <span class="s0">while </span><span class="s1">memo </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">:</span>
                <span class="s0">return True</span>

            <span class="s1">memo </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">parent</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">get_memo_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Name</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">memo_var_name</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">memo_var_name </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s3">&quot;memo&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">memo_var_name</span>

    <span class="s0">def </span><span class="s1">get_import</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Name</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">module </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names </span><span class="s0">and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names</span><span class="s2">[</span><span class="s1">module</span><span class="s2">]:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names</span><span class="s2">[</span><span class="s1">module</span><span class="s2">][</span><span class="s1">name</span><span class="s2">]</span>

        <span class="s1">qualified_name </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">module</span><span class="s0">}</span><span class="s3">.</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imported_names </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] == </span><span class="s1">qualified_name</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>

        <span class="s1">alias </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_unused_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names</span><span class="s2">[</span><span class="s1">module</span><span class="s2">][</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s1">alias</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">qualified_name</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">insert_imports</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Module </span><span class="s2">| </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Insert imports needed by injected code.&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names</span><span class="s2">:</span>
            <span class="s0">return</span>

        <span class="s5"># Insert imports after any &quot;from __future__ ...&quot; imports and any docstring</span>
        <span class="s0">for </span><span class="s1">modulename</span><span class="s2">, </span><span class="s1">names </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">load_names</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">aliases </span><span class="s2">= [</span>
                <span class="s1">alias</span><span class="s2">(</span><span class="s1">orig_name</span><span class="s2">, </span><span class="s1">new_name</span><span class="s2">.</span><span class="s1">id </span><span class="s0">if </span><span class="s1">orig_name </span><span class="s2">!= </span><span class="s1">new_name</span><span class="s2">.</span><span class="s1">id </span><span class="s0">else None</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">orig_name</span><span class="s2">, </span><span class="s1">new_name </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">names</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
            <span class="s2">]</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">code_inject_index</span><span class="s2">, </span><span class="s1">ImportFrom</span><span class="s2">(</span><span class="s1">modulename</span><span class="s2">, </span><span class="s1">aliases</span><span class="s2">, </span><span class="s4">0</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s1">Expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">, *</span><span class="s1">names</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">expression </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s1">path</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = []</span>
        <span class="s1">top_expression </span><span class="s2">= (</span>
            <span class="s1">expression</span><span class="s2">.</span><span class="s1">value </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">else </span><span class="s1">expression</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Subscript</span><span class="s2">):</span>
            <span class="s1">top_expression </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">value</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Call</span><span class="s2">):</span>
            <span class="s1">top_expression </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">func</span>

        <span class="s0">while </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Attribute</span><span class="s2">):</span>
            <span class="s1">path</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s1">top_expression </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">value</span>

        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">top_expression</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">:</span>
            <span class="s1">translated </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">[</span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id</span><span class="s2">]</span>
        <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">builtins</span><span class="s2">, </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id</span><span class="s2">):</span>
            <span class="s1">translated </span><span class="s2">= </span><span class="s3">&quot;builtins.&quot; </span><span class="s2">+ </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">translated </span><span class="s2">= </span><span class="s1">top_expression</span><span class="s2">.</span><span class="s1">id</span>

        <span class="s1">path</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">translated</span><span class="s2">)</span>
        <span class="s1">joined_path </span><span class="s2">= </span><span class="s3">&quot;.&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">path</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">joined_path </span><span class="s0">in </span><span class="s1">names</span><span class="s2">:</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, *</span><span class="s1">names</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">get_config_keywords</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">keyword</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, </span><span class="s1">ClassDef</span><span class="s2">):</span>
            <span class="s1">overrides </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">configuration_overrides</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">overrides </span><span class="s2">= {}</span>

        <span class="s1">overrides</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">configuration_overrides</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">keyword</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">) </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">overrides</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()]</span>


<span class="s0">class </span><span class="s1">NameCollector</span><span class="s2">(</span><span class="s1">NodeVisitor</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">visit_Import</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Import</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">names</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">.</span><span class="s1">asname </span><span class="s0">or </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">visit_ImportFrom</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportFrom</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">names</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">.</span><span class="s1">asname </span><span class="s0">or </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">visit_Assign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Assign</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">target </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">targets</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">visit_NamedExpr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedExpr</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">visit_FunctionDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDef</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">visit_ClassDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDef</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">GeneratorDetector</span><span class="s2">(</span><span class="s1">NodeVisitor</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Detects if a function node is a generator function.&quot;&quot;&quot;</span>

    <span class="s1">contains_yields</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">in_root_function</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">visit_Yield</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Yield</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">contains_yields </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">visit_YieldFrom</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">YieldFrom</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">contains_yields </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">visit_ClassDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDef</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">visit_FunctionDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">in_root_function</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">in_root_function </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">in_root_function </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">visit_AsyncFunctionDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AsyncFunctionDef</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">visit_FunctionDef</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">AnnotationTransformer</span><span class="s2">(</span><span class="s1">NodeTransformer</span><span class="s2">):</span>
    <span class="s1">type_substitutions</span><span class="s2">: </span><span class="s1">ClassVar</span><span class="s2">[</span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]]] = {</span>
        <span class="s3">&quot;builtins.dict&quot;</span><span class="s2">: (</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Dict&quot;</span><span class="s2">),</span>
        <span class="s3">&quot;builtins.list&quot;</span><span class="s2">: (</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;List&quot;</span><span class="s2">),</span>
        <span class="s3">&quot;builtins.tuple&quot;</span><span class="s2">: (</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Tuple&quot;</span><span class="s2">),</span>
        <span class="s3">&quot;builtins.set&quot;</span><span class="s2">: (</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Set&quot;</span><span class="s2">),</span>
        <span class="s3">&quot;builtins.frozenset&quot;</span><span class="s2">: (</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;FrozenSet&quot;</span><span class="s2">),</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">transformer</span><span class="s2">: </span><span class="s1">TypeguardTransformer</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">transformer </span><span class="s2">= </span><span class="s1">transformer</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s2">= </span><span class="s1">transformer</span><span class="s2">.</span><span class="s1">_memo</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_level </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s0">def </span><span class="s1">visit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AST</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s5"># Don't process Literals</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, *</span><span class="s1">literal_names</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">node</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_level </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s1">new_node </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_level </span><span class="s2">-= </span><span class="s4">1</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">, </span><span class="s1">Expression</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s5"># Return None if this new node matches a variation of typing.Any</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_level </span><span class="s2">== </span><span class="s4">0</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">, *</span><span class="s1">anytype_names</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s0">return </span><span class="s1">new_node</span>

    <span class="s0">def </span><span class="s1">visit_BinOp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">BinOp</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">op</span><span class="s2">, </span><span class="s1">BitOr</span><span class="s2">):</span>
            <span class="s5"># If either branch of the BinOp has been transformed to `None`, it means</span>
            <span class="s5"># that a type in the union was ignored, so the entire annotation should e</span>
            <span class="s5"># ignored</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;left&quot;</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s2">):</span>
                <span class="s0">return None</span>

            <span class="s5"># Return Any if either side is Any</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">left</span><span class="s2">, *</span><span class="s1">anytype_names</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">left</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">right</span><span class="s2">, *</span><span class="s1">anytype_names</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">right</span>

            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">):</span>
                <span class="s1">union_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transformer</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Union&quot;</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">Subscript</span><span class="s2">(</span>
                    <span class="s1">value</span><span class="s2">=</span><span class="s1">union_name</span><span class="s2">,</span>
                    <span class="s1">slice</span><span class="s2">=</span><span class="s1">Index</span><span class="s2">(</span>
                        <span class="s1">Tuple</span><span class="s2">(</span><span class="s1">elts</span><span class="s2">=[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">left</span><span class="s2">, </span><span class="s1">node</span><span class="s2">.</span><span class="s1">right</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()), </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()</span>
                    <span class="s2">),</span>
                    <span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">(),</span>
                <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Attribute</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Attribute</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">node</span><span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Subscript</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Subscript</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s5"># The subscript of typing(_extensions).Literal can be any arbitrary string, so</span>
        <span class="s5"># don't try to evaluate it as code</span>
        <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">):</span>
                <span class="s5"># Python 3.8</span>
                <span class="s1">slice_value </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">.</span><span class="s1">value  </span><span class="s5"># type: ignore[attr-defined]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">slice_value </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">slice</span>

            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">slice_value</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, *</span><span class="s1">annotated_names</span><span class="s2">):</span>
                    <span class="s5"># Only treat the first argument to typing.Annotated as a potential</span>
                    <span class="s5"># forward reference</span>
                    <span class="s1">items </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span>
                        <span class="s1">typing</span><span class="s2">.</span><span class="s1">List</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">],</span>
                        <span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">slice_value</span><span class="s2">.</span><span class="s1">elts</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])] + </span><span class="s1">slice_value</span><span class="s2">.</span><span class="s1">elts</span><span class="s2">[</span><span class="s4">1</span><span class="s2">:],</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">items </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span>
                        <span class="s1">typing</span><span class="s2">.</span><span class="s1">List</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">],</span>
                        <span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">item</span><span class="s2">) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">slice_value</span><span class="s2">.</span><span class="s1">elts</span><span class="s2">],</span>
                    <span class="s2">)</span>

                <span class="s5"># If this is a Union and any of the items is Any, erase the entire</span>
                <span class="s5"># annotation</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s3">&quot;typing.Union&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">any</span><span class="s2">(</span>
                    <span class="s1">item </span><span class="s0">is None</span>
                    <span class="s0">or </span><span class="s2">(</span>
                        <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">)</span>
                        <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, *</span><span class="s1">anytype_names</span><span class="s2">)</span>
                    <span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items</span>
                <span class="s2">):</span>
                    <span class="s0">return None</span>

                <span class="s5"># If all items in the subscript were Any, erase the subscript entirely</span>
                <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">item </span><span class="s0">is None for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span>

                <span class="s0">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">items</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">item </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s1">items</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transformer</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Any&quot;</span><span class="s2">)</span>

                <span class="s1">slice_value</span><span class="s2">.</span><span class="s1">elts </span><span class="s2">= </span><span class="s1">items</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

                <span class="s5"># If the transformer erased the slice entirely, just return the node</span>
                <span class="s5"># value without the subscript (unless it's Optional, in which case erase</span>
                <span class="s5"># the node entirely</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s3">&quot;typing.Optional&quot;</span>
                <span class="s2">) </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;slice&quot;</span><span class="s2">):</span>
                    <span class="s0">return None</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;slice&quot;</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span>
                <span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Name</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">node</span><span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">substitute </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type_substitutions</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">):</span>
                    <span class="s1">new_node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transformer</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(*</span><span class="s1">substitute</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">copy_location</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">, </span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Call</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s5"># Don't recurse into calls</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Constant</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Constant</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">expression </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">.</span><span class="s1">parse</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">&quot;eval&quot;</span><span class="s2">)</span>
            <span class="s1">new_node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">new_node</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">copy_location</span><span class="s2">(</span><span class="s1">new_node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">, </span><span class="s1">node</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return None</span>

        <span class="s0">return </span><span class="s1">node</span>


<span class="s0">class </span><span class="s1">TypeguardTransformer</span><span class="s2">(</span><span class="s1">NodeTransformer</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">target_path</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">target_lineno</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">target_path</span><span class="s2">) </span><span class="s0">if </span><span class="s1">target_path </span><span class="s0">else None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_module_memo </span><span class="s2">= </span><span class="s1">TransformMemo</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, ())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names_used_in_annotations</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_node</span><span class="s2">: </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_lineno </span><span class="s2">= </span><span class="s1">target_lineno</span>

    <span class="s0">def </span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AST</span><span class="s2">) </span><span class="s1">-&gt; AST</span><span class="s2">:</span>
        <span class="s1">has_non_empty_body_initially </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>
        <span class="s1">initial_type </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s1">node </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">type</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) </span><span class="s0">is </span><span class="s1">initial_type</span>
            <span class="s0">and </span><span class="s1">has_non_empty_body_initially</span>
            <span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s3">&quot;body&quot;</span><span class="s2">)</span>
            <span class="s0">and not </span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span>
        <span class="s2">):</span>
            <span class="s5"># If we have still the same node type after transformation</span>
            <span class="s5"># but we've optimised it's body away, we add a `pass` statement.</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= [</span><span class="s1">Pass</span><span class="s2">()]</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s2">@</span><span class="s1">contextmanager</span>
    <span class="s0">def </span><span class="s1">_use_memo</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDef </span><span class="s2">| </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef</span>
    <span class="s2">) </span><span class="s1">-&gt; Generator</span><span class="s2">[</span><span class="s0">None</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s1">new_memo </span><span class="s2">= </span><span class="s1">TransformMemo</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">path </span><span class="s2">+ (</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,))</span>
        <span class="s1">old_memo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s2">= </span><span class="s1">new_memo</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)):</span>
            <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">should_instrument </span><span class="s2">= (</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">is None or </span><span class="s1">new_memo</span><span class="s2">.</span><span class="s1">path </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">new_memo</span><span class="s2">.</span><span class="s1">should_instrument</span><span class="s2">:</span>
                <span class="s5"># Check if the function is a generator function</span>
                <span class="s1">detector </span><span class="s2">= </span><span class="s1">GeneratorDetector</span><span class="s2">()</span>
                <span class="s1">detector</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

                <span class="s5"># Extract yield, send and return types where possible from a subscripted</span>
                <span class="s5"># annotation like Generator[int, str, bool]</span>
                <span class="s1">return_annotation </span><span class="s2">= </span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">returns</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">detector</span><span class="s2">.</span><span class="s1">contains_yields </span><span class="s0">and </span><span class="s1">new_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span>
                    <span class="s1">return_annotation</span><span class="s2">, *</span><span class="s1">generator_names</span>
                <span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">return_annotation</span><span class="s2">, </span><span class="s1">Subscript</span><span class="s2">):</span>
                        <span class="s1">annotation_slice </span><span class="s2">= </span><span class="s1">return_annotation</span><span class="s2">.</span><span class="s1">slice</span>

                        <span class="s5"># Python &lt; 3.9</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation_slice</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">):</span>
                            <span class="s1">annotation_slice </span><span class="s2">= (</span>
                                <span class="s1">annotation_slice</span><span class="s2">.</span><span class="s1">value  </span><span class="s5"># type: ignore[attr-defined]</span>
                            <span class="s2">)</span>

                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotation_slice</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">):</span>
                            <span class="s1">items </span><span class="s2">= </span><span class="s1">annotation_slice</span><span class="s2">.</span><span class="s1">elts</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">items </span><span class="s2">= [</span><span class="s1">annotation_slice</span><span class="s2">]</span>

                        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items</span><span class="s2">) &gt; </span><span class="s4">0</span><span class="s2">:</span>
                            <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">yield_annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span>
                                <span class="s1">items</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
                            <span class="s2">)</span>

                        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
                            <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">send_annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span>
                                <span class="s1">items</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
                            <span class="s2">)</span>

                        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items</span><span class="s2">) &gt; </span><span class="s4">2</span><span class="s2">:</span>
                            <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">return_annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span>
                                <span class="s1">items</span><span class="s2">[</span><span class="s4">2</span><span class="s2">]</span>
                            <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">return_annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span>
                        <span class="s1">return_annotation</span>
                    <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">):</span>
            <span class="s1">new_memo</span><span class="s2">.</span><span class="s1">is_async </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">yield</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s2">= </span><span class="s1">old_memo</span>

    <span class="s0">def </span><span class="s1">_get_import</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Name</span><span class="s2">:</span>
        <span class="s1">memo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_module_memo</span>
        <span class="s0">return </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">get_import</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">: </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">: ...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">: </span><span class="s1">expr</span><span class="s2">) </span><span class="s1">-&gt; expr</span><span class="s2">: ...</span>

    <span class="s0">def </span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">: </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">annotation </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return None</span>

        <span class="s5"># Convert PEP 604 unions (x | y) and generic built-in collections where</span>
        <span class="s5"># necessary, and undo forward references</span>
        <span class="s1">new_annotation </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">AnnotationTransformer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">annotation</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new_annotation</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>
            <span class="s1">new_annotation </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">.</span><span class="s1">copy_location</span><span class="s2">(</span><span class="s1">new_annotation</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">)</span>

            <span class="s5"># Store names used in the annotation</span>
            <span class="s1">names </span><span class="s2">= {</span><span class="s1">node</span><span class="s2">.</span><span class="s1">id </span><span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">walk</span><span class="s2">(</span><span class="s1">new_annotation</span><span class="s2">) </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">)}</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">names_used_in_annotations</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">names</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">new_annotation</span>

    <span class="s0">def </span><span class="s1">visit_Name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Name</span><span class="s2">) </span><span class="s1">-&gt; Name</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Module</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Module</span><span class="s2">) </span><span class="s1">-&gt; Module</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_module_memo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s2">= </span><span class="s1">TransformMemo</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, ())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_module_memo</span><span class="s2">.</span><span class="s1">insert_imports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s1">fix_missing_locations</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Import</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Import</span><span class="s2">) </span><span class="s1">-&gt; Import</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">names</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">.</span><span class="s1">asname </span><span class="s0">or </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">[</span><span class="s1">name</span><span class="s2">.</span><span class="s1">asname </span><span class="s0">or </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_ImportFrom</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportFrom</span><span class="s2">) </span><span class="s1">-&gt; ImportFrom</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">names</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s3">&quot;*&quot;</span><span class="s2">:</span>
                <span class="s1">alias </span><span class="s2">= </span><span class="s1">name</span><span class="s2">.</span><span class="s1">asname </span><span class="s0">or </span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">alias</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">imported_names</span><span class="s2">[</span><span class="s1">alias</span><span class="s2">] = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">node</span><span class="s2">.</span><span class="s1">module</span><span class="s0">}</span><span class="s3">.</span><span class="s0">{</span><span class="s1">name</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot;</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_ClassDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDef</span><span class="s2">) </span><span class="s1">-&gt; ClassDef </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s5"># Eliminate top level classes not belonging to the target path</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">path</span>
            <span class="s0">and </span><span class="s1">node</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_memo</span><span class="s2">(</span><span class="s1">node</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">decorator </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s3">&quot;typeguard.typechecked&quot;</span><span class="s2">):</span>
                    <span class="s5"># Remove the decorator to prevent duplicate instrumentation</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">)</span>

                    <span class="s5"># Store any configuration overrides</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s1">Call</span><span class="s2">) </span><span class="s0">and </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">keywords</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">configuration_overrides</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
                            <span class="s2">{</span><span class="s1">kw</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">kw</span><span class="s2">.</span><span class="s1">value </span><span class="s0">for </span><span class="s1">kw </span><span class="s0">in </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">keywords </span><span class="s0">if </span><span class="s1">kw</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">}</span>
                        <span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_FunctionDef</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef</span>
    <span class="s2">) </span><span class="s1">-&gt; FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        Injects type checks for function arguments, and for a return of None if the 
        function is annotated to return something else than Any or None, and the body 
        ends without an explicit &quot;return&quot;. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">local_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s5"># Eliminate top level functions not belonging to the target path</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">path</span>
            <span class="s0">and </span><span class="s1">node</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s2">):</span>
            <span class="s0">return None</span>

        <span class="s5"># Skip instrumentation if we're instrumenting the whole module and the function</span>
        <span class="s5"># contains either @no_type_check or @typeguard_ignore</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">decorator </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, *</span><span class="s1">ignore_decorators</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">node</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_memo</span><span class="s2">(</span><span class="s1">node</span><span class="s2">):</span>
            <span class="s1">arg_annotations</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path </span><span class="s0">is None or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">path </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_target_path</span><span class="s2">:</span>
                <span class="s5"># Find line number we're supposed to match against</span>
                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">:</span>
                    <span class="s1">first_lineno </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">lineno</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">first_lineno </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">lineno</span>

                <span class="s0">for </span><span class="s1">decorator </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">():</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s3">&quot;typing.overload&quot;</span><span class="s2">):</span>
                        <span class="s5"># Remove overloads entirely</span>
                        <span class="s0">return None</span>
                    <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s3">&quot;typeguard.typechecked&quot;</span><span class="s2">):</span>
                        <span class="s5"># Remove the decorator to prevent duplicate instrumentation</span>
                        <span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">)</span>

                        <span class="s5"># Store any configuration overrides</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s1">Call</span><span class="s2">) </span><span class="s0">and </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">keywords</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">configuration_overrides </span><span class="s2">= {</span>
                                <span class="s1">kw</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">kw</span><span class="s2">.</span><span class="s1">value </span><span class="s0">for </span><span class="s1">kw </span><span class="s0">in </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">keywords </span><span class="s0">if </span><span class="s1">kw</span><span class="s2">.</span><span class="s1">arg</span>
                            <span class="s2">}</span>

                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_lineno </span><span class="s2">== </span><span class="s1">first_lineno</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_node </span><span class="s0">is None</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">target_node </span><span class="s2">= </span><span class="s1">node</span>
                    <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_lineno </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">lineno</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_lineno </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">lineno</span>

                <span class="s1">all_args </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args </span><span class="s2">+ </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwonlyargs </span><span class="s2">+ </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">posonlyargs</span>

                <span class="s5"># Ensure that any type shadowed by the positional or keyword-only</span>
                <span class="s5"># argument names are ignored in this function</span>
                <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">all_args</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">)</span>

                <span class="s5"># Ensure that any type shadowed by the variable positional argument name</span>
                <span class="s5"># (e.g. &quot;args&quot; in *args) is ignored this function</span>
                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">vararg</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">vararg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">)</span>

                <span class="s5"># Ensure that any type shadowed by the variable keywrod argument name</span>
                <span class="s5"># (e.g. &quot;kwargs&quot; in *kwargs) is ignored this function</span>
                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwarg</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwarg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">)</span>

                <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">all_args</span><span class="s2">:</span>
                    <span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">annotation</span><span class="s2">))</span>
                    <span class="s0">if </span><span class="s1">annotation</span><span class="s2">:</span>
                        <span class="s1">arg_annotations</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">annotation</span>

                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">vararg</span><span class="s2">:</span>
                    <span class="s1">annotation_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">vararg</span><span class="s2">.</span><span class="s1">annotation</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">annotation_</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
                            <span class="s1">container </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s3">&quot;tuple&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">container </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Tuple&quot;</span><span class="s2">)</span>

                        <span class="s1">subscript_slice</span><span class="s2">: </span><span class="s1">Tuple </span><span class="s2">| </span><span class="s1">Index </span><span class="s2">= </span><span class="s1">Tuple</span><span class="s2">(</span>
                            <span class="s2">[</span>
                                <span class="s1">annotation_</span><span class="s2">,</span>
                                <span class="s1">Constant</span><span class="s2">(</span><span class="s1">Ellipsis</span><span class="s2">),</span>
                            <span class="s2">],</span>
                            <span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">(),</span>
                        <span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
                            <span class="s1">subscript_slice </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">subscript_slice</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>

                        <span class="s1">arg_annotations</span><span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">vararg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">Subscript</span><span class="s2">(</span>
                            <span class="s1">container</span><span class="s2">, </span><span class="s1">subscript_slice</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()</span>
                        <span class="s2">)</span>

                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwarg</span><span class="s2">:</span>
                    <span class="s1">annotation_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwarg</span><span class="s2">.</span><span class="s1">annotation</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">annotation_</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
                            <span class="s1">container </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s3">&quot;dict&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">container </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Dict&quot;</span><span class="s2">)</span>

                        <span class="s1">subscript_slice </span><span class="s2">= </span><span class="s1">Tuple</span><span class="s2">(</span>
                            <span class="s2">[</span>
                                <span class="s1">Name</span><span class="s2">(</span><span class="s3">&quot;str&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()),</span>
                                <span class="s1">annotation_</span><span class="s2">,</span>
                            <span class="s2">],</span>
                            <span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">(),</span>
                        <span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">):</span>
                            <span class="s1">subscript_slice </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">subscript_slice</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>

                        <span class="s1">arg_annotations</span><span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">kwarg</span><span class="s2">.</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">Subscript</span><span class="s2">(</span>
                            <span class="s1">container</span><span class="s2">, </span><span class="s1">subscript_slice</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()</span>
                        <span class="s2">)</span>

                <span class="s0">if </span><span class="s1">arg_annotations</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">variable_annotations</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">arg_annotations</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">arg_annotations</span><span class="s2">:</span>
                <span class="s1">annotations_dict </span><span class="s2">= </span><span class="s1">Dict</span><span class="s2">(</span>
                    <span class="s1">keys</span><span class="s2">=[</span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">arg_annotations</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()],</span>
                    <span class="s1">values</span><span class="s2">=[</span>
                        <span class="s1">Tuple</span><span class="s2">([</span><span class="s1">Name</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()), </span><span class="s1">annotation</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>
                        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">annotation </span><span class="s0">in </span><span class="s1">arg_annotations</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                    <span class="s2">],</span>
                <span class="s2">)</span>
                <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                    <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_argument_types&quot;</span>
                <span class="s2">)</span>
                <span class="s1">args </span><span class="s2">= [</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">joined_path</span><span class="s2">,</span>
                    <span class="s1">annotations_dict</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                <span class="s2">]</span>
                <span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">code_inject_index</span><span class="s2">, </span><span class="s1">Expr</span><span class="s2">(</span><span class="s1">Call</span><span class="s2">(</span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, []))</span>
                <span class="s2">)</span>

            <span class="s5"># Add a checked &quot;return None&quot; to the end if there's no explicit return</span>
            <span class="s5"># Skip if the return annotation is None or Any</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span>
                <span class="s0">and </span><span class="s2">(</span><span class="s0">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_async </span><span class="s0">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">has_yield_expressions</span><span class="s2">)</span>
                <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">Return</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s2">(</span>
                    <span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">)</span>
                    <span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is not None</span>
                <span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                    <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_return_type&quot;</span>
                <span class="s2">)</span>
                <span class="s1">return_node </span><span class="s2">= </span><span class="s1">Return</span><span class="s2">(</span>
                    <span class="s1">Call</span><span class="s2">(</span>
                        <span class="s1">func_name</span><span class="s2">,</span>
                        <span class="s2">[</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">joined_path</span><span class="s2">,</span>
                            <span class="s1">Constant</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span><span class="s2">,</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                        <span class="s2">],</span>
                        <span class="s2">[],</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>

                <span class="s5"># Replace a placeholder &quot;pass&quot; at the end</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">Pass</span><span class="s2">):</span>
                    <span class="s1">copy_location</span><span class="s2">(</span><span class="s1">return_node</span><span class="s2">, </span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">])</span>
                    <span class="s0">del </span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>

                <span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">return_node</span><span class="s2">)</span>

            <span class="s5"># Insert code to create the call memo, if it was ever needed for this</span>
            <span class="s5"># function</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">memo_var_name</span><span class="s2">:</span>
                <span class="s1">memo_kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {}</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, </span><span class="s1">ClassDef</span><span class="s2">):</span>
                    <span class="s0">for </span><span class="s1">decorator </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">decorator_list</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s2">(</span>
                            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">)</span>
                            <span class="s0">and </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">id </span><span class="s2">== </span><span class="s3">&quot;staticmethod&quot;</span>
                        <span class="s2">):</span>
                            <span class="s0">break</span>
                        <span class="s0">elif </span><span class="s2">(</span>
                            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">decorator</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">)</span>
                            <span class="s0">and </span><span class="s1">decorator</span><span class="s2">.</span><span class="s1">id </span><span class="s2">== </span><span class="s3">&quot;classmethod&quot;</span>
                        <span class="s2">):</span>
                            <span class="s1">memo_kwargs</span><span class="s2">[</span><span class="s3">&quot;self_type&quot;</span><span class="s2">] = </span><span class="s1">Name</span><span class="s2">(</span>
                                <span class="s1">id</span><span class="s2">=</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()</span>
                            <span class="s2">)</span>
                            <span class="s0">break</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args</span><span class="s2">:</span>
                            <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;__new__&quot;</span><span class="s2">:</span>
                                <span class="s1">memo_kwargs</span><span class="s2">[</span><span class="s3">&quot;self_type&quot;</span><span class="s2">] = </span><span class="s1">Name</span><span class="s2">(</span>
                                    <span class="s1">id</span><span class="s2">=</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()</span>
                                <span class="s2">)</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s1">memo_kwargs</span><span class="s2">[</span><span class="s3">&quot;self_type&quot;</span><span class="s2">] = </span><span class="s1">Attribute</span><span class="s2">(</span>
                                    <span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()),</span>
                                    <span class="s3">&quot;__class__&quot;</span><span class="s2">,</span>
                                    <span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">(),</span>
                                <span class="s2">)</span>

                <span class="s5"># Construct the function reference</span>
                <span class="s5"># Nested functions get special treatment: the function name is added</span>
                <span class="s5"># to free variables (and the closure of the resulting function)</span>
                <span class="s1">names</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = [</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                <span class="s1">memo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent</span>
                <span class="s0">while </span><span class="s1">memo</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)):</span>
                        <span class="s5"># This is a nested function. Use the function name as-is.</span>
                        <span class="s0">del </span><span class="s1">names</span><span class="s2">[:-</span><span class="s4">1</span><span class="s2">]</span>
                        <span class="s0">break</span>
                    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, </span><span class="s1">ClassDef</span><span class="s2">):</span>
                        <span class="s0">break</span>

                    <span class="s1">names</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                    <span class="s1">memo </span><span class="s2">= </span><span class="s1">memo</span><span class="s2">.</span><span class="s1">parent</span>

                <span class="s1">config_keywords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_config_keywords</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">config_keywords</span><span class="s2">:</span>
                    <span class="s1">memo_kwargs</span><span class="s2">[</span><span class="s3">&quot;config&quot;</span><span class="s2">] = </span><span class="s1">Call</span><span class="s2">(</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;dataclasses&quot;</span><span class="s2">, </span><span class="s3">&quot;replace&quot;</span><span class="s2">),</span>
                        <span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard._config&quot;</span><span class="s2">, </span><span class="s3">&quot;global_config&quot;</span><span class="s2">)],</span>
                        <span class="s1">config_keywords</span><span class="s2">,</span>
                    <span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">memo_var_name</span><span class="s2">.</span><span class="s1">id </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_unused_name</span><span class="s2">(</span><span class="s3">&quot;memo&quot;</span><span class="s2">)</span>
                <span class="s1">memo_store_name </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">memo_var_name</span><span class="s2">.</span><span class="s1">id</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Store</span><span class="s2">())</span>
                <span class="s1">globals_call </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s3">&quot;globals&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()), [], [])</span>
                <span class="s1">locals_call </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span><span class="s1">Name</span><span class="s2">(</span><span class="s1">id</span><span class="s2">=</span><span class="s3">&quot;locals&quot;</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()), [], [])</span>
                <span class="s1">memo_expr </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard&quot;</span><span class="s2">, </span><span class="s3">&quot;TypeCheckMemo&quot;</span><span class="s2">),</span>
                    <span class="s2">[</span><span class="s1">globals_call</span><span class="s2">, </span><span class="s1">locals_call</span><span class="s2">],</span>
                    <span class="s2">[</span><span class="s1">keyword</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">) </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">memo_kwargs</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()],</span>
                <span class="s2">)</span>
                <span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">code_inject_index</span><span class="s2">,</span>
                    <span class="s1">Assign</span><span class="s2">([</span><span class="s1">memo_store_name</span><span class="s2">], </span><span class="s1">memo_expr</span><span class="s2">),</span>
                <span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">insert_imports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

                <span class="s5"># Special case the __new__() method to create a local alias from the</span>
                <span class="s5"># class name to the first argument (usually &quot;cls&quot;)</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">FunctionDef</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span>
                    <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, </span><span class="s1">ClassDef</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">node</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;__new__&quot;</span>
                <span class="s2">):</span>
                    <span class="s1">first_args_expr </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">())</span>
                    <span class="s1">cls_name </span><span class="s2">= </span><span class="s1">Name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Store</span><span class="s2">())</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">code_inject_index</span><span class="s2">,</span>
                        <span class="s1">Assign</span><span class="s2">([</span><span class="s1">cls_name</span><span class="s2">], </span><span class="s1">first_args_expr</span><span class="s2">),</span>
                    <span class="s2">)</span>

                <span class="s5"># Rmove any placeholder &quot;pass&quot; at the end</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">Pass</span><span class="s2">):</span>
                    <span class="s0">del </span><span class="s1">node</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_AsyncFunctionDef</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AsyncFunctionDef</span>
    <span class="s2">) </span><span class="s1">-&gt; FunctionDef </span><span class="s2">| </span><span class="s1">AsyncFunctionDef </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">visit_FunctionDef</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">visit_Return</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Return</span><span class="s2">) </span><span class="s1">-&gt; Return</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;This injects type checks into &quot;return&quot; statements.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">should_instrument</span>
            <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_return_type&quot;</span><span class="s2">)</span>
            <span class="s1">old_node </span><span class="s2">= </span><span class="s1">node</span>
            <span class="s1">retval </span><span class="s2">= </span><span class="s1">old_node</span><span class="s2">.</span><span class="s1">value </span><span class="s0">or </span><span class="s1">Constant</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">node </span><span class="s2">= </span><span class="s1">Return</span><span class="s2">(</span>
                <span class="s1">Call</span><span class="s2">(</span>
                    <span class="s1">func_name</span><span class="s2">,</span>
                    <span class="s2">[</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">joined_path</span><span class="s2">,</span>
                        <span class="s1">retval</span><span class="s2">,</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">return_annotation</span><span class="s2">,</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                    <span class="s2">],</span>
                    <span class="s2">[],</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s1">copy_location</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">old_node</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Yield</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Yield</span><span class="s2">) </span><span class="s1">-&gt; Yield </span><span class="s2">| </span><span class="s1">Call</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        This injects type checks into &quot;yield&quot; expressions, checking both the yielded 
        value and the value sent back to the generator, when appropriate. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">has_yield_expressions </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">yield_annotation</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">should_instrument</span>
            <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">yield_annotation</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_yield_type&quot;</span><span class="s2">)</span>
            <span class="s1">yieldval </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s0">or </span><span class="s1">Constant</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                <span class="s1">func_name</span><span class="s2">,</span>
                <span class="s2">[</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">joined_path</span><span class="s2">,</span>
                    <span class="s1">yieldval</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">yield_annotation</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                <span class="s2">],</span>
                <span class="s2">[],</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">send_annotation</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">should_instrument</span>
            <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">is_ignored_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">send_annotation</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_send_type&quot;</span><span class="s2">)</span>
            <span class="s1">old_node </span><span class="s2">= </span><span class="s1">node</span>
            <span class="s1">call_node </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                <span class="s1">func_name</span><span class="s2">,</span>
                <span class="s2">[</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">joined_path</span><span class="s2">,</span>
                    <span class="s1">old_node</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">send_annotation</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                <span class="s2">],</span>
                <span class="s2">[],</span>
            <span class="s2">)</span>
            <span class="s1">copy_location</span><span class="s2">(</span><span class="s1">call_node</span><span class="s2">, </span><span class="s1">old_node</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">call_node</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_AnnAssign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AnnAssign</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        This injects a type check into a local variable annotation-assignment within a 
        function body. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s1">node</span><span class="s2">.</span><span class="s1">annotation</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_annotation</span><span class="s2">(</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">annotation</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">annotation</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">variable_annotations</span><span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">] = </span><span class="s1">annotation</span>
                <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">:</span>
                    <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                        <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_variable_assignment&quot;</span>
                    <span class="s2">)</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                        <span class="s1">func_name</span><span class="s2">,</span>
                        <span class="s2">[</span>
                            <span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,</span>
                            <span class="s1">Constant</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">),</span>
                            <span class="s1">annotation</span><span class="s2">,</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                        <span class="s2">],</span>
                        <span class="s2">[],</span>
                    <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_Assign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Assign</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        This injects a type check into a local variable assignment within a function 
        body. The variable must have been annotated earlier in the function body. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s5"># Only instrument function-local assignments</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)):</span>
            <span class="s1">targets</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Constant</span><span class="s2">, </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">]] = []</span>
            <span class="s1">check_required </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">target </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">targets</span><span class="s2">:</span>
                <span class="s1">elts</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
                    <span class="s1">elts </span><span class="s2">= [</span><span class="s1">target</span><span class="s2">]</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">):</span>
                    <span class="s1">elts </span><span class="s2">= </span><span class="s1">target</span><span class="s2">.</span><span class="s1">elts</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">continue</span>

                <span class="s1">annotations_</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Constant</span><span class="s2">, </span><span class="s1">expr </span><span class="s2">| </span><span class="s0">None</span><span class="s2">] = {}</span>
                <span class="s0">for </span><span class="s1">exp </span><span class="s0">in </span><span class="s1">elts</span><span class="s2">:</span>
                    <span class="s1">prefix </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">, </span><span class="s1">Starred</span><span class="s2">):</span>
                        <span class="s1">exp </span><span class="s2">= </span><span class="s1">exp</span><span class="s2">.</span><span class="s1">value</span>
                        <span class="s1">prefix </span><span class="s2">= </span><span class="s3">&quot;*&quot;</span>

                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
                        <span class="s1">name </span><span class="s2">= </span><span class="s1">prefix </span><span class="s2">+ </span><span class="s1">exp</span><span class="s2">.</span><span class="s1">id</span>
                        <span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">variable_annotations</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">annotation</span><span class="s2">:</span>
                            <span class="s1">annotations_</span><span class="s2">[</span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)] = </span><span class="s1">annotation</span>
                            <span class="s1">check_required </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">annotations_</span><span class="s2">[</span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)] = </span><span class="s0">None</span>

                <span class="s1">targets</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">annotations_</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">check_required</span><span class="s2">:</span>
                <span class="s5"># Replace missing annotations with typing.Any</span>
                <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">targets</span><span class="s2">:</span>
                    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">expression </span><span class="s0">in </span><span class="s1">item</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                        <span class="s0">if </span><span class="s1">expression </span><span class="s0">is None</span><span class="s2">:</span>
                            <span class="s1">item</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typing&quot;</span><span class="s2">, </span><span class="s3">&quot;Any&quot;</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">targets</span><span class="s2">) == </span><span class="s4">1 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">targets</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]) == </span><span class="s4">1</span><span class="s2">:</span>
                    <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                        <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_variable_assignment&quot;</span>
                    <span class="s2">)</span>
                    <span class="s1">target_varname </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">targets</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]))</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                        <span class="s1">func_name</span><span class="s2">,</span>
                        <span class="s2">[</span>
                            <span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,</span>
                            <span class="s1">target_varname</span><span class="s2">,</span>
                            <span class="s1">targets</span><span class="s2">[</span><span class="s4">0</span><span class="s2">][</span><span class="s1">target_varname</span><span class="s2">],</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                        <span class="s2">],</span>
                        <span class="s2">[],</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">targets</span><span class="s2">:</span>
                    <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                        <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_multi_variable_assignment&quot;</span>
                    <span class="s2">)</span>
                    <span class="s1">targets_arg </span><span class="s2">= </span><span class="s1">List</span><span class="s2">(</span>
                        <span class="s2">[</span>
                            <span class="s1">Dict</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">=</span><span class="s1">list</span><span class="s2">(</span><span class="s1">target</span><span class="s2">), </span><span class="s1">values</span><span class="s2">=</span><span class="s1">list</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()))</span>
                            <span class="s0">for </span><span class="s1">target </span><span class="s0">in </span><span class="s1">targets</span>
                        <span class="s2">],</span>
                        <span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">(),</span>
                    <span class="s2">)</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                        <span class="s1">func_name</span><span class="s2">,</span>
                        <span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">targets_arg</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">()],</span>
                        <span class="s2">[],</span>
                    <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_NamedExpr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedExpr</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;This injects a type check into an assignment expression (a := foo()).&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s5"># Only instrument function-local assignments</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span>
        <span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>

            <span class="s5"># Bail out if no matching annotation is found</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">variable_annotations</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">annotation </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">node</span>

            <span class="s1">func_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span>
                <span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_variable_assignment&quot;</span>
            <span class="s2">)</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                <span class="s1">func_name</span><span class="s2">,</span>
                <span class="s2">[</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,</span>
                    <span class="s1">Constant</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">),</span>
                    <span class="s1">annotation</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                <span class="s2">],</span>
                <span class="s2">[],</span>
            <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_AugAssign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">AugAssign</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        This injects a type check into an augmented assignment expression (a += 1). 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s5"># Only instrument function-local assignments</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">node</span><span class="s2">, (</span><span class="s1">FunctionDef</span><span class="s2">, </span><span class="s1">AsyncFunctionDef</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">Name</span>
        <span class="s2">):</span>
            <span class="s5"># Bail out if no matching annotation is found</span>
            <span class="s1">annotation </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">variable_annotations</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">annotation </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">node</span>

            <span class="s5"># Bail out if the operator is not found (newer Python version?)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">operator_func_name </span><span class="s2">= </span><span class="s1">aug_assign_functions</span><span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">op</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">node</span>

            <span class="s1">operator_func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;operator&quot;</span><span class="s2">, </span><span class="s1">operator_func_name</span><span class="s2">)</span>
            <span class="s1">operator_call </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                <span class="s1">operator_func</span><span class="s2">, [</span><span class="s1">Name</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">=</span><span class="s1">Load</span><span class="s2">()), </span><span class="s1">node</span><span class="s2">.</span><span class="s1">value</span><span class="s2">], []</span>
            <span class="s2">)</span>
            <span class="s1">check_call </span><span class="s2">= </span><span class="s1">Call</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_import</span><span class="s2">(</span><span class="s3">&quot;typeguard._functions&quot;</span><span class="s2">, </span><span class="s3">&quot;check_variable_assignment&quot;</span><span class="s2">),</span>
                <span class="s2">[</span>
                    <span class="s1">operator_call</span><span class="s2">,</span>
                    <span class="s1">Constant</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">id</span><span class="s2">),</span>
                    <span class="s1">annotation</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">get_memo_name</span><span class="s2">(),</span>
                <span class="s2">],</span>
                <span class="s2">[],</span>
            <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">targets</span><span class="s2">=[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">target</span><span class="s2">], </span><span class="s1">value</span><span class="s2">=</span><span class="s1">check_call</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">visit_If</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">If</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot; 
        This blocks names from being collected from a module-level 
        &quot;if typing.TYPE_CHECKING:&quot; block, so that they won't be type checked. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">generic_visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_module_memo</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">test</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">name_matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">test</span><span class="s2">, </span><span class="s3">&quot;typing.TYPE_CHECKING&quot;</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">collector </span><span class="s2">= </span><span class="s1">NameCollector</span><span class="s2">()</span>
            <span class="s1">collector</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_memo</span><span class="s2">.</span><span class="s1">ignored_names</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">collector</span><span class="s2">.</span><span class="s1">names</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">node</span>
</pre>
</body>
</html>