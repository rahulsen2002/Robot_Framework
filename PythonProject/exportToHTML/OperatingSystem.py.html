<html>
<head>
<title>OperatingSystem.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
OperatingSystem.py</font>
</center></td></tr></table>
<pre><span class="s0">#  Copyright 2008-2015 Nokia Networks</span>
<span class="s0">#  Copyright 2016-     Robot Framework Foundation</span>
<span class="s0">#</span>
<span class="s0">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0">#  you may not use this file except in compliance with the License.</span>
<span class="s0">#  You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="s0">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0">#  See the License for the specific language governing permissions and</span>
<span class="s0">#  limitations under the License.</span>

<span class="s2">import </span><span class="s1">fnmatch</span>
<span class="s2">import </span><span class="s1">glob</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pathlib</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>

<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">api </span><span class="s2">import </span><span class="s1">logger</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">api</span><span class="s3">.</span><span class="s1">deco </span><span class="s2">import </span><span class="s1">keyword</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">abspath</span><span class="s3">, </span><span class="s1">ConnectionCache</span><span class="s3">, </span><span class="s1">console_decode</span><span class="s3">, </span><span class="s1">CONSOLE_ENCODING</span><span class="s3">, </span><span class="s1">del_env_var</span><span class="s3">,</span>
    <span class="s1">get_env_var</span><span class="s3">, </span><span class="s1">get_env_vars</span><span class="s3">, </span><span class="s1">get_time</span><span class="s3">, </span><span class="s1">normpath</span><span class="s3">, </span><span class="s1">parse_time</span><span class="s3">, </span><span class="s1">plural_or_not </span><span class="s2">as </span><span class="s1">s</span><span class="s3">,</span>
    <span class="s1">PY_VERSION</span><span class="s3">, </span><span class="s1">safe_str</span><span class="s3">, </span><span class="s1">secs_to_timestr</span><span class="s3">, </span><span class="s1">seq2str</span><span class="s3">, </span><span class="s1">set_env_var</span><span class="s3">, </span><span class="s1">timestr_to_secs</span><span class="s3">,</span>
    <span class="s1">WINDOWS</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">version </span><span class="s2">import </span><span class="s1">get_version</span>

<span class="s1">__version__ </span><span class="s3">= </span><span class="s1">get_version</span><span class="s3">()</span>
<span class="s1">PROCESSES </span><span class="s3">= </span><span class="s1">ConnectionCache</span><span class="s3">(</span><span class="s4">&quot;No active processes.&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">OperatingSystem</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;A library providing keywords for operating system related tasks. 
 
    ``OperatingSystem`` is Robot Framework's standard library that 
    enables various operating system related tasks to be performed in 
    the system where Robot Framework is running. It can, among other 
    things, execute commands (e.g. `Run`), create and remove files and 
    directories (e.g. `Create File`, `Remove Directory`), check 
    whether files or directories exists or contain something 
    (e.g. `File Should Exist`, `Directory Should Be Empty`) and 
    manipulate environment variables (e.g. `Set Environment Variable`). 
 
    == Table of contents == 
 
    %TOC% 
 
    = Path separators = 
 
    Because Robot Framework uses the backslash (``\``) as an escape character 
    in its data, using a literal backslash requires duplicating it like 
    in ``c:\\path\\file.txt``. That can be inconvenient especially with 
    longer Windows paths, and thus all keywords expecting paths as arguments 
    convert forward slashes to backslashes automatically on Windows. This also 
    means that paths like ``${CURDIR}/path/file.txt`` are operating system 
    independent. 
 
    Notice that the automatic path separator conversion does not work if 
    the path is only a part of an argument like with the `Run` keyword. 
    In these cases the built-in variable ``${/}`` that contains ``\`` or ``/``, 
    depending on the operating system, can be used instead. 
 
    = Pattern matching = 
 
    Many keywords accept arguments as either _glob_ or _regular expression_ patterns. 
 
    == Glob patterns == 
 
    Some keywords, for example `List Directory`, support so called 
    [http://en.wikipedia.org/wiki/Glob_(programming)|glob patterns] where: 
 
    | ``*``        | matches any string, even an empty string                | 
    | ``?``        | matches any single character                            | 
    | ``[chars]``  | matches one character in the bracket                    | 
    | ``[!chars]`` | matches one character not in the bracket                | 
    | ``[a-z]``    | matches one character from the range in the bracket     | 
    | ``[!a-z]``   | matches one character not from the range in the bracket | 
 
    Unless otherwise noted, matching is case-insensitive on case-insensitive 
    operating systems such as Windows. 
 
    == Regular expressions == 
 
    Some keywords, for example `Grep File`, support 
    [http://en.wikipedia.org/wiki/Regular_expression|regular expressions] 
    that are more powerful but also more complicated that glob patterns. 
    The regular expression support is implemented using Python's 
    [http://docs.python.org/library/re.html|re module] and its documentation 
    should be consulted for more information about the syntax. 
 
    Because the backslash character (``\``) is an escape character in 
    Robot Framework data, possible backslash characters in regular 
    expressions need to be escaped with another backslash like ``\\d\\w+``. 
    Strings that may contain special characters but should be handled 
    as literal strings, can be escaped with the `Regexp Escape` keyword 
    from the BuiltIn library. 
 
    = Tilde expansion = 
 
    Paths beginning with ``~`` or ``~username`` are expanded to the current or 
    specified user's home directory, respectively. The resulting path is 
    operating system dependent, but typically e.g. ``~/robot`` is expanded to 
    ``C:\Users\&lt;user&gt;\robot`` on Windows and ``/home/&lt;user&gt;/robot`` on Unixes. 
 
    = pathlib.Path support = 
 
    Starting from Robot Framework 6.0, arguments representing paths can be given 
    as [https://docs.python.org/3/library/pathlib.html|pathlib.Path] instances 
    in addition to strings. 
 
    All keywords returning paths return them as strings. This may change in 
    the future so that the return value type matches the argument type. 
 
    = Boolean arguments = 
 
    Some keywords accept arguments that are handled as Boolean values true or 
    false. If such an argument is given as a string, it is considered false if 
    it is an empty string or equal to ``FALSE``, ``NONE``, ``NO``, ``OFF`` or 
    ``0``, case-insensitively. Other strings are considered true regardless 
    their value, and other argument types are tested using the same 
    [http://docs.python.org/library/stdtypes.html#truth|rules as in Python]. 
 
    True examples: 
    | `Remove Directory` | ${path} | recursive=True    | # Strings are generally true.    | 
    | `Remove Directory` | ${path} | recursive=yes     | # Same as the above.             | 
    | `Remove Directory` | ${path} | recursive=${TRUE} | # Python ``True`` is true.       | 
    | `Remove Directory` | ${path} | recursive=${42}   | # Numbers other than 0 are true. | 
 
    False examples: 
    | `Remove Directory` | ${path} | recursive=False    | # String ``false`` is false.   | 
    | `Remove Directory` | ${path} | recursive=no       | # Also string ``no`` is false. | 
    | `Remove Directory` | ${path} | recursive=${EMPTY} | # Empty string is false.       | 
    | `Remove Directory` | ${path} | recursive=${FALSE} | # Python ``False`` is false.   | 
 
    = Example = 
 
    | ***** Settings ***** 
    | Library         OperatingSystem 
    | 
    | ***** Variables ***** 
    | ${PATH}         ${CURDIR}/example.txt 
    | 
    | ***** Test Cases ***** 
    | Example 
    |     `Create File`          ${PATH}    Some text 
    |     `File Should Exist`    ${PATH} 
    |     `Copy File`            ${PATH}    ~/file.txt 
    &quot;&quot;&quot;</span>

    <span class="s1">ROBOT_LIBRARY_SCOPE </span><span class="s3">= </span><span class="s4">&quot;GLOBAL&quot;</span>
    <span class="s1">ROBOT_LIBRARY_VERSION </span><span class="s3">= </span><span class="s1">__version__</span>

    <span class="s2">def </span><span class="s1">run</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Runs the given command in the system and returns the output. 
 
        The execution status of the command *is not checked* by this 
        keyword, and it must be done separately based on the returned 
        output. If the execution return code is needed, either `Run 
        And Return RC` or `Run And Return RC And Output` can be used. 
 
        The standard error stream is automatically redirected to the standard 
        output stream by adding ``2&gt;&amp;1`` after the executed command. This 
        automatic redirection is done only when the executed command does not 
        contain additional output redirections. You can thus freely forward 
        the standard error somewhere else, for example, like 
        ``my_command 2&gt;stderr.txt``. 
 
        The returned output contains everything written into the standard 
        output or error streams by the command (unless either of them 
        is redirected explicitly). Many commands add an extra newline 
        (``\\n``) after the output to make it easier to read in the 
        console. To ease processing the returned output, this possible 
        trailing newline is stripped by this keyword. 
 
        Examples: 
        | ${output} =        | Run       | ls -lhF /tmp | 
        | Log                | ${output} | 
        | ${result} =        | Run       | ${CURDIR}${/}tester.py arg1 arg2 | 
        | Should Not Contain | ${result} | FAIL | 
        | ${stdout} =        | Run       | /opt/script.sh 2&gt;/tmp/stderr.txt | 
        | Should Be Equal    | ${stdout} | TEST PASSED | 
        | File Should Be Empty | /tmp/stderr.txt | 
 
        *TIP:* `Run Process` keyword provided by the 
        [http://robotframework.org/robotframework/latest/libraries/Process.html| 
        Process library] supports better process configuration and is generally 
        recommended as a replacement for this keyword. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_run</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">run_and_return_rc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Runs the given command in the system and returns the return code. 
 
        The return code (RC) is returned as a positive integer in 
        range from 0 to 255 as returned by the executed command. On 
        some operating systems (notable Windows) original return codes 
        can be something else, but this keyword always maps them to 
        the 0-255 range. Since the RC is an integer, it must be 
        checked e.g. with the keyword `Should Be Equal As Integers` 
        instead of `Should Be Equal` (both are built-in keywords). 
 
        Examples: 
        | ${rc} = | Run and Return RC | ${CURDIR}${/}script.py arg | 
        | Should Be Equal As Integers | ${rc} | 0 | 
        | ${rc} = | Run and Return RC | /path/to/example.rb arg1 arg2 | 
        | Should Be True | 0 &lt; ${rc} &lt; 42 | 
 
        See `Run` and `Run And Return RC And Output` if you need to get the 
        output of the executed command. 
 
        *TIP:* `Run Process` keyword provided by the 
        [http://robotframework.org/robotframework/latest/libraries/Process.html| 
        Process library] supports better process configuration and is generally 
        recommended as a replacement for this keyword. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_run</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">run_and_return_rc_and_output</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Runs the given command in the system and returns the RC and output. 
 
        The return code (RC) is returned similarly as with `Run And Return RC` 
        and the output similarly as with `Run`. 
 
        Examples: 
        | ${rc} | ${output} =  | Run and Return RC and Output | ${CURDIR}${/}mytool | 
        | Should Be Equal As Integers | ${rc}    | 0    | 
        | Should Not Contain   | ${output}       | FAIL | 
        | ${rc} | ${stdout} =  | Run and Return RC and Output | /opt/script.sh 2&gt;/tmp/stderr.txt | 
        | Should Be True       | ${rc} &gt; 42      | 
        | Should Be Equal      | ${stdout}       | TEST PASSED | 
        | File Should Be Empty | /tmp/stderr.txt | 
 
        *TIP:* `Run Process` keyword provided by the 
        [http://robotframework.org/robotframework/latest/libraries/Process.html| 
        Process library] supports better process configuration and is generally 
        recommended as a replacement for this keyword. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_run</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_run</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">_Process</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Running command '</span><span class="s2">{</span><span class="s1">process</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>
        <span class="s1">stdout </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
        <span class="s1">rc </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">rc</span><span class="s3">, </span><span class="s1">stdout</span>

    <span class="s2">def </span><span class="s1">get_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;UTF-8&quot;</span><span class="s3">, </span><span class="s1">encoding_errors</span><span class="s3">=</span><span class="s4">&quot;strict&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the contents of a specified file. 
 
        This keyword reads the specified file and returns the contents. 
        Line breaks in content are converted to platform independent form. 
        See also `Get Binary File`. 
 
        ``encoding`` defines the encoding of the file. The default value is 
        ``UTF-8``, which means that UTF-8 and ASCII encoded files are read 
        correctly. In addition to the encodings supported by the underlying 
        Python implementation, the following special encoding values can be 
        used: 
 
        - ``SYSTEM``: Use the default system encoding. 
        - ``CONSOLE``: Use the console encoding. Outside Windows this is same 
          as the system encoding. 
 
        ``encoding_errors`` argument controls what to do if decoding some bytes 
        fails. All values accepted by ``decode`` method in Python are valid, but 
        in practice the following values are most useful: 
 
        - ``strict``: Fail if characters cannot be decoded (default). 
        - ``ignore``: Ignore characters that cannot be decoded. 
        - ``replace``: Replace characters that cannot be decoded with 
          a replacement character. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Getting file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">encoding </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_map_encoding</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">)</span>
        <span class="s0"># Using `newline=None` (default) and not converting `\r\n` -&gt; `\n`</span>
        <span class="s0"># ourselves would be better but some of our own acceptance tests</span>
        <span class="s0"># depend on these semantics. Best solution would probably be making</span>
        <span class="s0"># `newline` configurable.</span>
        <span class="s0"># FIXME: Make `newline` configurable or at least submit an issue about that.</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s1">encoding_errors</span><span class="s3">, </span><span class="s1">newline</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">().</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_map_encoding</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span>
            <span class="s4">&quot;SYSTEM&quot;</span><span class="s3">: </span><span class="s4">&quot;locale&quot; </span><span class="s2">if </span><span class="s1">PY_VERSION </span><span class="s3">&gt; (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">10</span><span class="s3">) </span><span class="s2">else None</span><span class="s3">,</span>
            <span class="s4">&quot;CONSOLE&quot;</span><span class="s3">: </span><span class="s1">CONSOLE_ENCODING</span><span class="s3">,</span>
        <span class="s3">}.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">(), </span><span class="s1">encoding</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_binary_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the contents of a specified file. 
 
        This keyword reads the specified file and returns the contents as is. 
        See also `Get File`. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Getting file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s4">&quot;rb&quot;</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">grep_file</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">path</span><span class="s3">,</span>
        <span class="s1">pattern</span><span class="s3">,</span>
        <span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;UTF-8&quot;</span><span class="s3">,</span>
        <span class="s1">encoding_errors</span><span class="s3">=</span><span class="s4">&quot;strict&quot;</span><span class="s3">,</span>
        <span class="s1">regexp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s5">r&quot;&quot;&quot;Returns the lines of the specified file that match the ``pattern``. 
 
        This keyword reads a file from the file system using the defined 
        ``path``, ``encoding`` and ``encoding_errors`` similarly as `Get File`. 
        A difference is that only the lines that match the given ``pattern`` are 
        returned. Lines are returned as a single string concatenated back together 
        with newlines and the number of matched lines is automatically logged. 
        Possible trailing newline is never returned. 
 
        A line matches if it contains the ``pattern`` anywhere in it i.e. it does 
        not need to match the pattern fully. There are two supported pattern types: 
 
        - By default the pattern is considered a _glob_ pattern where, for example, 
          ``*`` and ``?`` can be used as wildcards. 
        - If the ``regexp`` argument is given a true value, the pattern is 
          considered to be a _regular expression_. These patterns are more 
          powerful but also more complicated than glob patterns. They often use 
          the backslash character and it needs to be escaped in Robot Framework 
          date like `\\`. 
 
        For more information about glob and regular expression syntax, see 
        the `Pattern matching` section. With this keyword matching is always 
        case-sensitive. 
 
        Examples: 
        | ${errors} = | Grep File | /var/log/myapp.log | ERROR | 
        | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc??d ex*ple | 
        | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc\\w+d ex.*ple | regexp=True | 
 
        Special encoding values ``SYSTEM`` and ``CONSOLE`` that `Get File` supports 
        are supported by this keyword only with Robot Framework 4.0 and newer. 
 
        Support for regular expressions is new in Robot Framework 5.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">regexp</span><span class="s3">:</span>
            <span class="s1">pattern </span><span class="s3">= </span><span class="s1">fnmatch</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">pattern</span><span class="s2">}</span><span class="s4">*&quot;</span><span class="s3">)</span>
        <span class="s1">reobj </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)</span>
        <span class="s1">encoding </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_map_encoding</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">)</span>
        <span class="s1">lines </span><span class="s3">= []</span>
        <span class="s1">total_lines </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Reading file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s1">encoding_errors</span><span class="s3">) </span><span class="s2">as </span><span class="s1">file</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">file</span><span class="s3">:</span>
                <span class="s1">total_lines </span><span class="s3">+= </span><span class="s6">1</span>
                <span class="s1">line </span><span class="s3">= </span><span class="s1">line</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">reobj</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s1">line</span><span class="s3">):</span>
                    <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">)</span><span class="s2">} </span><span class="s4">out of </span><span class="s2">{</span><span class="s1">total_lines</span><span class="s2">} </span><span class="s4">lines matched.&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">log_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;UTF-8&quot;</span><span class="s3">, </span><span class="s1">encoding_errors</span><span class="s3">=</span><span class="s4">&quot;strict&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Wrapper for `Get File` that also logs the returned file. 
 
        The file is logged with the INFO level. If you want something else, 
        just use `Get File` and the built-in keyword `Log` with the desired 
        level. 
 
        See `Get File` for more information about ``encoding`` and 
        ``encoding_errors`` arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">content </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_file</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">encoding_errors</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s1">content</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">content</span>

    <span class="s0"># File and directory existence</span>

    <span class="s2">def </span><span class="s1">should_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails unless the given path (file or directory) exists. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Path '%s' exists.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">should_not_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the given path (file or directory) exists. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_matches_error</span><span class="s3">(</span><span class="s4">&quot;Path&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Path '%s' does not exist.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">glob</span><span class="s3">.</span><span class="s1">glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">else </span><span class="s3">[</span><span class="s1">path</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_matches_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_glob_path</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">} </span><span class="s4">'</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' exists.&quot;</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">} </span><span class="s4">'</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' matches </span><span class="s2">{</span><span class="s1">seq2str</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">matches</span><span class="s3">))</span><span class="s2">}</span><span class="s4">.&quot;</span>

    <span class="s2">def </span><span class="s1">_is_glob_path</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">&quot;*&quot; </span><span class="s2">in </span><span class="s1">path </span><span class="s2">or </span><span class="s4">&quot;?&quot; </span><span class="s2">in </span><span class="s1">path </span><span class="s2">or </span><span class="s3">(</span><span class="s4">&quot;[&quot; </span><span class="s2">in </span><span class="s1">path </span><span class="s2">and </span><span class="s4">&quot;]&quot; </span><span class="s2">in </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">file_should_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails unless the given ``path`` points to an existing file. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= [</span><span class="s1">p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)]</span>
        <span class="s2">if not </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;File '%s' exists.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">file_should_not_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the given path points to an existing file. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= [</span><span class="s1">p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_matches_error</span><span class="s3">(</span><span class="s4">&quot;File&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;File '%s' does not exist.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">directory_should_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails unless the given path points to an existing directory. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= [</span><span class="s1">p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)]</span>
        <span class="s2">if not </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Directory '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Directory '%s' exists.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">directory_should_not_exist</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the given path points to an existing file. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= [</span><span class="s1">p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) </span><span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_matches_error</span><span class="s3">(</span><span class="s4">&quot;Directory&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Directory '%s' does not exist.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s0"># Waiting file/dir to appear/disappear</span>

    <span class="s2">def </span><span class="s1">wait_until_removed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s4">&quot;1 minute&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Waits until the given file or directory is removed. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
        If the path is a pattern, the keyword waits until all matching 
        items are removed. 
 
        The optional ``timeout`` can be used to control the maximum time of 
        waiting. The timeout is given as a timeout string, e.g. in a format 
        ``15 seconds``, ``1min 10s`` or just ``10``. The time string format is 
        described in an appendix of Robot Framework User Guide. 
 
        If the timeout is negative, the keyword is never timed-out. The keyword 
        returns immediately, if the path does not exist in the first place. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">timeout </span><span class="s3">= </span><span class="s1">timestr_to_secs</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span>
        <span class="s1">maxtime </span><span class="s3">= </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() + </span><span class="s1">timeout</span>
        <span class="s2">while </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">timeout </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() &gt; </span><span class="s1">maxtime</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' was not removed in </span><span class="s2">{</span><span class="s1">secs_to_timestr</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
            <span class="s1">time</span><span class="s3">.</span><span class="s1">sleep</span><span class="s3">(</span><span class="s6">0.1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;'%s' was removed.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">wait_until_created</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s4">&quot;1 minute&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Waits until the given file or directory is created. 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
        If the path is a pattern, the keyword returns when an item matching 
        it is created. 
 
        The optional ``timeout`` can be used to control the maximum time of 
        waiting. The timeout is given as a timeout string, e.g. in a format 
        ``15 seconds``, ``1min 10s`` or just ``10``. The time string format is 
        described in an appendix of Robot Framework User Guide. 
 
        If the timeout is negative, the keyword is never timed-out. The keyword 
        returns immediately, if the path already exists. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">timeout </span><span class="s3">= </span><span class="s1">timestr_to_secs</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span>
        <span class="s1">maxtime </span><span class="s3">= </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() + </span><span class="s1">timeout</span>
        <span class="s2">while not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">timeout </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() &gt; </span><span class="s1">maxtime</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' was not created in </span><span class="s2">{</span><span class="s1">secs_to_timestr</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
            <span class="s1">time</span><span class="s3">.</span><span class="s1">sleep</span><span class="s3">(</span><span class="s6">0.1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;'%s' was created.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s0"># Dir/file empty</span>

    <span class="s2">def </span><span class="s1">directory_should_be_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails unless the specified directory is empty. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">items</span><span class="s3">:</span>
            <span class="s1">contents </span><span class="s3">= </span><span class="s1">seq2str</span><span class="s3">(</span><span class="s1">items</span><span class="s3">, </span><span class="s1">lastsep</span><span class="s3">=</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Directory '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not empty. Contents: </span><span class="s2">{</span><span class="s1">contents</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Directory '%s' is empty.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">directory_should_not_be_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the specified directory is empty. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">items</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Directory '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is empty.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">f&quot;Directory '%s' contains </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span><span class="s2">} </span><span class="s4">item</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">file_should_be_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails unless the specified file is empty. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">stat</span><span class="s3">(</span><span class="s1">path</span><span class="s3">).</span><span class="s1">st_size</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not empty. Size: </span><span class="s2">{</span><span class="s1">size</span><span class="s2">} </span><span class="s4">byte</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;File '%s' is empty.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">file_should_not_be_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the specified file is empty. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">stat</span><span class="s3">(</span><span class="s1">path</span><span class="s3">).</span><span class="s1">st_size</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is empty.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">f&quot;File '%s' contains </span><span class="s2">{</span><span class="s1">size</span><span class="s2">} </span><span class="s4">bytes.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s0"># Creating and removing files and directory</span>

    <span class="s2">def </span><span class="s1">create_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;UTF-8&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Creates a file with the given content and encoding. 
 
        If the directory where the file is created does not exist, it is 
        automatically created along with possible missing intermediate 
        directories. Possible existing file is overwritten. 
 
        On Windows newline characters (``\\n``) in content are automatically 
        converted to Windows native newline sequence (``\\r\\n``). 
 
        See `Get File` for more information about possible ``encoding`` values, 
        including special values ``SYSTEM`` and ``CONSOLE``. 
 
        Examples: 
        | Create File | ${dir}/example.txt | Hello, world!       |         | 
        | Create File | ${path}            | Hyv\\xe4 esimerkki  | Latin-1 | 
        | Create File | /tmp/foo.txt       | 3\\nlines\\nhere\\n | SYSTEM  | 
 
        Use `Append To File` if you want to append to an existing file 
        and `Create Binary File` if you need to write bytes without encoding. 
        `File Should Not Exist` can be used to avoid overwriting existing 
        files. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write_to_file</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Created file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_write_to_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;w&quot;</span><span class="s3">):</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">parent </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">):</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">makedirs</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">encoding</span><span class="s3">:</span>
            <span class="s1">encoding </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_map_encoding</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s1">encoding</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">content</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">path</span>

    <span class="s2">def </span><span class="s1">create_binary_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">):</span>
        <span class="s5">r&quot;&quot;&quot;Creates a binary file with the given content. 
 
        If content is given as a Unicode string, it is first converted to bytes 
        character by character. All characters with ordinal below 256 can be 
        used and are converted to bytes with same values. Using characters 
        with higher ordinal is an error. 
 
        Byte strings, and possible other types, are written to the file as is. 
 
        If the directory for the file does not exist, it is created, along 
        with missing intermediate directories. 
 
        Examples: 
        | Create Binary File | ${dir}/example.png | ${image content} | 
        | Create Binary File | ${path}            | \x01\x00\xe4\x00 | 
 
        Use `Create File` if you want to create a text file using a certain 
        encoding. `File Should Not Exist` can be used to avoid overwriting 
        existing files. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">content</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">content </span><span class="s3">= </span><span class="s1">bytes</span><span class="s3">(</span><span class="s1">ord</span><span class="s3">(</span><span class="s1">c</span><span class="s3">) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">content</span><span class="s3">)</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write_to_file</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;wb&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Created binary file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">append_to_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;UTF-8&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Appends the given content to the specified file. 
 
        If the file exists, the given text is written to its end. If the file 
        does not exist, it is created. 
 
        Other than not overwriting possible existing files, this keyword works 
        exactly like `Create File`. See its documentation for more details 
        about the usage. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write_to_file</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;a&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Appended to file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remove_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Removes a file with the given path. 
 
        Passes if the file does not exist, but fails if the path does 
        not point to a regular file (e.g. it points to a directory). 
 
        The path can be given as an exact path or as a glob pattern. 
        See the `Glob patterns` section for details about the supported syntax. 
        If the path is a pattern, all files matching it are removed. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">matches </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;File '%s' does not exist.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">match</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not a file.&quot;</span><span class="s3">)</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">match</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Removed file '%s'.&quot;</span><span class="s3">, </span><span class="s1">match</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remove_files</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">paths</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Uses `Remove File` to remove multiple files one-by-one. 
 
        Example: 
        | Remove Files | ${TEMPDIR}${/}foo.txt | ${TEMPDIR}${/}bar.txt | ${TEMPDIR}${/}zap.txt | 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">paths</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">remove_file</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">empty_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Deletes all the content from the given directory. 
 
        Deletes both files and sub-directories, but the specified directory 
        itself if not removed. Use `Remove Directory` if you want to remove 
        the whole directory. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">item</span><span class="s3">):</span>
                <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Emptied directory '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">create_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Creates the specified directory. 
 
        Also possible intermediate directories are created. Passes if the 
        directory already exists, but fails if the path exists and is not 
        a directory. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Directory '%s' already exists.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not a directory.&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">makedirs</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Created directory '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remove_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">recursive</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Removes the directory pointed to by the given ``path``. 
 
        If the second argument ``recursive`` is given a true value (see 
        `Boolean arguments`), the directory is removed recursively. Otherwise 
        removing fails if the directory is not empty. 
 
        If the directory pointed to by the ``path`` does not exist, the keyword 
        passes, but it fails, if the ``path`` points to a file. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Directory '%s' does not exist.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not a directory.&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">recursive</span><span class="s3">:</span>
                <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">directory_should_be_empty</span><span class="s3">(</span>
                    <span class="s1">path</span><span class="s3">, </span><span class="s4">f&quot;Directory '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not empty.&quot;</span>
                <span class="s3">)</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">rmdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Removed directory '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s0"># Moving and copying files and directories</span>

    <span class="s2">def </span><span class="s1">copy_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s5">r&quot;&quot;&quot;Copies the source file into the destination. 
 
        Source must be a path to an existing file or a glob pattern (see 
        `Glob patterns`) that matches exactly one file. How the 
        destination is interpreted is explained below. 
 
        1) If the destination is an existing file, the source file is copied 
        over it. 
 
        2) If the destination is an existing directory, the source file is 
        copied into it. A possible file with the same name as the source is 
        overwritten. 
 
        3) If the destination does not exist and it ends with a path 
        separator (``/`` or ``\``), it is considered a directory. That 
        directory is created and a source file copied into it. 
        Possible missing intermediate directories are also created. 
 
        4) If the destination does not exist and it does not end with a path 
        separator, it is considered a file. If the path to the file does not 
        exist, it is created. 
 
        The resulting destination path is returned. 
 
        See also `Copy Files`, `Move File`, and `Move Files`. 
        &quot;&quot;&quot;</span>
        <span class="s1">source</span><span class="s3">, </span><span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_file</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_are_source_and_destination_same_file</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
            <span class="s1">source</span><span class="s3">, </span><span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_atomic_copy</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Copied file from '%s' to '%s'.&quot;</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">_prepare_copy_and_move_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s1">source </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_normalize_copy_and_move_source</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_normalize_copy_and_move_destination</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">):</span>
            <span class="s1">destination </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">source</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">_normalize_copy_and_move_source</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">):</span>
        <span class="s1">source </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s1">sources </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sources</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Multiple matches with source pattern '</span><span class="s2">{</span><span class="s1">source</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sources</span><span class="s3">:</span>
            <span class="s1">source </span><span class="s3">= </span><span class="s1">sources</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">source</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Source file '</span><span class="s2">{</span><span class="s1">source</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">source</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Source file '</span><span class="s2">{</span><span class="s1">source</span><span class="s2">}</span><span class="s4">' is not a regular file.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">source</span>

    <span class="s2">def </span><span class="s1">_normalize_copy_and_move_destination</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">, </span><span class="s1">pathlib</span><span class="s3">.</span><span class="s1">Path</span><span class="s3">):</span>
            <span class="s1">destination </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">is_dir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">) </span><span class="s2">or </span><span class="s1">destination</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">((</span><span class="s4">&quot;/&quot;</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s3">))</span>
        <span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">directory </span><span class="s3">= </span><span class="s1">destination </span><span class="s2">if </span><span class="s1">is_dir </span><span class="s2">else </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_destination_directory_exists</span><span class="s3">(</span><span class="s1">directory</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">_ensure_destination_directory_exists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">makedirs</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Destination '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' exists and is not a directory.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_are_source_and_destination_same_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_force_normalize</span><span class="s3">(</span><span class="s1">source</span><span class="s3">) == </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_force_normalize</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span>
                <span class="s4">&quot;Source '%s' and destination '%s' point to the same file.&quot;</span><span class="s3">,</span>
                <span class="s1">source</span><span class="s3">,</span>
                <span class="s1">destination</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_force_normalize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s0"># TODO: Should normalize_path also support link normalization?</span>
        <span class="s0"># TODO: Should we handle dos paths like 'exampl~1.txt'?</span>
        <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">realpath</span><span class="s3">(</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">case_normalize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_atomic_copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Copy file atomically (or at least try to). 
 
        This method tries to ensure that a file copy operation will not fail 
        if the destination file is removed during copy operation. The problem 
        is that copying a file is typically not an atomic operation. 
 
        Luckily moving files is atomic in almost every platform, assuming files 
        are on the same filesystem, and we can use that as a workaround: 
        - First move the source to a temporary directory that is ensured to 
          be on the same filesystem as the destination. 
        - Move the temporary file over the real destination. 
 
        See also https://github.com/robotframework/robotframework/issues/1502 
        &quot;&quot;&quot;</span>
        <span class="s1">temp_directory </span><span class="s3">= </span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">mkdtemp</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">=</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">))</span>
        <span class="s1">temp_file </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">temp_directory</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">source</span><span class="s3">))</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">shutil</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">temp_file</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">):</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
            <span class="s1">shutil</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">temp_file</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">temp_directory</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">move_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Moves the source file into the destination. 
 
        Arguments have exactly same semantics as with `Copy File` keyword. 
        Destination file path is returned. 
 
        If the source and destination are on the same filesystem, rename 
        operation is used. Otherwise file is copied to the destination 
        filesystem and then removed from the original filesystem. 
 
        See also `Move Files`, `Copy File`, and `Copy Files`. 
        &quot;&quot;&quot;</span>
        <span class="s1">source</span><span class="s3">, </span><span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_file</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_are_source_and_destination_same_file</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">, </span><span class="s1">source</span><span class="s3">):</span>
            <span class="s1">shutil</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Moved file from '%s' to '%s'.&quot;</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">copy_files</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">sources_and_destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Copies specified files to the target directory. 
 
        Source files can be given as exact paths and as glob patterns (see 
        `Glob patterns`). At least one source must be given, but it is 
        not an error if it is a pattern that does not match anything. 
 
        Last argument must be the destination directory. If the destination 
        does not exist, it will be created. 
 
        Examples: 
        | Copy Files | ${dir}/file1.txt  | ${dir}/file2.txt | ${dir2} | 
        | Copy Files | ${dir}/file-*.txt | ${dir2}          |         | 
 
        See also `Copy File`, `Move File`, and `Move Files`. 
        &quot;&quot;&quot;</span>
        <span class="s1">sources</span><span class="s3">, </span><span class="s1">dest </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_files</span><span class="s3">(</span><span class="s1">sources_and_destination</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">copy_file</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_prepare_copy_and_move_files</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">items</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">) &lt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">&quot;Must contain destination and at least one source.&quot;</span><span class="s3">)</span>
        <span class="s1">sources </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob_files</span><span class="s3">(</span><span class="s1">items</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">items</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_destination_directory_exists</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sources</span><span class="s3">, </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">_glob_files</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">patterns</span><span class="s3">):</span>
        <span class="s1">files </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">patterns</span><span class="s3">:</span>
            <span class="s1">files</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_glob</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">files</span>

    <span class="s2">def </span><span class="s1">move_files</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">sources_and_destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Moves specified files to the target directory. 
 
        Arguments have exactly same semantics as with `Copy Files` keyword. 
 
        See also `Move File`, `Copy File`, and `Copy Files`. 
        &quot;&quot;&quot;</span>
        <span class="s1">sources</span><span class="s3">, </span><span class="s1">dest </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_files</span><span class="s3">(</span><span class="s1">sources_and_destination</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">move_file</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">copy_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Copies the source directory into the destination. 
 
        If the destination exists, the source is copied under it. Otherwise 
        the destination directory and the possible missing intermediate 
        directories are created. 
        &quot;&quot;&quot;</span>
        <span class="s1">source</span><span class="s3">, </span><span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_directory</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">shutil</span><span class="s3">.</span><span class="s1">copytree</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Copied directory from '%s' to '%s'.&quot;</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_prepare_copy_and_move_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s1">source </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">source</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Source '</span><span class="s2">{</span><span class="s1">source</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">source</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Source '</span><span class="s2">{</span><span class="s1">source</span><span class="s2">}</span><span class="s4">' is not a directory.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Destination '</span><span class="s2">{</span><span class="s1">destination</span><span class="s2">}</span><span class="s4">' is not a directory.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">):</span>
            <span class="s1">base </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
            <span class="s1">destination </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">, </span><span class="s1">base</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">parent </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">destination</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">):</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">makedirs</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span>

    <span class="s2">def </span><span class="s1">move_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Moves the source directory into a destination. 
 
        Uses `Copy Directory` keyword internally, and ``source`` and 
        ``destination`` arguments have exactly same semantics as with 
        that keyword. 
        &quot;&quot;&quot;</span>
        <span class="s1">source</span><span class="s3">, </span><span class="s1">destination </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_copy_and_move_directory</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">shutil</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Moved directory from '%s' to '%s'.&quot;</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">)</span>

    <span class="s0"># Environment Variables</span>

    <span class="s3">@</span><span class="s1">keyword</span><span class="s3">(</span><span class="s1">types</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">get_environment_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the value of an environment variable with the given name. 
 
        If no environment variable is found, returns possible default value. 
        If no default value is given, the keyword fails. 
 
        Returned variables are automatically decoded to Unicode using 
        the system encoding. 
 
        Note that you can also access environment variables directly using 
        the variable syntax ``%{ENV_VAR_NAME}``. 
        &quot;&quot;&quot;</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">get_env_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">set_environment_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Sets an environment variable to a specified value. 
 
        Values are converted to strings automatically. Set variables are 
        automatically encoded using the system encoding. 
        &quot;&quot;&quot;</span>
        <span class="s1">set_env_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' set to value '</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">append_to_environment_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, *</span><span class="s1">values</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">=</span><span class="s1">os</span><span class="s3">.</span><span class="s1">pathsep</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Appends given ``values`` to environment variable ``name``. 
 
        If the environment variable already exists, values are added after it, 
        and otherwise a new environment variable is created. 
 
        Values are, by default, joined together using the operating system 
        path separator (``;`` on Windows, ``:`` elsewhere). This can be changed 
        by giving a separator after the values like ``separator=value``. 
 
        Examples (assuming ``NAME`` and ``NAME2`` do not exist initially): 
        | Append To Environment Variable | NAME     | first  |       | 
        | Should Be Equal                | %{NAME}  | first  |       | 
        | Append To Environment Variable | NAME     | second | third | 
        | Should Be Equal                | %{NAME}  | first${:}second${:}third | 
        | Append To Environment Variable | NAME2    | first  | separator=-     | 
        | Should Be Equal                | %{NAME2} | first  |                 | 
        | Append To Environment Variable | NAME2    | second | separator=-     | 
        | Should Be Equal                | %{NAME2} | first-second             | 
        &quot;&quot;&quot;</span>
        <span class="s1">sentinel </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>
        <span class="s1">initial </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_environment_variable</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">sentinel</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">initial </span><span class="s2">is not </span><span class="s1">sentinel</span><span class="s3">:</span>
            <span class="s1">values </span><span class="s3">= (</span><span class="s1">initial</span><span class="s3">, *</span><span class="s1">values</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_environment_variable</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">values</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">remove_environment_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">names</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Deletes the specified environment variable. 
 
        Does nothing if the environment variable is not set. 
 
        It is possible to remove multiple variables by passing them to this 
        keyword as separate arguments. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names</span><span class="s3">:</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">del_env_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">value</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' deleted.&quot;</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">environment_variable_should_be_set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the specified environment variable is not set. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">get_env_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' is not set.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' is set to '</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">environment_variable_should_not_be_set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Fails if the specified environment variable is set. 
 
        The default error message can be overridden with the ``msg`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">get_env_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' is set to '</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s4">'.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;Environment variable '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' is not set.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_environment_variables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns currently available environment variables as a dictionary. 
 
        Both keys and values are decoded to Unicode using the system encoding. 
        Altering the returned dictionary has no effect on the actual environment 
        variables. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">get_env_vars</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">log_environment_variables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s4">&quot;INFO&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Logs all environment variables using the given log level. 
 
        Environment variables are also returned the same way as with 
        `Get Environment Variables` keyword. 
        &quot;&quot;&quot;</span>
        <span class="s1">variables </span><span class="s3">= </span><span class="s1">get_env_vars</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">variables</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">item</span><span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_log</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">= </span><span class="s2">{</span><span class="s1">variables</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">level</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">variables</span>

    <span class="s0"># Path</span>

    <span class="s2">def </span><span class="s1">join_path</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, *</span><span class="s1">parts</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Joins the given path part(s) to the given base path. 
 
        The path separator (``/`` or ``\\``) is inserted when needed and 
        the possible absolute paths handled as expected. The resulted 
        path is also normalized. 
 
        Examples: 
        | ${path} = | Join Path | my        | path  | 
        | ${p2} =   | Join Path | my/       | path/ | 
        | ${p3} =   | Join Path | my        | path  | my | file.txt | 
        | ${p4} =   | Join Path | my        | /path | 
        | ${p5} =   | Join Path | /my/path/ | ..    | path2 | 
        =&gt; 
        - ${path} = 'my/path' 
        - ${p2} = 'my/path' 
        - ${p3} = 'my/path/my/file.txt' 
        - ${p4} = '/path' 
        - ${p5} = '/my/path2' 
        &quot;&quot;&quot;</span>
        <span class="s0"># FIXME: Is normalizing parts needed anymore?</span>
        <span class="s1">parts </span><span class="s3">= [</span>
            <span class="s1">str</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">pathlib</span><span class="s3">.</span><span class="s1">Path</span><span class="s3">) </span><span class="s2">else </span><span class="s1">p</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;/&quot;</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s3">(</span><span class="s1">base</span><span class="s3">, *</span><span class="s1">parts</span><span class="s3">)</span>
        <span class="s3">]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_path</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(*</span><span class="s1">parts</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">join_paths</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, *</span><span class="s1">paths</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Joins given paths with base and returns resulted paths. 
 
        See `Join Path` for more information. 
 
        Examples: 
        | @{p1} = | Join Paths | base     | example       | other |          | 
        | @{p2} = | Join Paths | /my/base | /example      | other |          | 
        | @{p3} = | Join Paths | my/base  | example/path/ | other | one/more | 
        =&gt; 
        - @{p1} = ['base/example', 'base/other'] 
        - @{p2} = ['/example', '/my/base/other'] 
        - @{p3} = ['my/base/example/path', 'my/base/other', 'my/base/one/more'] 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">join_path</span><span class="s3">(</span><span class="s1">base</span><span class="s3">, </span><span class="s1">path</span><span class="s3">) </span><span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">paths</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">normalize_path</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">case_normalize</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Normalizes the given path. 
 
        - Collapses redundant separators and up-level references. 
        - Converts ``/`` to ``\\`` on Windows. 
        - Replaces initial ``~`` or ``~user`` by that user's home directory. 
        - If ``case_normalize`` is given a true value (see `Boolean arguments`) 
          on Windows, converts the path to all lowercase. 
        - Converts ``pathlib.Path`` instances to ``str``. 
 
        Examples: 
        | ${path1} = | Normalize Path | abc/           | 
        | ${path2} = | Normalize Path | abc/../def     | 
        | ${path3} = | Normalize Path | abc/./def//ghi | 
        | ${path4} = | Normalize Path | ~robot/stuff   | 
        =&gt; 
        - ${path1} = 'abc' 
        - ${path2} = 'def' 
        - ${path3} = 'abc/def/ghi' 
        - ${path4} = '/home/robot/stuff' 
 
        On Windows result would use ``\\`` instead of ``/`` and home directory 
        would be different. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pathlib</span><span class="s3">.</span><span class="s1">Path</span><span class="s3">):</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;/&quot;</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">)</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">expanduser</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>
        <span class="s0"># os.path.normcase doesn't normalize on OSX which also, by default,</span>
        <span class="s0"># has case-insensitive file system. Our robot.utils.normpath would</span>
        <span class="s0"># do that, but it's not certain would that, or other things that the</span>
        <span class="s0"># utility do, desirable.</span>
        <span class="s2">if </span><span class="s1">case_normalize</span><span class="s3">:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normcase</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">path </span><span class="s2">or </span><span class="s4">&quot;.&quot;</span>

    <span class="s2">def </span><span class="s1">split_path</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Splits the given path from the last path separator (``/`` or ``\\``). 
 
        The given path is first normalized (e.g. a possible trailing 
        path separator is removed, special directories ``..`` and ``.`` 
        removed). The parts that are split are returned as separate 
        components. 
 
        Examples: 
        | ${path1} | ${dir} =  | Split Path | abc/def         | 
        | ${path2} | ${file} = | Split Path | abc/def/ghi.txt | 
        | ${path3} | ${d2}  =  | Split Path | abc/../def/ghi/ | 
        =&gt; 
        - ${path1} = 'abc' &amp; ${dir} = 'def' 
        - ${path2} = 'abc/def' &amp; ${file} = 'ghi.txt' 
        - ${path3} = 'def' &amp; ${d2} = 'ghi' 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_path</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">split_extension</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Splits the extension from the given path. 
 
        The given path is first normalized (e.g. possible trailing 
        path separators removed, special directories ``..`` and ``.`` 
        removed). The base path and extension are returned as separate 
        components so that the dot used as an extension separator is 
        removed. If the path contains no extension, an empty string is 
        returned for it. Possible leading and trailing dots in the file 
        name are never considered to be extension separators. 
 
        Examples: 
        | ${path} | ${ext} = | Split Extension | file.extension    | 
        | ${p2}   | ${e2} =  | Split Extension | path/file.ext     | 
        | ${p3}   | ${e3} =  | Split Extension | path/file         | 
        | ${p4}   | ${e4} =  | Split Extension | p1/../p2/file.ext | 
        | ${p5}   | ${e5} =  | Split Extension | path/.file.ext    | 
        | ${p6}   | ${e6} =  | Split Extension | path/.file        | 
        =&gt; 
        - ${path} = 'file' &amp; ${ext} = 'extension' 
        - ${p2} = 'path/file' &amp; ${e2} = 'ext' 
        - ${p3} = 'path/file' &amp; ${e3} = '' 
        - ${p4} = 'p2/file' &amp; ${e4} = 'ext' 
        - ${p5} = 'path/.file' &amp; ${e5} = 'ext' 
        - ${p6} = 'path/.file' &amp; ${e6} = '' 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_path</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">basename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">basename</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;.&quot; </span><span class="s3">* </span><span class="s1">basename</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">path</span><span class="s3">, </span><span class="s4">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">path</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">):</span>
            <span class="s1">path2 </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)</span>
            <span class="s1">trailing_dots </span><span class="s3">= </span><span class="s4">&quot;.&quot; </span><span class="s3">* (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">path2</span><span class="s3">))</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">path2</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">trailing_dots </span><span class="s3">= </span><span class="s4">&quot;&quot;</span>
        <span class="s1">basepath</span><span class="s3">, </span><span class="s1">extension </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">splitext</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">extension</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">):</span>
            <span class="s1">extension </span><span class="s3">= </span><span class="s1">extension</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>
        <span class="s2">if </span><span class="s1">extension</span><span class="s3">:</span>
            <span class="s1">extension </span><span class="s3">+= </span><span class="s1">trailing_dots</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">basepath </span><span class="s3">+= </span><span class="s1">trailing_dots</span>
        <span class="s2">return </span><span class="s1">basepath</span><span class="s3">, </span><span class="s1">extension</span>

    <span class="s0"># Misc</span>

    <span class="s2">def </span><span class="s1">get_modified_time</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">&quot;timestamp&quot;</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the last modification time of a file or directory. 
 
        How time is returned is determined based on the given ``format`` 
        string as follows. Note that all checks are case-insensitive. 
        Returned time is also automatically logged. 
 
        1) If ``format`` contains the word ``epoch``, the time is returned 
           in seconds after the UNIX epoch. The return value is always 
           an integer. 
 
        2) If ``format`` contains any of the words ``year``, ``month``, 
           ``day``, ``hour``, ``min`` or ``sec``, only the selected parts are 
           returned. The order of the returned parts is always the one 
           in the previous sentence and the order of the words in 
           ``format`` is not significant. The parts are returned as 
           zero-padded strings (e.g. May -&gt; ``05``). 
 
        3) Otherwise, and by default, the time is returned as a 
           timestamp string in the format ``2006-02-24 15:08:31``. 
 
        Examples (when the modified time of ``${CURDIR}`` is 
        2006-03-29 15:06:21): 
        | ${time} = | Get Modified Time | ${CURDIR} | 
        | ${secs} = | Get Modified Time | ${CURDIR} | epoch | 
        | ${year} = | Get Modified Time | ${CURDIR} | return year | 
        | ${y} | ${d} = | Get Modified Time | ${CURDIR} | year,day | 
        | @{time} = | Get Modified Time | ${CURDIR} | year,month,day,hour,min,sec | 
        =&gt; 
        - ${time} = '2006-03-29 15:06:21' 
        - ${secs} = 1143637581 
        - ${year} = '2006' 
        - ${y} = '2006' &amp; ${d} = '29' 
        - @{time} = ['2006', '03', '29', '15', '06', '21'] 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">mtime </span><span class="s3">= </span><span class="s1">get_time</span><span class="s3">(</span><span class="s1">format</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">stat</span><span class="s3">(</span><span class="s1">path</span><span class="s3">).</span><span class="s1">st_mtime</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">f&quot;Last modified time of '%s' is </span><span class="s2">{</span><span class="s1">mtime</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mtime</span>

    <span class="s2">def </span><span class="s1">set_modified_time</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">mtime</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Sets the file modification and access times. 
 
        Changes the modification and access times of the given file to 
        the value determined by ``mtime``. The time can be given in 
        different formats described below. Note that all checks 
        involving strings are case-insensitive. Modified time can only 
        be set to regular files. 
 
        1) If ``mtime`` is a number, or a string that can be converted 
           to a number, it is interpreted as seconds since the UNIX 
           epoch (1970-01-01 00:00:00 UTC). This documentation was 
           originally written about 1177654467 seconds after the epoch. 
 
        2) If ``mtime`` is a timestamp, that time will be used. Valid 
           timestamp formats are ``YYYY-MM-DD hh:mm:ss`` and 
           ``YYYYMMDD hhmmss``. 
 
        3) If ``mtime`` is equal to ``NOW``, the current local time is used. 
 
        4) If ``mtime`` is equal to ``UTC``, the current time in 
           [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC] 
           is used. 
 
        5) If ``mtime`` is in the format like ``NOW - 1 day`` or ``UTC + 1 
           hour 30 min``, the current local/UTC time plus/minus the time 
           specified with the time string is used. The time string format 
           is described in an appendix of Robot Framework User Guide. 
 
        Examples: 
        | Set Modified Time | /path/file | 1177654467         | # Time given as epoch seconds | 
        | Set Modified Time | /path/file | 2007-04-27 9:14:27 | # Time given as a timestamp   | 
        | Set Modified Time | /path/file | NOW                | # The local time of execution | 
        | Set Modified Time | /path/file | NOW - 1 day        | # 1 day subtracted from the local time | 
        | Set Modified Time | /path/file | UTC + 1h 2min 3s   | # 1h 2min 3s added to the UTC time | 
        &quot;&quot;&quot;</span>
        <span class="s1">mtime </span><span class="s3">= </span><span class="s1">parse_time</span><span class="s3">(</span><span class="s1">mtime</span><span class="s3">)</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' is not a regular file.&quot;</span><span class="s3">)</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">utime</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, (</span><span class="s1">mtime</span><span class="s3">, </span><span class="s1">mtime</span><span class="s3">))</span>
        <span class="s1">time</span><span class="s3">.</span><span class="s1">sleep</span><span class="s3">(</span><span class="s6">0.1</span><span class="s3">)  </span><span class="s0"># Give OS some time to really set these times.</span>
        <span class="s1">tstamp </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">fromtimestamp</span><span class="s3">(</span><span class="s1">mtime</span><span class="s3">).</span><span class="s1">isoformat</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s1">timespec</span><span class="s3">=</span><span class="s4">&quot;seconds&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">f&quot;Set modified time of '%s' to </span><span class="s2">{</span><span class="s1">tstamp</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_file_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns and logs file size as an integer in bytes.&quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;File '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">stat</span><span class="s3">(</span><span class="s1">path</span><span class="s3">).</span><span class="s1">st_size</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">f&quot;Size of file '%s' is </span><span class="s2">{</span><span class="s1">size</span><span class="s2">} </span><span class="s4">byte</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">size</span>

    <span class="s2">def </span><span class="s1">list_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns and logs items in a directory, optionally filtered with ``pattern``. 
 
        File and directory names are returned in case-sensitive alphabetical 
        order, e.g. ``['A Name', 'Second', 'a lower case name', 'one more']``. 
        Implicit directories ``.`` and ``..`` are not returned. The returned 
        items are automatically logged. 
 
        File and directory names are returned relative to the given path 
        (e.g. ``'file.txt'``) by default. If you want them be returned in 
        absolute format (e.g. ``'/home/robot/file.txt'``), give the ``absolute`` 
        argument a true value (see `Boolean arguments`). 
 
        If ``pattern`` is given, only items matching it are returned. The pattern 
        is considered to be a _glob pattern_ and the full syntax is explained in 
        the `Glob patterns` section. With this keyword matching is always 
        case-sensitive. 
 
        Examples (using also other `List Directory` variants): 
        | @{items} = | List Directory           | ${TEMPDIR} | 
        | @{files} = | List Files In Directory  | /tmp | *.txt | absolute | 
        | ${count} = | Count Files In Directory | ${CURDIR} | ??? | 
        &quot;&quot;&quot;</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span><span class="s2">} </span><span class="s4">item</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span><span class="s2">}</span><span class="s4">:</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">+ </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">items</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">list_files_in_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Wrapper for `List Directory` that returns only files.&quot;&quot;&quot;</span>
        <span class="s1">files </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_files_in_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">files</span><span class="s3">)</span><span class="s2">} </span><span class="s4">file</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">files</span><span class="s3">)</span><span class="s2">}</span><span class="s4">:</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">+ </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">files</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">files</span>

    <span class="s2">def </span><span class="s1">list_directories_in_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Wrapper for `List Directory` that returns only directories.&quot;&quot;&quot;</span>
        <span class="s1">dirs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dirs_in_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">)</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s4">&quot;directory&quot; </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dirs</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">else </span><span class="s4">&quot;directories&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">dirs</span><span class="s3">)</span><span class="s2">} {</span><span class="s1">label</span><span class="s2">}</span><span class="s4">:</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">+ </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirs</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">dirs</span>

    <span class="s2">def </span><span class="s1">count_items_in_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Returns and logs the number of all items in the given directory. 
 
        The argument ``pattern`` has the same semantics as with `List Directory` 
        keyword. The count is returned as an integer, so it must be checked e.g. 
        with the built-in keyword `Should Be Equal As Integers`. 
        &quot;&quot;&quot;</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">count</span><span class="s2">} </span><span class="s4">item</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">count</span>

    <span class="s2">def </span><span class="s1">count_files_in_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Wrapper for `Count Items In Directory` returning only file count.&quot;&quot;&quot;</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_files_in_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">count</span><span class="s2">} </span><span class="s4">file</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">count</span>

    <span class="s2">def </span><span class="s1">count_directories_in_directory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Wrapper for `Count Items In Directory` returning only directory count.&quot;&quot;&quot;</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dirs_in_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">))</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s4">&quot;directory&quot; </span><span class="s2">if </span><span class="s1">count </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">else </span><span class="s4">&quot;directories&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_info</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">count</span><span class="s2">} {</span><span class="s1">label</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">count</span>

    <span class="s2">def </span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Listing contents of directory '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Directory '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' does not exist.&quot;</span><span class="s3">)</span>
        <span class="s0"># result is already unicode but safe_str also handles NFC normalization</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">safe_str</span><span class="s3">(</span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">listdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">pattern</span><span class="s3">:</span>
            <span class="s1">items </span><span class="s3">= [</span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">items </span><span class="s2">if </span><span class="s1">fnmatch</span><span class="s3">.</span><span class="s1">fnmatchcase</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">absolute</span><span class="s3">:</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">normpath</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s1">items </span><span class="s3">= [</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">item</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">_list_files_in_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s1">item</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">item</span><span class="s3">))</span>
        <span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_list_dirs_in_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s1">item</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_list_dir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">item</span><span class="s3">))</span>
        <span class="s3">]</span>

    <span class="s2">def </span><span class="s1">touch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Emulates the UNIX touch command. 
 
        Creates a file, if it does not exist. Otherwise changes its access and 
        modification times to the current time. 
 
        Fails if used with the directories or the parent directory of the given 
        file does not exist. 
        &quot;&quot;&quot;</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s4">f&quot;Cannot touch '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' because it is a directory.&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span>
                <span class="s4">f&quot;Cannot touch '</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s4">' because its parent directory does not exist.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s1">mtime </span><span class="s3">= </span><span class="s1">round</span><span class="s3">(</span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">())</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">utime</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, (</span><span class="s1">mtime</span><span class="s3">, </span><span class="s1">mtime</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Touched existing file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;ASCII&quot;</span><span class="s3">).</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_link</span><span class="s3">(</span><span class="s4">&quot;Touched new file '%s'.&quot;</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_absnorm</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">abspath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">normalize_path</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_fail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">messages</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">next</span><span class="s3">(</span><span class="s1">msg </span><span class="s2">for </span><span class="s1">msg </span><span class="s2">in </span><span class="s1">messages </span><span class="s2">if </span><span class="s1">msg</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_log</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">&quot;INFO&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_link</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, *</span><span class="s1">paths</span><span class="s3">):</span>
        <span class="s1">paths </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s4">f'&lt;a href=&quot;file://</span><span class="s2">{</span><span class="s1">p</span><span class="s2">}</span><span class="s4">&quot;&gt;</span><span class="s2">{</span><span class="s1">p</span><span class="s2">}</span><span class="s4">&lt;/a&gt;' </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">paths</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_log</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">paths</span><span class="s3">, </span><span class="s4">&quot;HTML&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_warn</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_log</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s4">&quot;WARN&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_log</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">level</span><span class="s3">):</span>
        <span class="s1">logger</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">level</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_Process</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_command </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_command</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_process </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">popen</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_command</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_command</span>

    <span class="s2">def </span><span class="s1">read</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_output</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process</span><span class="s3">.</span><span class="s1">read</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">rc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">IOError</span><span class="s3">:  </span><span class="s0"># Has occurred sometimes in Windows</span>
            <span class="s2">return </span><span class="s6">255</span>
        <span class="s2">if </span><span class="s1">rc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">0</span>
        <span class="s0"># In Windows return code is value returned by</span>
        <span class="s0"># command (can be almost anything)</span>
        <span class="s0"># In other OS:</span>
        <span class="s0">#   Return code must be converted with 'rc &gt;&gt; 8' and it is</span>
        <span class="s0">#   between 0-255 after conversion</span>
        <span class="s2">if </span><span class="s1">WINDOWS</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">rc </span><span class="s3">% </span><span class="s6">256</span>
        <span class="s2">return </span><span class="s1">rc </span><span class="s3">&gt;&gt; </span><span class="s6">8</span>

    <span class="s2">def </span><span class="s1">_process_command</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s4">&quot;&gt;&quot; </span><span class="s2">not in </span><span class="s1">command</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">command</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;&amp;&quot;</span><span class="s3">):</span>
                <span class="s1">command </span><span class="s3">= </span><span class="s1">command</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">] + </span><span class="s4">&quot; 2&gt;&amp;1 &amp;&quot;</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">command </span><span class="s3">+= </span><span class="s4">&quot; 2&gt;&amp;1&quot;</span>
        <span class="s2">return </span><span class="s1">command</span>

    <span class="s2">def </span><span class="s1">_process_output</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">output</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot; </span><span class="s2">in </span><span class="s1">output</span><span class="s3">:</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\r\n</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">output</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">):</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">console_decode</span><span class="s3">(</span><span class="s1">output</span><span class="s3">)</span>
</pre>
</body>
</html>