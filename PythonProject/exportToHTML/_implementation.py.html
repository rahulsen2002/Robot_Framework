<html>
<head>
<title>_implementation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_implementation.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">dataclasses</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Mapping</span>

<span class="s0">from </span><span class="s1">pip</span><span class="s2">.</span><span class="s1">_vendor</span><span class="s2">.</span><span class="s1">packaging</span><span class="s2">.</span><span class="s1">requirements </span><span class="s0">import </span><span class="s1">Requirement</span>


<span class="s0">def </span><span class="s1">_normalize_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s1">re</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s3">r&quot;[-_.]+&quot;</span><span class="s2">, </span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">).</span><span class="s1">lower</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_normalize_group_names</span><span class="s2">(</span>
    <span class="s1">dependency_groups</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str </span><span class="s2">| </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]],</span>
<span class="s2">) </span><span class="s1">-&gt; Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str </span><span class="s2">| </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]]:</span>
    <span class="s1">original_names</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]] = {}</span>
    <span class="s1">normalized_groups </span><span class="s2">= {}</span>

    <span class="s0">for </span><span class="s1">group_name</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">dependency_groups</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">normed_group_name </span><span class="s2">= </span><span class="s1">_normalize_name</span><span class="s2">(</span><span class="s1">group_name</span><span class="s2">)</span>
        <span class="s1">original_names</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">normed_group_name</span><span class="s2">, []).</span><span class="s1">append</span><span class="s2">(</span><span class="s1">group_name</span><span class="s2">)</span>
        <span class="s1">normalized_groups</span><span class="s2">[</span><span class="s1">normed_group_name</span><span class="s2">] = </span><span class="s1">value</span>

    <span class="s1">errors </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">normed_name</span><span class="s2">, </span><span class="s1">names </span><span class="s0">in </span><span class="s1">original_names</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">names</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">errors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">normed_name</span><span class="s0">} </span><span class="s3">(</span><span class="s0">{</span><span class="s3">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">names</span><span class="s2">)</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">errors</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Duplicate dependency group names: </span><span class="s0">{</span><span class="s3">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">normalized_groups</span>


<span class="s2">@</span><span class="s1">dataclasses</span><span class="s2">.</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">DependencyGroupInclude</span><span class="s2">:</span>
    <span class="s1">include_group</span><span class="s2">: </span><span class="s1">str</span>


<span class="s0">class </span><span class="s1">CyclicDependencyError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    An error representing the detection of a cycle. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">requested_group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">include_group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">requested_group </span><span class="s2">= </span><span class="s1">requested_group</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">group </span><span class="s2">= </span><span class="s1">group</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">include_group </span><span class="s2">= </span><span class="s1">include_group</span>

        <span class="s0">if </span><span class="s1">include_group </span><span class="s2">== </span><span class="s1">group</span><span class="s2">:</span>
            <span class="s1">reason </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">group</span><span class="s0">} </span><span class="s3">includes itself&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">reason </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">include_group</span><span class="s0">} </span><span class="s3">-&gt; </span><span class="s0">{</span><span class="s1">group</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">group</span><span class="s0">} </span><span class="s3">-&gt; </span><span class="s0">{</span><span class="s1">include_group</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s3">&quot;Cyclic dependency group include while resolving &quot;</span>
            <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">requested_group</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">reason</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">DependencyGroupResolver</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    A resolver for Dependency Group data. 
 
    This class handles caching, name normalization, cycle detection, and other 
    parsing requirements. There are only two public methods for exploring the data: 
    ``lookup()`` and ``resolve()``. 
 
    :param dependency_groups: A mapping, as provided via pyproject 
        ``[dependency-groups]``. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dependency_groups</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str </span><span class="s2">| </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]],</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dependency_groups</span><span class="s2">, </span><span class="s1">Mapping</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Dependency Groups table is not a mapping&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dependency_groups </span><span class="s2">= </span><span class="s1">_normalize_group_names</span><span class="s2">(</span><span class="s1">dependency_groups</span><span class="s2">)</span>
        <span class="s6"># a map of group names to parsed data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_groups</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span>
            <span class="s1">str</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Requirement </span><span class="s2">| </span><span class="s1">DependencyGroupInclude</span><span class="s2">, ...]</span>
        <span class="s2">] = {}</span>
        <span class="s6"># a map of group names to their ancestors, used for cycle detection</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_include_graph_ancestors</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...]] = {}</span>
        <span class="s6"># a cache of completed resolutions to Requirement lists</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_cache</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">, ...]] = {}</span>

    <span class="s0">def </span><span class="s1">lookup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Requirement </span><span class="s2">| </span><span class="s1">DependencyGroupInclude</span><span class="s2">, ...]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Lookup a group name, returning the parsed dependency data for that group. 
        This will not resolve includes. 
 
        :param group: the name of the group to lookup 
 
        :raises ValueError: if the data does not appear to be valid dependency group 
            data 
        :raises TypeError: if the data is not a string 
        :raises LookupError: if group name is absent 
        :raises packaging.requirements.InvalidRequirement: if a specifier is not valid 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">group</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Dependency group name is not a str&quot;</span><span class="s2">)</span>
        <span class="s1">group </span><span class="s2">= </span><span class="s1">_normalize_name</span><span class="s2">(</span><span class="s1">group</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parse_group</span><span class="s2">(</span><span class="s1">group</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">resolve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">, ...]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Resolve a dependency group to a list of requirements. 
 
        :param group: the name of the group to resolve 
 
        :raises TypeError: if the inputs appear to be the wrong types 
        :raises ValueError: if the data does not appear to be valid dependency group 
            data 
        :raises LookupError: if group name is absent 
        :raises packaging.requirements.InvalidRequirement: if a specifier is not valid 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">group</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Dependency group name is not a str&quot;</span><span class="s2">)</span>
        <span class="s1">group </span><span class="s2">= </span><span class="s1">_normalize_name</span><span class="s2">(</span><span class="s1">group</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve</span><span class="s2">(</span><span class="s1">group</span><span class="s2">, </span><span class="s1">group</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_parse_group</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">group</span><span class="s2">: </span><span class="s1">str</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Requirement </span><span class="s2">| </span><span class="s1">DependencyGroupInclude</span><span class="s2">, ...]:</span>
        <span class="s6"># short circuit -- never do the work twice</span>
        <span class="s0">if </span><span class="s1">group </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_groups</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_groups</span><span class="s2">[</span><span class="s1">group</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">group </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dependency_groups</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">LookupError</span><span class="s2">(</span><span class="s3">f&quot;Dependency group '</span><span class="s0">{</span><span class="s1">group</span><span class="s0">}</span><span class="s3">' not found&quot;</span><span class="s2">)</span>

        <span class="s1">raw_group </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dependency_groups</span><span class="s2">[</span><span class="s1">group</span><span class="s2">]</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">raw_group</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">f&quot;Dependency group '</span><span class="s0">{</span><span class="s1">group</span><span class="s0">}</span><span class="s3">' is not a list&quot;</span><span class="s2">)</span>

        <span class="s1">elements</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Requirement </span><span class="s2">| </span><span class="s1">DependencyGroupInclude</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">raw_group</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s6"># packaging.requirements.Requirement parsing ensures that this is a</span>
                <span class="s6"># valid PEP 508 Dependency Specifier</span>
                <span class="s6"># raises InvalidRequirement on failure</span>
                <span class="s1">elements</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">Requirement</span><span class="s2">(</span><span class="s1">item</span><span class="s2">))</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">item</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) != (</span><span class="s3">&quot;include-group&quot;</span><span class="s2">,):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Invalid dependency group item: </span><span class="s0">{</span><span class="s1">item</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>

                <span class="s1">include_group </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">item</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()))</span>
                <span class="s1">elements</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DependencyGroupInclude</span><span class="s2">(</span><span class="s1">include_group</span><span class="s2">=</span><span class="s1">include_group</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Invalid dependency group item: </span><span class="s0">{</span><span class="s1">item</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_groups</span><span class="s2">[</span><span class="s1">group</span><span class="s2">] = </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_groups</span><span class="s2">[</span><span class="s1">group</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_resolve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">requested_group</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Requirement</span><span class="s2">, ...]:</span>
        <span class="s5">&quot;&quot;&quot; 
        This is a helper for cached resolution to strings. 
 
        :param group: The name of the group to resolve. 
        :param requested_group: The group which was used in the original, user-facing 
            request. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">group </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_cache</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_cache</span><span class="s2">[</span><span class="s1">group</span><span class="s2">]</span>

        <span class="s1">parsed </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parse_group</span><span class="s2">(</span><span class="s1">group</span><span class="s2">)</span>

        <span class="s1">resolved_group </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">parsed</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, </span><span class="s1">Requirement</span><span class="s2">):</span>
                <span class="s1">resolved_group</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">item</span><span class="s2">, </span><span class="s1">DependencyGroupInclude</span><span class="s2">):</span>
                <span class="s1">include_group </span><span class="s2">= </span><span class="s1">_normalize_name</span><span class="s2">(</span><span class="s1">item</span><span class="s2">.</span><span class="s1">include_group</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">include_group </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_include_graph_ancestors</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">group</span><span class="s2">, ()):</span>
                    <span class="s0">raise </span><span class="s1">CyclicDependencyError</span><span class="s2">(</span>
                        <span class="s1">requested_group</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">item</span><span class="s2">.</span><span class="s1">include_group</span>
                    <span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_include_graph_ancestors</span><span class="s2">[</span><span class="s1">include_group</span><span class="s2">] = (</span>
                    <span class="s2">*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_include_graph_ancestors</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">group</span><span class="s2">, ()),</span>
                    <span class="s1">group</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s1">resolved_group</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve</span><span class="s2">(</span><span class="s1">include_group</span><span class="s2">, </span><span class="s1">requested_group</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:  </span><span class="s6"># unreachable</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s3">f&quot;Invalid dependency group item after parse: </span><span class="s0">{</span><span class="s1">item</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_cache</span><span class="s2">[</span><span class="s1">group</span><span class="s2">] = </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">resolved_group</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_cache</span><span class="s2">[</span><span class="s1">group</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">resolve</span><span class="s2">(</span>
    <span class="s1">dependency_groups</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str </span><span class="s2">| </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]], /, *</span><span class="s1">groups</span><span class="s2">: </span><span class="s1">str</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Resolve a dependency group to a tuple of requirements, as strings. 
 
    :param dependency_groups: the parsed contents of the ``[dependency-groups]`` table 
        from ``pyproject.toml`` 
    :param groups: the name of the group(s) to resolve 
 
    :raises TypeError: if the inputs appear to be the wrong types 
    :raises ValueError: if the data does not appear to be valid dependency group data 
    :raises LookupError: if group name is absent 
    :raises packaging.requirements.InvalidRequirement: if a specifier is not valid 
    &quot;&quot;&quot;</span>
    <span class="s1">resolver </span><span class="s2">= </span><span class="s1">DependencyGroupResolver</span><span class="s2">(</span><span class="s1">dependency_groups</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) </span><span class="s0">for </span><span class="s1">group </span><span class="s0">in </span><span class="s1">groups </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">resolver</span><span class="s2">.</span><span class="s1">resolve</span><span class="s2">(</span><span class="s1">group</span><span class="s2">))</span>
</pre>
</body>
</html>