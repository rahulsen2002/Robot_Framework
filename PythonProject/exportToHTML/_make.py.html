<html>
<head>
<title>_make.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_make.py</font>
</center></td></tr></table>
<pre><span class="s0"># SPDX-License-Identifier: MIT</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">linecache</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">unicodedata</span>

<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">NamedTuple</span><span class="s3">, </span><span class="s1">TypeVar</span>

<span class="s0"># We need to import _compat itself in addition to the _compat members to avoid</span>
<span class="s0"># having the thread-local in the globals here.</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_compat</span><span class="s3">, </span><span class="s1">_config</span><span class="s3">, </span><span class="s1">setters</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_compat </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">PY_3_10_PLUS</span><span class="s3">,</span>
    <span class="s1">PY_3_11_PLUS</span><span class="s3">,</span>
    <span class="s1">PY_3_13_PLUS</span><span class="s3">,</span>
    <span class="s1">_AnnotationExtractor</span><span class="s3">,</span>
    <span class="s1">_get_annotations</span><span class="s3">,</span>
    <span class="s1">get_generic_base</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">DefaultAlreadySetError</span><span class="s3">,</span>
    <span class="s1">FrozenInstanceError</span><span class="s3">,</span>
    <span class="s1">NotAnAttrsClassError</span><span class="s3">,</span>
    <span class="s1">UnannotatedAttributeError</span><span class="s3">,</span>
<span class="s3">)</span>


<span class="s0"># This is used at least twice, so cache it here.</span>
<span class="s1">_OBJ_SETATTR </span><span class="s3">= </span><span class="s1">object</span><span class="s3">.</span><span class="s1">__setattr__</span>
<span class="s1">_INIT_FACTORY_PAT </span><span class="s3">= </span><span class="s4">&quot;__attr_factory_%s&quot;</span>
<span class="s1">_CLASSVAR_PREFIXES </span><span class="s3">= (</span>
    <span class="s4">&quot;typing.ClassVar&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;t.ClassVar&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ClassVar&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;typing_extensions.ClassVar&quot;</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s0"># we don't use a double-underscore prefix because that triggers</span>
<span class="s0"># name mangling when trying to create a slot for the field</span>
<span class="s0"># (when slots=True)</span>
<span class="s1">_HASH_CACHE_FIELD </span><span class="s3">= </span><span class="s4">&quot;_attrs_cached_hash&quot;</span>

<span class="s1">_EMPTY_METADATA_SINGLETON </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MappingProxyType</span><span class="s3">({})</span>

<span class="s0"># Unique object for unequivocal getattr() defaults.</span>
<span class="s1">_SENTINEL </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>

<span class="s1">_DEFAULT_ON_SETATTR </span><span class="s3">= </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">pipe</span><span class="s3">(</span><span class="s1">setters</span><span class="s3">.</span><span class="s1">convert</span><span class="s3">, </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">validate</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_Nothing</span><span class="s3">(</span><span class="s1">enum</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Sentinel to indicate the lack of a value when `None` is ambiguous. 
 
    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show 
    that a value may be ``NOTHING``. 
 
    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False. 
    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant. 
    &quot;&quot;&quot;</span>

    <span class="s1">NOTHING </span><span class="s3">= </span><span class="s1">enum</span><span class="s3">.</span><span class="s1">auto</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">&quot;NOTHING&quot;</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return False</span>


<span class="s1">NOTHING </span><span class="s3">= </span><span class="s1">_Nothing</span><span class="s3">.</span><span class="s1">NOTHING</span>
<span class="s4">&quot;&quot;&quot; 
Sentinel to indicate the lack of a value when `None` is ambiguous. 
 
When using in 3rd party code, use `attrs.NothingType` for type annotations. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">_CacheHashWrapper</span><span class="s3">(</span><span class="s1">int</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    An integer subclass that pickles / copies as None 
 
    This is used for non-slots classes with ``cache_hash=True``, to avoid 
    serializing a potentially (even likely) invalid hash value. Since `None` 
    is the default value for uncalculated hashes, whenever this is copied, 
    the copy's value for the hash should automatically reset. 
 
    See GH #613 for more details. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__reduce__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">_none_constructor</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">), </span><span class="s1">_args</span><span class="s3">=()):  </span><span class="s0"># noqa: B008</span>
        <span class="s2">return </span><span class="s1">_none_constructor</span><span class="s3">, </span><span class="s1">_args</span>


<span class="s2">def </span><span class="s1">attrib</span><span class="s3">(</span>
    <span class="s1">default</span><span class="s3">=</span><span class="s1">NOTHING</span><span class="s3">,</span>
    <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">hash</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">metadata</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">converter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">factory</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">eq</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">on_setattr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">alias</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a new field / attribute on a class. 
 
    Identical to `attrs.field`, except it's not keyword-only. 
 
    Consider using `attrs.field` in new code (``attr.ib`` will *never* go away, 
    though). 
 
    ..  warning:: 
 
        Does **nothing** unless the class is also decorated with 
        `attr.s` (or similar)! 
 
 
    .. versionadded:: 15.2.0 *convert* 
    .. versionadded:: 16.3.0 *metadata* 
    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now. 
    .. versionchanged:: 17.1.0 
       *hash* is `None` and therefore mirrors *eq* by default. 
    .. versionadded:: 17.3.0 *type* 
    .. deprecated:: 17.4.0 *convert* 
    .. versionadded:: 17.4.0 
       *converter* as a replacement for the deprecated *convert* to achieve 
       consistency with other noun-based arguments. 
    .. versionadded:: 18.1.0 
       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``. 
    .. versionadded:: 18.2.0 *kw_only* 
    .. versionchanged:: 19.2.0 *convert* keyword argument removed. 
    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable. 
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01. 
    .. versionadded:: 19.2.0 *eq* and *order* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2 
    .. versionchanged:: 21.1.0 
       *eq*, *order*, and *cmp* also accept a custom callable 
    .. versionchanged:: 21.1.0 *cmp* undeprecated 
    .. versionadded:: 22.2.0 *alias* 
    &quot;&quot;&quot;</span>
    <span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">order_key </span><span class="s3">= </span><span class="s1">_determine_attrib_eq_order</span><span class="s3">(</span>
        <span class="s1">cmp</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s2">True</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hash </span><span class="s2">is not None and </span><span class="s1">hash </span><span class="s2">is not True and </span><span class="s1">hash </span><span class="s2">is not False</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">factory </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is not </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span>
                <span class="s4">&quot;The `default` and `factory` arguments are mutually exclusive.&quot;</span>
            <span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">factory</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The `factory` argument must be a callable.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s1">default </span><span class="s3">= </span><span class="s1">Factory</span><span class="s3">(</span><span class="s1">factory</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">metadata </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">metadata </span><span class="s3">= {}</span>

    <span class="s0"># Apply syntactic sugar by auto-wrapping.</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">on_setattr</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">on_setattr </span><span class="s3">= </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">pipe</span><span class="s3">(*</span><span class="s1">on_setattr</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">validator </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">validator</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">validator </span><span class="s3">= </span><span class="s1">and_</span><span class="s3">(*</span><span class="s1">validator</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">converter </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">converter</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">converter </span><span class="s3">= </span><span class="s1">pipe</span><span class="s3">(*</span><span class="s1">converter</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_CountingAttr</span><span class="s3">(</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s1">default</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">=</span><span class="s1">validator</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">=</span><span class="s1">repr</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">hash</span><span class="s3">=</span><span class="s1">hash</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">=</span><span class="s1">init</span><span class="s3">,</span>
        <span class="s1">converter</span><span class="s3">=</span><span class="s1">converter</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">type</span><span class="s3">,</span>
        <span class="s1">kw_only</span><span class="s3">=</span><span class="s1">kw_only</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">=</span><span class="s1">eq</span><span class="s3">,</span>
        <span class="s1">eq_key</span><span class="s3">=</span><span class="s1">eq_key</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">,</span>
        <span class="s1">order_key</span><span class="s3">=</span><span class="s1">order_key</span><span class="s3">,</span>
        <span class="s1">on_setattr</span><span class="s3">=</span><span class="s1">on_setattr</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s1">alias</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_compile_and_eval</span><span class="s3">(</span>
    <span class="s1">script</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">globs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">locs</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">filename</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Evaluate the script with the given global (globs) and local (locs) 
    variables. 
    &quot;&quot;&quot;</span>
    <span class="s1">bytecode </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">script</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s4">&quot;exec&quot;</span><span class="s3">)</span>
    <span class="s1">eval</span><span class="s3">(</span><span class="s1">bytecode</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_linecache_and_compile</span><span class="s3">(</span>
    <span class="s1">script</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">filename</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">globs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">locals</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Cache the script with _linecache_, compile it and return the _locals_. 
    &quot;&quot;&quot;</span>

    <span class="s1">locs </span><span class="s3">= {} </span><span class="s2">if </span><span class="s1">locals </span><span class="s2">is None else </span><span class="s1">locals</span>

    <span class="s0"># In order of debuggers like PDB being able to step through the code,</span>
    <span class="s0"># we add a fake linecache entry.</span>
    <span class="s1">count </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">base_filename </span><span class="s3">= </span><span class="s1">filename</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">linecache_tuple </span><span class="s3">= (</span>
            <span class="s1">len</span><span class="s3">(</span><span class="s1">script</span><span class="s3">),</span>
            <span class="s2">None</span><span class="s3">,</span>
            <span class="s1">script</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">(</span><span class="s2">True</span><span class="s3">),</span>
            <span class="s1">filename</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">old_val </span><span class="s3">= </span><span class="s1">linecache</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">linecache_tuple</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">old_val </span><span class="s3">== </span><span class="s1">linecache_tuple</span><span class="s3">:</span>
            <span class="s2">break</span>

        <span class="s1">filename </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">base_filename</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span><span class="s2">}</span><span class="s4">-</span><span class="s2">{</span><span class="s1">count</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>
        <span class="s1">count </span><span class="s3">+= </span><span class="s6">1</span>

    <span class="s1">_compile_and_eval</span><span class="s3">(</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">locs</span>


<span class="s2">def </span><span class="s1">_make_attr_tuple_class</span><span class="s3">(</span><span class="s1">cls_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">attr_names</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; type</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a tuple subclass to hold `Attribute`s for an `attrs` class. 
 
    The subclass is a bare tuple with properties for names. 
 
    class MyClassAttributes(tuple): 
        __slots__ = () 
        x = property(itemgetter(0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">attr_class_name </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls_name</span><span class="s2">}</span><span class="s4">Attributes&quot;</span>
    <span class="s1">body </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">attr_name </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">attr_names</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">getter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">=</span><span class="s1">i</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s1">body</span><span class="s3">[</span><span class="s1">attr_name</span><span class="s3">] = </span><span class="s1">property</span><span class="s3">(</span><span class="s1">getter</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">type</span><span class="s3">(</span><span class="s1">attr_class_name</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">,), </span><span class="s1">body</span><span class="s3">)</span>


<span class="s0"># Tuple class for extracted attributes from a class definition.</span>
<span class="s0"># `base_attrs` is a subset of `attrs`.</span>
<span class="s2">class </span><span class="s1">_Attributes</span><span class="s3">(</span><span class="s1">NamedTuple</span><span class="s3">):</span>
    <span class="s1">attrs</span><span class="s3">: </span><span class="s1">type</span>
    <span class="s1">base_attrs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Attribute</span><span class="s3">]</span>
    <span class="s1">base_attrs_map</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">type</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_is_class_var</span><span class="s3">(</span><span class="s1">annot</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether *annot* is a typing.ClassVar. 
 
    The string comparison hack is used to avoid evaluating all string 
    annotations which would put attrs-based classes at a performance 
    disadvantage compared to plain old classes. 
    &quot;&quot;&quot;</span>
    <span class="s1">annot </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">annot</span><span class="s3">)</span>

    <span class="s0"># Annotation can be quoted.</span>
    <span class="s2">if </span><span class="s1">annot</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">((</span><span class="s4">&quot;'&quot;</span><span class="s3">, </span><span class="s4">'&quot;'</span><span class="s3">)) </span><span class="s2">and </span><span class="s1">annot</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">((</span><span class="s4">&quot;'&quot;</span><span class="s3">, </span><span class="s4">'&quot;'</span><span class="s3">)):</span>
        <span class="s1">annot </span><span class="s3">= </span><span class="s1">annot</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">annot</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">_CLASSVAR_PREFIXES</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_has_own_attribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">attrib_name</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether *cls* defines *attrib_name* (and doesn't just inherit it). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">attrib_name </span><span class="s2">in </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span>


<span class="s2">def </span><span class="s1">_collect_base_attrs</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">, </span><span class="s1">taken_attr_names</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">Attribute</span><span class="s3">], </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">type</span><span class="s3">]]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_attrs </span><span class="s3">= []</span>
    <span class="s1">base_attr_map </span><span class="s3">= {}  </span><span class="s0"># A dictionary of base attrs to their classes.</span>

    <span class="s0"># Traverse the MRO and collect attributes.</span>
    <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]):</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">base_cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">, []):</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">inherited </span><span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">taken_attr_names</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">inherited</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)  </span><span class="s0"># noqa: PLW2901</span>
            <span class="s1">base_attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">base_attr_map</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">base_cls</span>

    <span class="s0"># For each name, only keep the freshest definition i.e. the furthest at the</span>
    <span class="s0"># back.  base_attr_map is fine because it gets overwritten with every new</span>
    <span class="s0"># instance.</span>
    <span class="s1">filtered </span><span class="s3">= []</span>
    <span class="s1">seen </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">base_attrs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">seen</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">filtered</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">seen</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">filtered</span><span class="s3">, </span><span class="s1">base_attr_map</span>


<span class="s2">def </span><span class="s1">_collect_base_attrs_broken</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">taken_attr_names</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*. 
 
    N.B. *taken_attr_names* will be mutated. 
 
    Adhere to the old incorrect behavior. 
 
    Notably it collects from the front and considers inherited attributes which 
    leads to the buggy behavior reported in #428. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_attrs </span><span class="s3">= []</span>
    <span class="s1">base_attr_map </span><span class="s3">= {}  </span><span class="s0"># A dictionary of base attrs to their classes.</span>

    <span class="s0"># Traverse the MRO and collect attributes.</span>
    <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]:</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">base_cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">, []):</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">taken_attr_names</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">inherited</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)  </span><span class="s0"># noqa: PLW2901</span>
            <span class="s1">taken_attr_names</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">base_attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">base_attr_map</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">base_cls</span>

    <span class="s2">return </span><span class="s1">base_attrs</span><span class="s3">, </span><span class="s1">base_attr_map</span>


<span class="s2">def </span><span class="s1">_transform_attrs</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">, </span><span class="s1">these</span><span class="s3">, </span><span class="s1">auto_attribs</span><span class="s3">, </span><span class="s1">kw_only</span><span class="s3">, </span><span class="s1">collect_by_mro</span><span class="s3">, </span><span class="s1">field_transformer</span>
<span class="s3">) </span><span class="s1">-&gt; _Attributes</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Transform all `_CountingAttr`s on a class into `Attribute`s. 
 
    If *these* is passed, use that and don't look for them on the class. 
 
    If *collect_by_mro* is True, collect them in the correct MRO order, 
    otherwise use the old -- incorrect -- order.  See #428. 
 
    Return an `_Attributes`. 
    &quot;&quot;&quot;</span>
    <span class="s1">cd </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span>
    <span class="s1">anns </span><span class="s3">= </span><span class="s1">_get_annotations</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">these </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">ca_list </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">these</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
    <span class="s2">elif </span><span class="s1">auto_attribs </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s1">ca_names </span><span class="s3">= {</span>
            <span class="s1">name</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">_CountingAttr</span>
        <span class="s3">}</span>
        <span class="s1">ca_list </span><span class="s3">= []</span>
        <span class="s1">annot_names </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">anns</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">_is_class_var</span><span class="s3">(</span><span class="s1">type</span><span class="s3">):</span>
                <span class="s2">continue</span>
            <span class="s1">annot_names</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">NOTHING</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is not </span><span class="s1">_CountingAttr</span><span class="s3">:</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">attrib</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">ca_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">a</span><span class="s3">))</span>

        <span class="s1">unannotated </span><span class="s3">= </span><span class="s1">ca_names </span><span class="s3">- </span><span class="s1">annot_names</span>
        <span class="s2">if </span><span class="s1">unannotated</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">UnannotatedAttributeError</span><span class="s3">(</span>
                <span class="s4">&quot;The following `attr.ib`s lack a type annotation: &quot;</span>
                <span class="s3">+ </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
                    <span class="s1">sorted</span><span class="s3">(</span><span class="s1">unannotated</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">n</span><span class="s3">: </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">n</span><span class="s3">).</span><span class="s1">counter</span><span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s3">+ </span><span class="s4">&quot;.&quot;</span>
            <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ca_list </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">(</span>
                <span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">_CountingAttr</span>
            <span class="s3">),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">e</span><span class="s3">: </span><span class="s1">e</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">counter</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s1">fca </span><span class="s3">= </span><span class="s1">Attribute</span><span class="s3">.</span><span class="s1">from_counting_attr</span>
    <span class="s1">own_attrs </span><span class="s3">= [</span>
        <span class="s1">fca</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">ca</span><span class="s3">, </span><span class="s1">anns</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">ca </span><span class="s2">in </span><span class="s1">ca_list</span>
    <span class="s3">]</span>

    <span class="s2">if </span><span class="s1">collect_by_mro</span><span class="s3">:</span>
        <span class="s1">base_attrs</span><span class="s3">, </span><span class="s1">base_attr_map </span><span class="s3">= </span><span class="s1">_collect_base_attrs</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, {</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs</span><span class="s3">}</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">base_attrs</span><span class="s3">, </span><span class="s1">base_attr_map </span><span class="s3">= </span><span class="s1">_collect_base_attrs_broken</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, {</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs</span><span class="s3">}</span>
        <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">kw_only</span><span class="s3">:</span>
        <span class="s1">own_attrs </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">kw_only</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs</span><span class="s3">]</span>
        <span class="s1">base_attrs </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">kw_only</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">base_attrs</span><span class="s3">]</span>

    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">base_attrs </span><span class="s3">+ </span><span class="s1">own_attrs</span>

    <span class="s2">if </span><span class="s1">field_transformer </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">attrs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">field_transformer</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">))</span>

    <span class="s0"># Check attr order after executing the field_transformer.</span>
    <span class="s0"># Mandatory vs non-mandatory attr order only matters when they are part of</span>
    <span class="s0"># the __init__ signature and when they aren't kw_only (which are moved to</span>
    <span class="s0"># the end and can be mandatory or non-mandatory in any order, as they will</span>
    <span class="s0"># be specified as keyword args anyway). Check the order of those attrs:</span>
    <span class="s1">had_default </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s3">(</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init </span><span class="s2">is not False and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">kw_only </span><span class="s2">is False</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">had_default </span><span class="s2">is True and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: </span><span class="s2">{</span><span class="s1">a</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">had_default </span><span class="s2">is False and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is not </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s1">had_default </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s0"># Resolve default field alias after executing field_transformer.</span>
    <span class="s0"># This allows field_transformer to differentiate between explicit vs</span>
    <span class="s0"># default aliases and supply their own defaults.</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">:</span>
            <span class="s0"># Evolve is very slow, so we hold our nose and do it dirty.</span>
            <span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)(</span><span class="s4">&quot;alias&quot;</span><span class="s3">, </span><span class="s1">_default_init_alias_for</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>

    <span class="s0"># Create AttrsClass *after* applying the field_transformer since it may</span>
    <span class="s0"># add or remove attributes!</span>
    <span class="s1">attr_names </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">]</span>
    <span class="s1">AttrsClass </span><span class="s3">= </span><span class="s1">_make_attr_tuple_class</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">attr_names</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_Attributes</span><span class="s3">(</span><span class="s1">AttrsClass</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">), </span><span class="s1">base_attrs</span><span class="s3">, </span><span class="s1">base_attr_map</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_make_cached_property_getattr</span><span class="s3">(</span><span class="s1">cached_properties</span><span class="s3">, </span><span class="s1">original_getattr</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s1">lines </span><span class="s3">= [</span>
        <span class="s0"># Wrapped to get `__class__` into closure cell for super()</span>
        <span class="s0"># (It will be replaced with the newly constructed class after construction).</span>
        <span class="s4">&quot;def wrapper(_cls):&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    __class__ = _cls&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    def __getattr__(self, item, cached_properties=cached_properties, original_getattr=original_getattr, _cached_setattr_get=_cached_setattr_get):&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;         func = cached_properties.get(item)&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;         if func is not None:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;              result = func(self)&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;              _setter = _cached_setattr_get(self)&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;              _setter(item, result)&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;              return result&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>
    <span class="s2">if </span><span class="s1">original_getattr </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s4">&quot;         return original_getattr(self, item)&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s4">&quot;         try:&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;             return super().__getattribute__(item)&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;         except AttributeError:&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;             if not hasattr(super(), '__getattr__'):&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;                 raise&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;             return super().__getattr__(item)&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;         original_error = f</span><span class="s2">\&quot;</span><span class="s4">'{self.__class__.__name__}' object has no attribute '{item}'</span><span class="s2">\&quot;</span><span class="s4">&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;         raise AttributeError(original_error)&quot;</span><span class="s3">,</span>
            <span class="s3">]</span>
        <span class="s3">)</span>

    <span class="s1">lines</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s4">&quot;    return __getattr__&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;__getattr__ = wrapper(_cls)&quot;</span><span class="s3">,</span>
        <span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">unique_filename </span><span class="s3">= </span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;getattr&quot;</span><span class="s3">)</span>

    <span class="s1">glob </span><span class="s3">= {</span>
        <span class="s4">&quot;cached_properties&quot;</span><span class="s3">: </span><span class="s1">cached_properties</span><span class="s3">,</span>
        <span class="s4">&quot;_cached_setattr_get&quot;</span><span class="s3">: </span><span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">,</span>
        <span class="s4">&quot;original_getattr&quot;</span><span class="s3">: </span><span class="s1">original_getattr</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s2">return </span><span class="s1">_linecache_and_compile</span><span class="s3">(</span>
        <span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">), </span><span class="s1">unique_filename</span><span class="s3">, </span><span class="s1">glob</span><span class="s3">, </span><span class="s1">locals</span><span class="s3">={</span><span class="s4">&quot;_cls&quot;</span><span class="s3">: </span><span class="s1">cls</span><span class="s3">}</span>
    <span class="s3">)[</span><span class="s4">&quot;__getattr__&quot;</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_frozen_setattrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Attached to frozen classes as __setattr__. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s4">&quot;__cause__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;__context__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;__traceback__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;__suppress_context__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;__notes__&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">BaseException</span><span class="s3">.</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">return</span>

    <span class="s2">raise </span><span class="s1">FrozenInstanceError</span>


<span class="s2">def </span><span class="s1">_frozen_delattrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Attached to frozen classes as __delattr__. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;__notes__&quot;</span><span class="s3">,):</span>
        <span class="s1">BaseException</span><span class="s3">.</span><span class="s1">__delattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return</span>

    <span class="s2">raise </span><span class="s1">FrozenInstanceError</span>


<span class="s2">def </span><span class="s1">evolve</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a new instance, based on the first positional argument with 
    *changes* applied. 
 
    .. tip:: 
 
       On Python 3.13 and later, you can also use `copy.replace` instead. 
 
    Args: 
 
        inst: 
            Instance of a class with *attrs* attributes. *inst* must be passed 
            as a positional argument. 
 
        changes: 
            Keyword changes in the new copy. 
 
    Returns: 
        A copy of inst with *changes* incorporated. 
 
    Raises: 
        TypeError: 
            If *attr_name* couldn't be found in the class ``__init__``. 
 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    .. versionadded:: 17.1.0 
    .. deprecated:: 23.1.0 
       It is now deprecated to pass the instance using the keyword argument 
       *inst*. It will raise a warning until at least April 2024, after which 
       it will become an error. Always pass the instance as a positional 
       argument. 
    .. versionchanged:: 24.1.0 
       *inst* can't be passed as a keyword argument anymore. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s3">(</span><span class="s1">inst</span><span class="s3">,) = </span><span class="s1">args</span>
    <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;evolve() takes 1 positional argument, but </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span><span class="s2">} </span><span class="s4">were given&quot;</span>
        <span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">) </span><span class="s2">from None</span>

    <span class="s1">cls </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">attr_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name  </span><span class="s0"># To deal with private attributes.</span>
        <span class="s1">init_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">alias</span>
        <span class="s2">if </span><span class="s1">init_name </span><span class="s2">not in </span><span class="s1">changes</span><span class="s3">:</span>
            <span class="s1">changes</span><span class="s3">[</span><span class="s1">init_name</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">cls</span><span class="s3">(**</span><span class="s1">changes</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_ClassBuilder</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Iteratively build *one* class. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;_add_method_dunders&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_attr_names&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_attrs&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_base_attr_map&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_base_names&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_cache_hash&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_cls&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_cls_dict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_delete_attribs&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_frozen&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_has_custom_setattr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_has_post_init&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_has_pre_init&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_is_exc&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_on_setattr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_pre_init_has_args&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_repr_added&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_script_snippets&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_slots&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_weakref_slot&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_wrote_own_setattr&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">,</span>
        <span class="s1">these</span><span class="s3">,</span>
        <span class="s1">slots</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">,</span>
        <span class="s1">weakref_slot</span><span class="s3">,</span>
        <span class="s1">getstate_setstate</span><span class="s3">,</span>
        <span class="s1">auto_attribs</span><span class="s3">,</span>
        <span class="s1">kw_only</span><span class="s3">,</span>
        <span class="s1">cache_hash</span><span class="s3">,</span>
        <span class="s1">is_exc</span><span class="s3">,</span>
        <span class="s1">collect_by_mro</span><span class="s3">,</span>
        <span class="s1">on_setattr</span><span class="s3">,</span>
        <span class="s1">has_custom_setattr</span><span class="s3">,</span>
        <span class="s1">field_transformer</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">attrs</span><span class="s3">, </span><span class="s1">base_attrs</span><span class="s3">, </span><span class="s1">base_map </span><span class="s3">= </span><span class="s1">_transform_attrs</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">,</span>
            <span class="s1">these</span><span class="s3">,</span>
            <span class="s1">auto_attribs</span><span class="s3">,</span>
            <span class="s1">kw_only</span><span class="s3">,</span>
            <span class="s1">collect_by_mro</span><span class="s3">,</span>
            <span class="s1">field_transformer</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls </span><span class="s3">= </span><span class="s1">cls</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">) </span><span class="s2">if </span><span class="s1">slots </span><span class="s2">else </span><span class="s3">{}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs </span><span class="s3">= </span><span class="s1">attrs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_base_names </span><span class="s3">= {</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">base_attrs</span><span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_base_attr_map </span><span class="s3">= </span><span class="s1">base_map</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_attr_names </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_slots </span><span class="s3">= </span><span class="s1">slots</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_frozen </span><span class="s3">= </span><span class="s1">frozen</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_weakref_slot </span><span class="s3">= </span><span class="s1">weakref_slot</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash </span><span class="s3">= </span><span class="s1">cache_hash</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_pre_init </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_pre_init__&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pre_init_has_args </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_has_pre_init</span><span class="s3">:</span>
            <span class="s0"># Check if the pre init method has more arguments than just `self`</span>
            <span class="s0"># We want to pass arguments if pre init expects arguments</span>
            <span class="s1">pre_init_func </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_pre_init__</span>
            <span class="s1">pre_init_signature </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">pre_init_func</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_pre_init_has_args </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pre_init_signature</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">) &gt; </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_post_init </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_post_init__&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_delete_attribs </span><span class="s3">= </span><span class="s2">not </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">these</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_exc </span><span class="s3">= </span><span class="s1">is_exc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_on_setattr </span><span class="s3">= </span><span class="s1">on_setattr</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_custom_setattr </span><span class="s3">= </span><span class="s1">has_custom_setattr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_wrote_own_setattr </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span>

        <span class="s2">if </span><span class="s1">frozen</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__setattr__&quot;</span><span class="s3">] = </span><span class="s1">_frozen_setattrs</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__delattr__&quot;</span><span class="s3">] = </span><span class="s1">_frozen_delattrs</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">_wrote_own_setattr </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">on_setattr </span><span class="s2">in </span><span class="s3">(</span>
            <span class="s1">_DEFAULT_ON_SETATTR</span><span class="s3">,</span>
            <span class="s1">setters</span><span class="s3">.</span><span class="s1">validate</span><span class="s3">,</span>
            <span class="s1">setters</span><span class="s3">.</span><span class="s1">convert</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s1">has_validator </span><span class="s3">= </span><span class="s1">has_converter </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">validator </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">has_validator </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">has_converter </span><span class="s3">= </span><span class="s2">True</span>

                <span class="s2">if </span><span class="s1">has_validator </span><span class="s2">and </span><span class="s1">has_converter</span><span class="s3">:</span>
                    <span class="s2">break</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s3">(</span>
                    <span class="s1">on_setattr </span><span class="s3">== </span><span class="s1">_DEFAULT_ON_SETATTR</span>
                    <span class="s2">and not </span><span class="s3">(</span><span class="s1">has_validator </span><span class="s2">or </span><span class="s1">has_converter</span><span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s2">or </span><span class="s3">(</span><span class="s1">on_setattr </span><span class="s3">== </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">validate </span><span class="s2">and not </span><span class="s1">has_validator</span><span class="s3">)</span>
                <span class="s2">or </span><span class="s3">(</span><span class="s1">on_setattr </span><span class="s3">== </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">convert </span><span class="s2">and not </span><span class="s1">has_converter</span><span class="s3">)</span>
            <span class="s3">):</span>
                <span class="s0"># If class-level on_setattr is set to convert + validate, but</span>
                <span class="s0"># there's no field to convert or validate, pretend like there's</span>
                <span class="s0"># no on_setattr.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_on_setattr </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">getstate_setstate</span><span class="s3">:</span>
            <span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__getstate__&quot;</span><span class="s3">],</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__setstate__&quot;</span><span class="s3">],</span>
            <span class="s3">) = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_getstate_setstate</span><span class="s3">()</span>

        <span class="s0"># tuples of script, globs, hook</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span>
            <span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">dict</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">]]</span>
        <span class="s3">] = []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_repr_added </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s0"># We want to only do this check once; in 99.9% of cases these</span>
        <span class="s0"># exist.</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">, </span><span class="s4">&quot;__module__&quot;</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">hasattr</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">, </span><span class="s4">&quot;__qualname__&quot;</span>
        <span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders_safe</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders_unsafe</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;_ClassBuilder(cls=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">)&gt;&quot;</span>

    <span class="s2">def </span><span class="s1">_eval_snippets</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Evaluate any registered snippets in one go. 
        &quot;&quot;&quot;</span>
        <span class="s1">script </span><span class="s3">= </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">snippet</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">snippet </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">])</span>
        <span class="s1">globs </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">snippet_globs</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">:</span>
            <span class="s1">globs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">snippet_globs</span><span class="s3">)</span>

        <span class="s1">locs </span><span class="s3">= </span><span class="s1">_linecache_and_compile</span><span class="s3">(</span>
            <span class="s1">script</span><span class="s3">,</span>
            <span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">, </span><span class="s4">&quot;methods&quot;</span><span class="s3">),</span>
            <span class="s1">globs</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">hook </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">:</span>
            <span class="s1">hook</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Finalize class based on the accumulated configuration. 
 
        Builder cannot be used after calling this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_snippets</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_slots </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">cls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_create_slots_class</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_patch_original_class</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">PY_3_10_PLUS</span><span class="s3">:</span>
                <span class="s1">cls </span><span class="s3">= </span><span class="s1">abc</span><span class="s3">.</span><span class="s1">update_abstractmethods</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

        <span class="s0"># The method gets only called if it's not inherited from a base class.</span>
        <span class="s0"># _has_own_attribute does NOT work properly for classmethods.</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_init_subclass__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s4">&quot;__attrs_init_subclass__&quot; </span><span class="s2">not in </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span>
        <span class="s3">):</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_init_subclass__</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">def </span><span class="s1">_patch_original_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Apply accumulated methods and return the class. 
        &quot;&quot;&quot;</span>
        <span class="s1">cls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span>
        <span class="s1">base_names </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_base_names</span>

        <span class="s0"># Clean class of attribute definitions (`attr.ib()`s).</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_delete_attribs</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attr_names</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">name </span><span class="s2">not in </span><span class="s1">base_names</span>
                    <span class="s2">and </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">_SENTINEL</span><span class="s3">) </span><span class="s2">is not </span><span class="s1">_SENTINEL</span>
                <span class="s3">):</span>
                    <span class="s0"># An AttributeError can happen if a base class defines a</span>
                    <span class="s0"># class variable and we want to set an attribute with the</span>
                    <span class="s0"># same name by using only a type annotation.</span>
                    <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">):</span>
                        <span class="s1">delattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s0"># Attach our dunder methods.</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

        <span class="s0"># If we've inherited an attrs __setattr__ and don't write our own,</span>
        <span class="s0"># reset it to object's.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_wrote_own_setattr </span><span class="s2">and </span><span class="s1">getattr</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_own_setattr__&quot;</span><span class="s3">, </span><span class="s2">False</span>
        <span class="s3">):</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_own_setattr__ </span><span class="s3">= </span><span class="s2">False</span>

            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_has_custom_setattr</span><span class="s3">:</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">__setattr__ </span><span class="s3">= </span><span class="s1">_OBJ_SETATTR</span>

        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">def </span><span class="s1">_create_slots_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Build and return a new class with a `__slots__` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s1">cd </span><span class="s3">= {</span>
            <span class="s1">k</span><span class="s3">: </span><span class="s1">v</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s3">(*</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attr_names</span><span class="s3">), </span><span class="s4">&quot;__dict__&quot;</span><span class="s3">, </span><span class="s4">&quot;__weakref__&quot;</span><span class="s3">)</span>
        <span class="s3">}</span>

        <span class="s0"># If our class doesn't have its own implementation of __setattr__</span>
        <span class="s0"># (either from the user or by us), check the bases, if one of them has</span>
        <span class="s0"># an attrs-made __setattr__, that needs to be reset. We don't walk the</span>
        <span class="s0"># MRO because we only care about our immediate base classes.</span>
        <span class="s0"># XXX: This can be confused by subclassing a slotted attrs class with</span>
        <span class="s0"># XXX: a non-attrs class and subclass the resulting class with an attrs</span>
        <span class="s0"># XXX: class.  See `test_slotted_confused` for details.  For now that's</span>
        <span class="s0"># XXX: OK with us.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_wrote_own_setattr</span><span class="s3">:</span>
            <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__attrs_own_setattr__&quot;</span><span class="s3">] = </span><span class="s2">False</span>

            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_has_custom_setattr</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__bases__</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">base_cls</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;__attrs_own_setattr__&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
                        <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__setattr__&quot;</span><span class="s3">] = </span><span class="s1">_OBJ_SETATTR</span>
                        <span class="s2">break</span>

        <span class="s0"># Traverse the MRO to collect existing slots</span>
        <span class="s0"># and check for an existing __weakref__.</span>
        <span class="s1">existing_slots </span><span class="s3">= {}</span>
        <span class="s1">weakref_inherited </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__mro__</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">base_cls</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;__weakref__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">weakref_inherited </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">existing_slots</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span>
                <span class="s3">{</span>
                    <span class="s1">name</span><span class="s3">: </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">base_cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">base_cls</span><span class="s3">, </span><span class="s4">&quot;__slots__&quot;</span><span class="s3">, [])</span>
                <span class="s3">}</span>
            <span class="s3">)</span>

        <span class="s1">base_names </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_base_names</span><span class="s3">)</span>

        <span class="s1">names </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attr_names</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_weakref_slot</span>
            <span class="s2">and </span><span class="s4">&quot;__weakref__&quot; </span><span class="s2">not in </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">, </span><span class="s4">&quot;__slots__&quot;</span><span class="s3">, ())</span>
            <span class="s2">and </span><span class="s4">&quot;__weakref__&quot; </span><span class="s2">not in </span><span class="s1">names</span>
            <span class="s2">and not </span><span class="s1">weakref_inherited</span>
        <span class="s3">):</span>
            <span class="s1">names </span><span class="s3">+= (</span><span class="s4">&quot;__weakref__&quot;</span><span class="s3">,)</span>

        <span class="s1">cached_properties </span><span class="s3">= {</span>
            <span class="s1">name</span><span class="s3">: </span><span class="s1">cached_prop</span><span class="s3">.</span><span class="s1">func</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">cached_prop </span><span class="s2">in </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cached_prop</span><span class="s3">, </span><span class="s1">cached_property</span><span class="s3">)</span>
        <span class="s3">}</span>

        <span class="s0"># Collect methods with a `__class__` reference that are shadowed in the new class.</span>
        <span class="s0"># To know to update them.</span>
        <span class="s1">additional_closure_functions_to_update </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">cached_properties</span><span class="s3">:</span>
            <span class="s1">class_annotations </span><span class="s3">= </span><span class="s1">_get_annotations</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func </span><span class="s2">in </span><span class="s1">cached_properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s0"># Add cached properties to names for slotting.</span>
                <span class="s1">names </span><span class="s3">+= (</span><span class="s1">name</span><span class="s3">,)</span>
                <span class="s0"># Clear out function from class to avoid clashing.</span>
                <span class="s2">del </span><span class="s1">cd</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
                <span class="s1">additional_closure_functions_to_update</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
                <span class="s1">annotation </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">func</span><span class="s3">).</span><span class="s1">return_annotation</span>
                <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is not </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
                    <span class="s1">class_annotations</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">annotation</span>

            <span class="s1">original_getattr </span><span class="s3">= </span><span class="s1">cd</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;__getattr__&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">original_getattr </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">additional_closure_functions_to_update</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">original_getattr</span><span class="s3">)</span>

            <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__getattr__&quot;</span><span class="s3">] = </span><span class="s1">_make_cached_property_getattr</span><span class="s3">(</span>
                <span class="s1">cached_properties</span><span class="s3">, </span><span class="s1">original_getattr</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span>
            <span class="s3">)</span>

        <span class="s0"># We only add the names of attributes that aren't inherited.</span>
        <span class="s0"># Setting __slots__ to inherited attributes wastes memory.</span>
        <span class="s1">slot_names </span><span class="s3">= [</span><span class="s1">name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">base_names</span><span class="s3">]</span>

        <span class="s0"># There are slots for attributes from current class</span>
        <span class="s0"># that are defined in parent classes.</span>
        <span class="s0"># As their descriptors may be overridden by a child class,</span>
        <span class="s0"># we collect them here and update the class dict</span>
        <span class="s1">reused_slots </span><span class="s3">= {</span>
            <span class="s1">slot</span><span class="s3">: </span><span class="s1">slot_descriptor</span>
            <span class="s2">for </span><span class="s1">slot</span><span class="s3">, </span><span class="s1">slot_descriptor </span><span class="s2">in </span><span class="s1">existing_slots</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">slot </span><span class="s2">in </span><span class="s1">slot_names</span>
        <span class="s3">}</span>
        <span class="s1">slot_names </span><span class="s3">= [</span><span class="s1">name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">slot_names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">reused_slots</span><span class="s3">]</span>
        <span class="s1">cd</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">reused_slots</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash</span><span class="s3">:</span>
            <span class="s1">slot_names</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s3">)</span>

        <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__slots__&quot;</span><span class="s3">] = </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">slot_names</span><span class="s3">)</span>

        <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__qualname__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__qualname__</span>

        <span class="s0"># Create new class based on old class and our methods.</span>
        <span class="s1">cls </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">)(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__bases__</span><span class="s3">, </span><span class="s1">cd</span><span class="s3">)</span>

        <span class="s0"># The following is a fix for</span>
        <span class="s0"># &lt;https://github.com/python-attrs/attrs/issues/102&gt;.</span>
        <span class="s0"># If a method mentions `__class__` or uses the no-arg super(), the</span>
        <span class="s0"># compiler will bake a reference to the class in the method itself</span>
        <span class="s0"># as `method.__closure__`.  Since we replace the class with a</span>
        <span class="s0"># clone, we rewrite these references so it keeps working.</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">chain</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">additional_closure_functions_to_update</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, (</span><span class="s1">classmethod</span><span class="s3">, </span><span class="s1">staticmethod</span><span class="s3">)):</span>
                <span class="s0"># Class- and staticmethods hide their functions inside.</span>
                <span class="s0"># These might need to be rewritten as well.</span>
                <span class="s1">closure_cells </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">__func__</span><span class="s3">, </span><span class="s4">&quot;__closure__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">property</span><span class="s3">):</span>
                <span class="s0"># Workaround for property `super()` shortcut (PY3-only).</span>
                <span class="s0"># There is no universal way for other descriptors.</span>
                <span class="s1">closure_cells </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">fget</span><span class="s3">, </span><span class="s4">&quot;__closure__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">closure_cells </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s4">&quot;__closure__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">closure_cells</span><span class="s3">:  </span><span class="s0"># Catch None or the empty list.</span>
                <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">closure_cells</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">match </span><span class="s3">= </span><span class="s1">cell</span><span class="s3">.</span><span class="s1">cell_contents </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span>
                <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:  </span><span class="s0"># noqa: PERF203</span>
                    <span class="s0"># ValueError: Cell is empty</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">match</span><span class="s3">:</span>
                        <span class="s1">cell</span><span class="s3">.</span><span class="s1">cell_contents </span><span class="s3">= </span><span class="s1">cls</span>
        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">def </span><span class="s1">add_repr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">):</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_repr_script</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_attach_repr</span><span class="s3">(</span><span class="s1">cls_dict</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">):</span>
            <span class="s1">cls_dict</span><span class="s3">[</span><span class="s4">&quot;__repr__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__repr__&quot;</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">_attach_repr</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_repr_added </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_repr_added</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;__str__ can only be generated if a __repr__ exists.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__repr__</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__str__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">__str__</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_make_getstate_setstate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Create custom __setstate__ and __getstate__ methods. 
        &quot;&quot;&quot;</span>
        <span class="s0"># __weakref__ is not writable.</span>
        <span class="s1">state_attr_names </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">an </span><span class="s2">for </span><span class="s1">an </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attr_names </span><span class="s2">if </span><span class="s1">an </span><span class="s3">!= </span><span class="s4">&quot;__weakref__&quot;</span>
        <span class="s3">)</span>

        <span class="s2">def </span><span class="s1">slots_getstate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Automatically created by attrs. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s3">{</span><span class="s1">name</span><span class="s3">: </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state_attr_names</span><span class="s3">}</span>

        <span class="s1">hash_caching_enabled </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash</span>

        <span class="s2">def </span><span class="s1">slots_setstate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Automatically created by attrs. 
            &quot;&quot;&quot;</span>
            <span class="s1">__bound_setattr </span><span class="s3">= </span><span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s0"># Backward compatibility with attrs instances pickled with</span>
                <span class="s0"># attrs versions before v22.2.0 which stored tuples.</span>
                <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">state_attr_names</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
                    <span class="s1">__bound_setattr</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state_attr_names</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state</span><span class="s3">:</span>
                        <span class="s1">__bound_setattr</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">state</span><span class="s3">[</span><span class="s1">name</span><span class="s3">])</span>

            <span class="s0"># The hash code cache is not included when the object is</span>
            <span class="s0"># serialized, but it still needs to be initialized to None to</span>
            <span class="s0"># indicate that the first call to __hash__ should be a cache</span>
            <span class="s0"># miss.</span>
            <span class="s2">if </span><span class="s1">hash_caching_enabled</span><span class="s3">:</span>
                <span class="s1">__bound_setattr</span><span class="s3">(</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">slots_getstate</span><span class="s3">, </span><span class="s1">slots_setstate</span>

    <span class="s2">def </span><span class="s1">make_unhashable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__hash__&quot;</span><span class="s3">] = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_hash</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_hash_script</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">,</span>
            <span class="s1">frozen</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_frozen</span><span class="s3">,</span>
            <span class="s1">cache_hash</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">def </span><span class="s1">attach_hash</span><span class="s3">(</span><span class="s1">cls_dict</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">cls_dict</span><span class="s3">[</span><span class="s4">&quot;__hash__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">locs</span><span class="s3">[</span><span class="s4">&quot;__hash__&quot;</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">attach_hash</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">annotations </span><span class="s3">= </span><span class="s1">_make_init_script</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_pre_init</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_pre_init_has_args</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_post_init</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_frozen</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_slots</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_base_attr_map</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_exc</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_on_setattr</span><span class="s3">,</span>
            <span class="s1">attrs_init</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_attach_init</span><span class="s3">(</span><span class="s1">cls_dict</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">):</span>
            <span class="s1">init </span><span class="s3">= </span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__init__&quot;</span><span class="s3">]</span>
            <span class="s1">init</span><span class="s3">.</span><span class="s1">__annotations__ </span><span class="s3">= </span><span class="s1">annotations</span>
            <span class="s1">cls_dict</span><span class="s3">[</span><span class="s4">&quot;__init__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">init</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">_attach_init</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_replace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__replace__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span>
            <span class="s2">lambda </span><span class="s1">self</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">: </span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_match_args</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__match_args__&quot;</span><span class="s3">] = </span><span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">field</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span>
            <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">init </span><span class="s2">and not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">kw_only</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">add_attrs_init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">annotations </span><span class="s3">= </span><span class="s1">_make_init_script</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_pre_init</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_pre_init_has_args</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_has_post_init</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_frozen</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_slots</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cache_hash</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_base_attr_map</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_exc</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_on_setattr</span><span class="s3">,</span>
            <span class="s1">attrs_init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_attach_attrs_init</span><span class="s3">(</span><span class="s1">cls_dict</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">):</span>
            <span class="s1">init </span><span class="s3">= </span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__attrs_init__&quot;</span><span class="s3">]</span>
            <span class="s1">init</span><span class="s3">.</span><span class="s1">__annotations__ </span><span class="s3">= </span><span class="s1">annotations</span>
            <span class="s1">cls_dict</span><span class="s3">[</span><span class="s4">&quot;__attrs_init__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">init</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">_attach_attrs_init</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_eq</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">cd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span>

        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_eq_script</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_attach_eq</span><span class="s3">(</span><span class="s1">cls_dict</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">):</span>
            <span class="s1">cls_dict</span><span class="s3">[</span><span class="s4">&quot;__eq__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__eq__&quot;</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_script_snippets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">_attach_eq</span><span class="s3">))</span>

        <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__ne__&quot;</span><span class="s3">] = </span><span class="s1">__ne__</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_order</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">cd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span>

        <span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__lt__&quot;</span><span class="s3">], </span><span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__le__&quot;</span><span class="s3">], </span><span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__gt__&quot;</span><span class="s3">], </span><span class="s1">cd</span><span class="s3">[</span><span class="s4">&quot;__ge__&quot;</span><span class="s3">] = (</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">meth</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">_make_order</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">sa_attrs </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attrs</span><span class="s3">:</span>
            <span class="s1">on_setattr </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_on_setattr</span>
            <span class="s2">if </span><span class="s1">on_setattr </span><span class="s2">and </span><span class="s1">on_setattr </span><span class="s2">is not </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">NO_OP</span><span class="s3">:</span>
                <span class="s1">sa_attrs</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">, </span><span class="s1">on_setattr</span>

        <span class="s2">if not </span><span class="s1">sa_attrs</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_has_custom_setattr</span><span class="s3">:</span>
            <span class="s0"># We need to write a __setattr__ but there already is one!</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Can't combine custom __setattr__ with on_setattr hooks.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s0"># docstring comes from _add_method_dunders</span>
        <span class="s2">def </span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">a</span><span class="s3">, </span><span class="s1">hook </span><span class="s3">= </span><span class="s1">sa_attrs</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                <span class="s1">nval </span><span class="s3">= </span><span class="s1">val</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">nval </span><span class="s3">= </span><span class="s1">hook</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

            <span class="s1">_OBJ_SETATTR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">nval</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__attrs_own_setattr__&quot;</span><span class="s3">] = </span><span class="s2">True</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cls_dict</span><span class="s3">[</span><span class="s4">&quot;__setattr__&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_method_dunders</span><span class="s3">(</span><span class="s1">__setattr__</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_wrote_own_setattr </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_add_method_dunders_unsafe</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Add __module__ and __qualname__ to a *method*. 
        &quot;&quot;&quot;</span>
        <span class="s1">method</span><span class="s3">.</span><span class="s1">__module__ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__module__</span>

        <span class="s1">method</span><span class="s3">.</span><span class="s1">__qualname__ </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">method</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s1">method</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= (</span>
            <span class="s4">f&quot;Method generated by attrs for class </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">method</span>

    <span class="s2">def </span><span class="s1">_add_method_dunders_safe</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Add __module__ and __qualname__ to a *method* if possible. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">):</span>
            <span class="s1">method</span><span class="s3">.</span><span class="s1">__module__ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__module__</span>

        <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">):</span>
            <span class="s1">method</span><span class="s3">.</span><span class="s1">__qualname__ </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">method</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">):</span>
            <span class="s1">method</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s4">f&quot;Method generated by attrs for class </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">}</span><span class="s4">.&quot;</span>

        <span class="s2">return </span><span class="s1">method</span>


<span class="s2">def </span><span class="s1">_determine_attrs_eq_order</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">default_eq</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective 
    values of eq and order.  If *eq* is None, set it to *default_eq*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None and </span><span class="s1">any</span><span class="s3">((</span><span class="s1">eq </span><span class="s2">is not None</span><span class="s3">, </span><span class="s1">order </span><span class="s2">is not None</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Don't mix `cmp` with `eq' and `order`.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s0"># cmp takes precedence due to bw-compatibility.</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">cmp</span>

    <span class="s0"># If left None, equality is set to the specified default and ordering</span>
    <span class="s0"># mirrors equality.</span>
    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">eq </span><span class="s3">= </span><span class="s1">default_eq</span>

    <span class="s2">if </span><span class="s1">order </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">eq</span>

    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is False and </span><span class="s1">order </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;`order` can only be True if `eq` is True too.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order</span>


<span class="s2">def </span><span class="s1">_determine_attrib_eq_order</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">default_eq</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective 
    values of eq and order.  If *eq* is None, set it to *default_eq*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None and </span><span class="s1">any</span><span class="s3">((</span><span class="s1">eq </span><span class="s2">is not None</span><span class="s3">, </span><span class="s1">order </span><span class="s2">is not None</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Don't mix `cmp` with `eq' and `order`.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">decide_callable_or_boolean</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Decide whether a key function is used. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">key </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, </span><span class="s1">value</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span>

    <span class="s0"># cmp takes precedence due to bw-compatibility.</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">cmp</span><span class="s3">, </span><span class="s1">cmp_key </span><span class="s3">= </span><span class="s1">decide_callable_or_boolean</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">cmp_key</span><span class="s3">, </span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">cmp_key</span>

    <span class="s0"># If left None, equality is set to the specified default and ordering</span>
    <span class="s0"># mirrors equality.</span>
    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key </span><span class="s3">= </span><span class="s1">default_eq</span><span class="s3">, </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key </span><span class="s3">= </span><span class="s1">decide_callable_or_boolean</span><span class="s3">(</span><span class="s1">eq</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">order </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">order</span><span class="s3">, </span><span class="s1">order_key </span><span class="s3">= </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">order</span><span class="s3">, </span><span class="s1">order_key </span><span class="s3">= </span><span class="s1">decide_callable_or_boolean</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is False and </span><span class="s1">order </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;`order` can only be True if `eq` is True too.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">order_key</span>


<span class="s2">def </span><span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">auto_detect</span><span class="s3">, </span><span class="s1">dunders</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">True</span>
<span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether we should implement a set of methods for *cls*. 
 
    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the 
    same as passed into @attr.s and *dunders* is a tuple of attribute names 
    whose presence signal that the user has implemented it themselves. 
 
    Return *default* if no reason for either for or against is found. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">flag </span><span class="s2">is True or </span><span class="s1">flag </span><span class="s2">is False</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">flag</span>

    <span class="s2">if </span><span class="s1">flag </span><span class="s2">is None and </span><span class="s1">auto_detect </span><span class="s2">is False</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">default</span>

    <span class="s0"># Logically, flag is None and auto_detect is True here.</span>
    <span class="s2">for </span><span class="s1">dunder </span><span class="s2">in </span><span class="s1">dunders</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">_has_own_attribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dunder</span><span class="s3">):</span>
            <span class="s2">return False</span>

    <span class="s2">return </span><span class="s1">default</span>


<span class="s2">def </span><span class="s1">attrs</span><span class="s3">(</span>
    <span class="s1">maybe_cls</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">these</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">repr_ns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">repr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">hash</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">slots</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">weakref_slot</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">str</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">auto_attribs</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">cache_hash</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">auto_exc</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">eq</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">auto_detect</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">collect_by_mro</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">getstate_setstate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">on_setattr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">field_transformer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">match_args</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">unsafe_hash</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    A class decorator that adds :term:`dunder methods` according to the 
    specified attributes using `attr.ib` or the *these* argument. 
 
    Consider using `attrs.define` / `attrs.frozen` in new code (``attr.s`` will 
    *never* go away, though). 
 
    Args: 
        repr_ns (str): 
            When using nested classes, there was no way in Python 2 to 
            automatically detect that.  This argument allows to set a custom 
            name for a more meaningful ``repr`` output.  This argument is 
            pointless in Python 3 and is therefore deprecated. 
 
    .. caution:: 
        Refer to `attrs.define` for the rest of the parameters, but note that they 
        can have different defaults. 
 
        Notably, leaving *on_setattr* as `None` will **not** add any hooks. 
 
    .. versionadded:: 16.0.0 *slots* 
    .. versionadded:: 16.1.0 *frozen* 
    .. versionadded:: 16.3.0 *str* 
    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``. 
    .. versionchanged:: 17.1.0 
       *hash* supports `None` as value which is also the default now. 
    .. versionadded:: 17.3.0 *auto_attribs* 
    .. versionchanged:: 18.1.0 
       If *these* is passed, no attributes are deleted from the class body. 
    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained. 
    .. versionadded:: 18.2.0 *weakref_slot* 
    .. deprecated:: 18.2.0 
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a 
       `DeprecationWarning` if the classes compared are subclasses of 
       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses 
       to each other. 
    .. versionchanged:: 19.2.0 
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider 
       subclasses comparable anymore. 
    .. versionadded:: 18.2.0 *kw_only* 
    .. versionadded:: 18.2.0 *cache_hash* 
    .. versionadded:: 19.1.0 *auto_exc* 
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01. 
    .. versionadded:: 19.2.0 *eq* and *order* 
    .. versionadded:: 20.1.0 *auto_detect* 
    .. versionadded:: 20.1.0 *collect_by_mro* 
    .. versionadded:: 20.1.0 *getstate_setstate* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionadded:: 20.3.0 *field_transformer* 
    .. versionchanged:: 21.1.0 
       ``init=False`` injects ``__attrs_init__`` 
    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__`` 
    .. versionchanged:: 21.1.0 *cmp* undeprecated 
    .. versionadded:: 21.3.0 *match_args* 
    .. versionadded:: 22.2.0 
       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance). 
    .. deprecated:: 24.1.0 *repr_ns* 
    .. versionchanged:: 24.1.0 
       Instances are not compared as tuples of attributes anymore, but using a 
       big ``and`` condition. This is faster and has more correct behavior for 
       uncomparable values like `math.nan`. 
    .. versionadded:: 24.1.0 
       If a class has an *inherited* classmethod called 
       ``__attrs_init_subclass__``, it is executed after the class is created. 
    .. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">repr_ns </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">warnings</span>

        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s1">DeprecationWarning</span><span class="s3">(</span>
                <span class="s4">&quot;The `repr_ns` argument is deprecated and will be removed in or after August 2025.&quot;</span>
            <span class="s3">),</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s1">eq_</span><span class="s3">, </span><span class="s1">order_ </span><span class="s3">= </span><span class="s1">_determine_attrs_eq_order</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s0">#  unsafe_hash takes precedence due to PEP 681.</span>
    <span class="s2">if </span><span class="s1">unsafe_hash </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">hash </span><span class="s3">= </span><span class="s1">unsafe_hash</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">on_setattr</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">on_setattr </span><span class="s3">= </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">pipe</span><span class="s3">(*</span><span class="s1">on_setattr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
        <span class="s1">is_frozen </span><span class="s3">= </span><span class="s1">frozen </span><span class="s2">or </span><span class="s1">_has_frozen_base_class</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s1">is_exc </span><span class="s3">= </span><span class="s1">auto_exc </span><span class="s2">is True and </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">)</span>
        <span class="s1">has_own_setattr </span><span class="s3">= </span><span class="s1">auto_detect </span><span class="s2">and </span><span class="s1">_has_own_attribute</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__setattr__&quot;</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">has_own_setattr </span><span class="s2">and </span><span class="s1">is_frozen</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Can't freeze a class with a custom __setattr__.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">builder </span><span class="s3">= </span><span class="s1">_ClassBuilder</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">,</span>
            <span class="s1">these</span><span class="s3">,</span>
            <span class="s1">slots</span><span class="s3">,</span>
            <span class="s1">is_frozen</span><span class="s3">,</span>
            <span class="s1">weakref_slot</span><span class="s3">,</span>
            <span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
                <span class="s1">cls</span><span class="s3">,</span>
                <span class="s1">getstate_setstate</span><span class="s3">,</span>
                <span class="s1">auto_detect</span><span class="s3">,</span>
                <span class="s3">(</span><span class="s4">&quot;__getstate__&quot;</span><span class="s3">, </span><span class="s4">&quot;__setstate__&quot;</span><span class="s3">),</span>
                <span class="s1">default</span><span class="s3">=</span><span class="s1">slots</span><span class="s3">,</span>
            <span class="s3">),</span>
            <span class="s1">auto_attribs</span><span class="s3">,</span>
            <span class="s1">kw_only</span><span class="s3">,</span>
            <span class="s1">cache_hash</span><span class="s3">,</span>
            <span class="s1">is_exc</span><span class="s3">,</span>
            <span class="s1">collect_by_mro</span><span class="s3">,</span>
            <span class="s1">on_setattr</span><span class="s3">,</span>
            <span class="s1">has_own_setattr</span><span class="s3">,</span>
            <span class="s1">field_transformer</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s1">repr</span><span class="s3">, </span><span class="s1">auto_detect</span><span class="s3">, (</span><span class="s4">&quot;__repr__&quot;</span><span class="s3">,)</span>
        <span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_repr</span><span class="s3">(</span><span class="s1">repr_ns</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">str </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_str</span><span class="s3">()</span>

        <span class="s1">eq </span><span class="s3">= </span><span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s1">eq_</span><span class="s3">, </span><span class="s1">auto_detect</span><span class="s3">, (</span><span class="s4">&quot;__eq__&quot;</span><span class="s3">, </span><span class="s4">&quot;__ne__&quot;</span><span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">is_exc </span><span class="s2">and </span><span class="s1">eq </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_eq</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">is_exc </span><span class="s2">and </span><span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s1">order_</span><span class="s3">, </span><span class="s1">auto_detect</span><span class="s3">, (</span><span class="s4">&quot;__lt__&quot;</span><span class="s3">, </span><span class="s4">&quot;__le__&quot;</span><span class="s3">, </span><span class="s4">&quot;__gt__&quot;</span><span class="s3">, </span><span class="s4">&quot;__ge__&quot;</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_order</span><span class="s3">()</span>

        <span class="s2">if not </span><span class="s1">frozen</span><span class="s3">:</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_setattr</span><span class="s3">()</span>

        <span class="s2">nonlocal </span><span class="s1">hash</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">hash </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">auto_detect </span><span class="s2">is True</span>
            <span class="s2">and </span><span class="s1">_has_own_attribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__hash__&quot;</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s1">hash </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">hash </span><span class="s2">is not True and </span><span class="s1">hash </span><span class="s2">is not False and </span><span class="s1">hash </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># Can't use `hash in` because 1 == True for example.</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hash </span><span class="s2">is False or </span><span class="s3">(</span><span class="s1">hash </span><span class="s2">is None and </span><span class="s1">eq </span><span class="s2">is False</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_exc</span><span class="s3">:</span>
            <span class="s0"># Don't do anything. Should fall back to __object__'s __hash__</span>
            <span class="s0"># which is by id.</span>
            <span class="s2">if </span><span class="s1">cache_hash</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.&quot;</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hash </span><span class="s2">is True or </span><span class="s3">(</span>
            <span class="s1">hash </span><span class="s2">is None and </span><span class="s1">eq </span><span class="s2">is True and </span><span class="s1">is_frozen </span><span class="s2">is True</span>
        <span class="s3">):</span>
            <span class="s0"># Build a __hash__ if told so, or if it's safe.</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_hash</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Raise TypeError on attempts to hash.</span>
            <span class="s2">if </span><span class="s1">cache_hash</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.&quot;</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">make_unhashable</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">_determine_whether_to_implement</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">, </span><span class="s1">init</span><span class="s3">, </span><span class="s1">auto_detect</span><span class="s3">, (</span><span class="s4">&quot;__init__&quot;</span><span class="s3">,)</span>
        <span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_init</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_attrs_init</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">cache_hash</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Invalid value for cache_hash.  To use hash caching, init must be True.&quot;</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">PY_3_13_PLUS </span><span class="s2">and not </span><span class="s1">_has_own_attribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__replace__&quot;</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_replace</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">PY_3_10_PLUS</span>
            <span class="s2">and </span><span class="s1">match_args</span>
            <span class="s2">and not </span><span class="s1">_has_own_attribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__match_args__&quot;</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">add_match_args</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">build_class</span><span class="s3">()</span>

    <span class="s0"># maybe_cls's type depends on the usage of the decorator.  It's a class</span>
    <span class="s0"># if it's used as `@attrs` but `None` if used as `@attrs()`.</span>
    <span class="s2">if </span><span class="s1">maybe_cls </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">wrap</span>

    <span class="s2">return </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">maybe_cls</span><span class="s3">)</span>


<span class="s1">_attrs </span><span class="s3">= </span><span class="s1">attrs</span>
<span class="s4">&quot;&quot;&quot; 
Internal alias so we can use it in functions that take an argument called 
*attrs*. 
&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_has_frozen_base_class</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether *cls* has a frozen ancestor by looking at its 
    __setattr__. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__setattr__ </span><span class="s2">is </span><span class="s1">_frozen_setattrs</span>


<span class="s2">def </span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a &quot;filename&quot; suitable for a function being generated. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s4">f&quot;&lt;attrs generated </span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">} {</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__module__</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">'__qualname__'</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_make_hash_script</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Attribute</span><span class="s3">], </span><span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">cache_hash</span><span class="s3">: </span><span class="s1">bool</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]:</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span>
        <span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">hash </span><span class="s2">is True or </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">hash </span><span class="s2">is None and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq </span><span class="s2">is True</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s1">tab </span><span class="s3">= </span><span class="s4">&quot;        &quot;</span>

    <span class="s1">type_hash </span><span class="s3">= </span><span class="s1">hash</span><span class="s3">(</span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;hash&quot;</span><span class="s3">))</span>
    <span class="s0"># If eq is custom generated, we need to include the functions in globs</span>
    <span class="s1">globs </span><span class="s3">= {}</span>

    <span class="s1">hash_def </span><span class="s3">= </span><span class="s4">&quot;def __hash__(self&quot;</span>
    <span class="s1">hash_func </span><span class="s3">= </span><span class="s4">&quot;hash((&quot;</span>
    <span class="s1">closing_braces </span><span class="s3">= </span><span class="s4">&quot;))&quot;</span>
    <span class="s2">if not </span><span class="s1">cache_hash</span><span class="s3">:</span>
        <span class="s1">hash_def </span><span class="s3">+= </span><span class="s4">&quot;):&quot;</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">hash_def </span><span class="s3">+= </span><span class="s4">&quot;, *&quot;</span>

        <span class="s1">hash_def </span><span class="s3">+= </span><span class="s4">&quot;, _cache_wrapper=__import__('attr._make')._make._CacheHashWrapper):&quot;</span>
        <span class="s1">hash_func </span><span class="s3">= </span><span class="s4">&quot;_cache_wrapper(&quot; </span><span class="s3">+ </span><span class="s1">hash_func</span>
        <span class="s1">closing_braces </span><span class="s3">+= </span><span class="s4">&quot;)&quot;</span>

    <span class="s1">method_lines </span><span class="s3">= [</span><span class="s1">hash_def</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">append_hash_computation_lines</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">indent</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generate the code for actually computing the hash code. 
        Below this will either be returned directly or used to compute 
        a value which is then cached, depending on the value of cache_hash 
        &quot;&quot;&quot;</span>

        <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s1">indent </span><span class="s3">+ </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">hash_func</span><span class="s3">,</span>
                <span class="s1">indent </span><span class="s3">+ </span><span class="s4">f&quot;        </span><span class="s2">{</span><span class="s1">type_hash</span><span class="s2">}</span><span class="s4">,&quot;</span><span class="s3">,</span>
            <span class="s3">]</span>
        <span class="s3">)</span>

        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq_key</span><span class="s3">:</span>
                <span class="s1">cmp_name </span><span class="s3">= </span><span class="s4">f&quot;_</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">_key&quot;</span>
                <span class="s1">globs</span><span class="s3">[</span><span class="s1">cmp_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq_key</span>
                <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">indent </span><span class="s3">+ </span><span class="s4">f&quot;        </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s4">(self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">),&quot;</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indent </span><span class="s3">+ </span><span class="s4">f&quot;        self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">,&quot;</span><span class="s3">)</span>

        <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indent </span><span class="s3">+ </span><span class="s4">&quot;    &quot; </span><span class="s3">+ </span><span class="s1">closing_braces</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">cache_hash</span><span class="s3">:</span>
        <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tab </span><span class="s3">+ </span><span class="s4">f&quot;if self.</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">} </span><span class="s4">is None:&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">frozen</span><span class="s3">:</span>
            <span class="s1">append_hash_computation_lines</span><span class="s3">(</span>
                <span class="s4">f&quot;object.__setattr__(self, '</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">}</span><span class="s4">', &quot;</span><span class="s3">, </span><span class="s1">tab </span><span class="s3">* </span><span class="s6">2</span>
            <span class="s3">)</span>
            <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tab </span><span class="s3">* </span><span class="s6">2 </span><span class="s3">+ </span><span class="s4">&quot;)&quot;</span><span class="s3">)  </span><span class="s0"># close __setattr__</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">append_hash_computation_lines</span><span class="s3">(</span>
                <span class="s4">f&quot;self.</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">} </span><span class="s4">= &quot;</span><span class="s3">, </span><span class="s1">tab </span><span class="s3">* </span><span class="s6">2</span>
            <span class="s3">)</span>
        <span class="s1">method_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tab </span><span class="s3">+ </span><span class="s4">f&quot;return self.</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">append_hash_computation_lines</span><span class="s3">(</span><span class="s4">&quot;return &quot;</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">)</span>

    <span class="s1">script </span><span class="s3">= </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">method_lines</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span>


<span class="s2">def </span><span class="s1">_add_hash</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Attribute</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot; 
    Add a hash method to *cls*. 
    &quot;&quot;&quot;</span>
    <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_hash_script</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">frozen</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">cache_hash</span><span class="s3">=</span><span class="s2">False</span>
    <span class="s3">)</span>
    <span class="s1">_compile_and_eval</span><span class="s3">(</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">=</span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__hash__&quot;</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">cls</span><span class="s3">.</span><span class="s1">__hash__ </span><span class="s3">= </span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__hash__&quot;</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check equality and either forward a NotImplemented or 
    return the result negated. 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">return not </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_make_eq_script</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Create __eq__ method for *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">]</span>

    <span class="s1">lines </span><span class="s3">= [</span>
        <span class="s4">&quot;def __eq__(self, other):&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    if other.__class__ is not self.__class__:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;        return NotImplemented&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s1">globs </span><span class="s3">= {}</span>
    <span class="s2">if </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;    return  (&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq_key</span><span class="s3">:</span>
                <span class="s1">cmp_name </span><span class="s3">= </span><span class="s4">f&quot;_</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">_key&quot;</span>
                <span class="s0"># Add the key function to the global namespace</span>
                <span class="s0"># of the evaluated function.</span>
                <span class="s1">globs</span><span class="s3">[</span><span class="s1">cmp_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">eq_key</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s4">f&quot;        </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s4">(self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">) == </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s4">(other.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">)&quot;</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;        self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">} </span><span class="s4">== other.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">is not </span><span class="s1">attrs</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]:</span>
                <span class="s1">lines</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">lines</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span><span class="s2">} </span><span class="s4">and&quot;</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;    )&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;    return True&quot;</span><span class="s3">)</span>

    <span class="s1">script </span><span class="s3">= </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span>


<span class="s2">def </span><span class="s1">_make_order</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create ordering methods for *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">order</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Save us some typing. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">key</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) </span><span class="s2">if </span><span class="s1">key </span><span class="s2">else </span><span class="s1">value</span>
            <span class="s2">for </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key </span><span class="s2">in </span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">order_key</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span>
            <span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__lt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &lt; </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__le__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &lt;= </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__gt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &gt; </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__ge__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &gt;= </span><span class="s1">attrs_to_tuple</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">return </span><span class="s1">__lt__</span><span class="s3">, </span><span class="s1">__le__</span><span class="s3">, </span><span class="s1">__gt__</span><span class="s3">, </span><span class="s1">__ge__</span>


<span class="s2">def </span><span class="s1">_add_eq</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Add equality methods to *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">attrs </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_attrs__</span>

    <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_eq_script</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">)</span>
    <span class="s1">_compile_and_eval</span><span class="s3">(</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">=</span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__eq__&quot;</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">cls</span><span class="s3">.</span><span class="s1">__eq__ </span><span class="s3">= </span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__eq__&quot;</span><span class="s3">]</span>
    <span class="s1">cls</span><span class="s3">.</span><span class="s1">__ne__ </span><span class="s3">= </span><span class="s1">__ne__</span>

    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">_make_repr_script</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Create the source and globs for a __repr__ and return it. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Figure out which attributes to include, and which function to use to</span>
    <span class="s0"># format them. The a.repr value can be either bool or a custom</span>
    <span class="s0"># callable.</span>
    <span class="s1">attr_names_with_reprs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, (</span><span class="s1">repr </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">repr </span><span class="s2">is True else </span><span class="s1">a</span><span class="s3">.</span><span class="s1">repr</span><span class="s3">), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">repr </span><span class="s2">is not False</span>
    <span class="s3">)</span>
    <span class="s1">globs </span><span class="s3">= {</span>
        <span class="s1">name </span><span class="s3">+ </span><span class="s4">&quot;_repr&quot;</span><span class="s3">: </span><span class="s1">r </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">attr_names_with_reprs </span><span class="s2">if </span><span class="s1">r </span><span class="s3">!= </span><span class="s1">repr</span>
    <span class="s3">}</span>
    <span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;_compat&quot;</span><span class="s3">] = </span><span class="s1">_compat</span>
    <span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;AttributeError&quot;</span><span class="s3">] = </span><span class="s1">AttributeError</span>
    <span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;NOTHING&quot;</span><span class="s3">] = </span><span class="s1">NOTHING</span>
    <span class="s1">attribute_fragments </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">attr_names_with_reprs</span><span class="s3">:</span>
        <span class="s1">accessor </span><span class="s3">= (</span>
            <span class="s4">&quot;self.&quot; </span><span class="s3">+ </span><span class="s1">name </span><span class="s2">if </span><span class="s1">i </span><span class="s2">else </span><span class="s4">'getattr(self, &quot;' </span><span class="s3">+ </span><span class="s1">name </span><span class="s3">+ </span><span class="s4">'&quot;, NOTHING)'</span>
        <span class="s3">)</span>
        <span class="s1">fragment </span><span class="s3">= (</span>
            <span class="s4">&quot;%s={%s!r}&quot; </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">accessor</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">r </span><span class="s3">== </span><span class="s1">repr</span>
            <span class="s2">else </span><span class="s4">&quot;%s={%s_repr(%s)}&quot; </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">accessor</span><span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s1">attribute_fragments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fragment</span><span class="s3">)</span>
    <span class="s1">repr_fragment </span><span class="s3">= </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">attribute_fragments</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">ns </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">cls_name_fragment </span><span class="s3">= </span><span class="s4">'{self.__class__.__qualname__.rsplit(&quot;&gt;.&quot;, 1)[-1]}'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cls_name_fragment </span><span class="s3">= </span><span class="s1">ns </span><span class="s3">+ </span><span class="s4">&quot;.{self.__class__.__name__}&quot;</span>

    <span class="s1">lines </span><span class="s3">= [</span>
        <span class="s4">&quot;def __repr__(self):&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;  try:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    already_repring = _compat.repr_context.already_repring&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;  except AttributeError:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    already_repring = {id(self),}&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    _compat.repr_context.already_repring = already_repring&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;  else:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    if id(self) in already_repring:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;      return '...'&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    else:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;      already_repring.add(id(self))&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;  try:&quot;</span><span class="s3">,</span>
        <span class="s4">f&quot;    return f'</span><span class="s2">{</span><span class="s1">cls_name_fragment</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">repr_fragment</span><span class="s2">}</span><span class="s4">)'&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;  finally:&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;    already_repring.remove(id(self))&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">), </span><span class="s1">globs</span>


<span class="s2">def </span><span class="s1">_add_repr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Add a repr method to *cls*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">attrs </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_attrs__</span>

    <span class="s1">script</span><span class="s3">, </span><span class="s1">globs </span><span class="s3">= </span><span class="s1">_make_repr_script</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">)</span>
    <span class="s1">_compile_and_eval</span><span class="s3">(</span>
        <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">=</span><span class="s1">_generate_unique_filename</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__repr__&quot;</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">cls</span><span class="s3">.</span><span class="s1">__repr__ </span><span class="s3">= </span><span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;__repr__&quot;</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return the tuple of *attrs* attributes for a class. 
 
    The tuple also allows accessing the fields by their names (see below for 
    examples). 
 
    Args: 
        cls (type): Class to introspect. 
 
    Raises: 
        TypeError: If *cls* is not a class. 
 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    Returns: 
        tuple (with name accessors) of `attrs.Attribute` 
 
    .. versionchanged:: 16.2.0 Returned tuple allows accessing the fields 
       by name. 
    .. versionchanged:: 23.1.0 Add support for generic classes. 
    &quot;&quot;&quot;</span>
    <span class="s1">generic_base </span><span class="s3">= </span><span class="s1">get_generic_base</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">generic_base </span><span class="s2">is None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Passed object must be a class.&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">generic_base </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">generic_base</span><span class="s3">, </span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s0"># Even though this is global state, stick it on here to speed</span>
                <span class="s0"># it up. We rely on `cls` being cached for this to be</span>
                <span class="s0"># efficient.</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_attrs__ </span><span class="s3">= </span><span class="s1">attrs</span>
                <span class="s2">return </span><span class="s1">attrs</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s2">!r} </span><span class="s4">is not an attrs-decorated class.&quot;</span>
        <span class="s2">raise </span><span class="s1">NotAnAttrsClassError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">attrs</span>


<span class="s2">def </span><span class="s1">fields_dict</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return an ordered dictionary of *attrs* attributes for a class, whose keys 
    are the attribute names. 
 
    Args: 
        cls (type): Class to introspect. 
 
    Raises: 
        TypeError: If *cls* is not a class. 
 
        attrs.exceptions.NotAnAttrsClassError: 
            If *cls* is not an *attrs* class. 
 
    Returns: 
        dict[str, attrs.Attribute]: Dict of attribute name to definition 
 
    .. versionadded:: 18.1.0 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Passed object must be a class.&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s4">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s2">!r} </span><span class="s4">is not an attrs-decorated class.&quot;</span>
        <span class="s2">raise </span><span class="s1">NotAnAttrsClassError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">: </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">validate</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Validate all attributes on *inst* that have a validator. 
 
    Leaves all exceptions through. 
 
    Args: 
        inst: Instance of a class with *attrs* attributes. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_config</span><span class="s3">.</span><span class="s1">_run_validators </span><span class="s2">is False</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">):</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">validator</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">v</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_is_slot_attr</span><span class="s3">(</span><span class="s1">a_name</span><span class="s3">, </span><span class="s1">base_attr_map</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check if the attribute name comes from a slot class. 
    &quot;&quot;&quot;</span>
    <span class="s1">cls </span><span class="s3">= </span><span class="s1">base_attr_map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">a_name</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">cls </span><span class="s2">and </span><span class="s4">&quot;__slots__&quot; </span><span class="s2">in </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__dict__</span>


<span class="s2">def </span><span class="s1">_make_init_script</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">,</span>
    <span class="s1">attrs</span><span class="s3">,</span>
    <span class="s1">pre_init</span><span class="s3">,</span>
    <span class="s1">pre_init_has_args</span><span class="s3">,</span>
    <span class="s1">post_init</span><span class="s3">,</span>
    <span class="s1">frozen</span><span class="s3">,</span>
    <span class="s1">slots</span><span class="s3">,</span>
    <span class="s1">cache_hash</span><span class="s3">,</span>
    <span class="s1">base_attr_map</span><span class="s3">,</span>
    <span class="s1">is_exc</span><span class="s3">,</span>
    <span class="s1">cls_on_setattr</span><span class="s3">,</span>
    <span class="s1">attrs_init</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]:</span>
    <span class="s1">has_cls_on_setattr </span><span class="s3">= (</span>
        <span class="s1">cls_on_setattr </span><span class="s2">is not None and </span><span class="s1">cls_on_setattr </span><span class="s2">is not </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">NO_OP</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">frozen </span><span class="s2">and </span><span class="s1">has_cls_on_setattr</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Frozen classes can't use on_setattr.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">needs_cached_setattr </span><span class="s3">= </span><span class="s1">cache_hash </span><span class="s2">or </span><span class="s1">frozen</span>
    <span class="s1">filtered_attrs </span><span class="s3">= []</span>
    <span class="s1">attr_dict </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s1">filtered_attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">attr_dict</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">a</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">frozen </span><span class="s2">is True</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Frozen classes can't use on_setattr.&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

            <span class="s1">needs_cached_setattr </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">has_cls_on_setattr </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s2">is not </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">NO_OP</span><span class="s3">:</span>
            <span class="s1">needs_cached_setattr </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">annotations </span><span class="s3">= </span><span class="s1">_attrs_to_init_script</span><span class="s3">(</span>
        <span class="s1">filtered_attrs</span><span class="s3">,</span>
        <span class="s1">frozen</span><span class="s3">,</span>
        <span class="s1">slots</span><span class="s3">,</span>
        <span class="s1">pre_init</span><span class="s3">,</span>
        <span class="s1">pre_init_has_args</span><span class="s3">,</span>
        <span class="s1">post_init</span><span class="s3">,</span>
        <span class="s1">cache_hash</span><span class="s3">,</span>
        <span class="s1">base_attr_map</span><span class="s3">,</span>
        <span class="s1">is_exc</span><span class="s3">,</span>
        <span class="s1">needs_cached_setattr</span><span class="s3">,</span>
        <span class="s1">has_cls_on_setattr</span><span class="s3">,</span>
        <span class="s4">&quot;__attrs_init__&quot; </span><span class="s2">if </span><span class="s1">attrs_init </span><span class="s2">else </span><span class="s4">&quot;__init__&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__module__ </span><span class="s2">in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s0"># This makes typing.get_type_hints(CLS.__init__) resolve string types.</span>
        <span class="s1">globs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__module__</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">)</span>

    <span class="s1">globs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s4">&quot;NOTHING&quot;</span><span class="s3">: </span><span class="s1">NOTHING</span><span class="s3">, </span><span class="s4">&quot;attr_dict&quot;</span><span class="s3">: </span><span class="s1">attr_dict</span><span class="s3">})</span>

    <span class="s2">if </span><span class="s1">needs_cached_setattr</span><span class="s3">:</span>
        <span class="s0"># Save the lookup overhead in __init__ if we need to circumvent</span>
        <span class="s0"># setattr hooks.</span>
        <span class="s1">globs</span><span class="s3">[</span><span class="s4">&quot;_cached_setattr_get&quot;</span><span class="s3">] = </span><span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span>

    <span class="s2">return </span><span class="s1">script</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">annotations</span>


<span class="s2">def </span><span class="s1">_setattr</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Use the cached object.setattr to set *attr_name* to *value_var*. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s4">f&quot;_setattr('</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">', </span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">)&quot;</span>


<span class="s2">def </span><span class="s1">_setattr_with_converter</span><span class="s3">(</span>
    <span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">: </span><span class="s1">Converter</span>
<span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Use the cached object.setattr to set *attr_name* to *value_var*, but run 
    its converter first. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s4">f&quot;_setattr('</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">', </span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_fmt_converter_call</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">)</span><span class="s2">}</span><span class="s4">)&quot;</span>


<span class="s2">def </span><span class="s1">_assign</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise 
    relegate to _setattr. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">has_on_setattr</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_setattr</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s4">f&quot;self.</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">} </span><span class="s4">= </span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">_assign_with_converter</span><span class="s3">(</span>
    <span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">: </span><span class="s1">Converter</span>
<span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Unless *attr_name* has an on_setattr hook, use normal assignment after 
    conversion. Otherwise relegate to _setattr_with_converter. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">has_on_setattr</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_setattr_with_converter</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s4">f&quot;self.</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">} </span><span class="s4">= </span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_fmt_converter_call</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">_determine_setters</span><span class="s3">(</span>
    <span class="s1">frozen</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">slots</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">base_attr_map</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">type</span><span class="s3">]</span>
<span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Determine the correct setter functions based on whether a class is frozen 
    and/or slotted. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">frozen </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">slots </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(), </span><span class="s1">_setattr</span><span class="s3">, </span><span class="s1">_setattr_with_converter</span>

        <span class="s0"># Dict frozen classes assign directly to __dict__.</span>
        <span class="s0"># But only if the attribute doesn't come from an ancestor slot</span>
        <span class="s0"># class.</span>
        <span class="s0"># Note _inst_dict will be used again below if cache_hash is True</span>

        <span class="s2">def </span><span class="s1">fmt_setter</span><span class="s3">(</span>
            <span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span>
        <span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">_is_slot_attr</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">base_attr_map</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">_setattr</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s4">f&quot;_inst_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'] = </span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">def </span><span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
            <span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
            <span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
            <span class="s1">has_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
            <span class="s1">converter</span><span class="s3">: </span><span class="s1">Converter</span><span class="s3">,</span>
        <span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has_on_setattr </span><span class="s2">or </span><span class="s1">_is_slot_attr</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">base_attr_map</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">_setattr_with_converter</span><span class="s3">(</span>
                    <span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">, </span><span class="s1">converter</span>
                <span class="s3">)</span>

            <span class="s2">return </span><span class="s4">f&quot;_inst_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'] = </span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_fmt_converter_call</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">return </span><span class="s3">(</span>
            <span class="s3">(</span><span class="s4">&quot;_inst_dict = self.__dict__&quot;</span><span class="s3">,),</span>
            <span class="s1">fmt_setter</span><span class="s3">,</span>
            <span class="s1">fmt_setter_with_converter</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s0"># Not frozen -- we can just assign directly.</span>
    <span class="s2">return </span><span class="s3">(), </span><span class="s1">_assign</span><span class="s3">, </span><span class="s1">_assign_with_converter</span>


<span class="s2">def </span><span class="s1">_attrs_to_init_script</span><span class="s3">(</span>
    <span class="s1">attrs</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Attribute</span><span class="s3">],</span>
    <span class="s1">is_frozen</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">is_slotted</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">call_pre_init</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">pre_init_has_args</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">call_post_init</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">does_cache_hash</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">base_attr_map</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">type</span><span class="s3">],</span>
    <span class="s1">is_exc</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">needs_cached_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">has_cls_on_setattr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s1">method_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Return a script of an initializer for *attrs*, a dict of globals, and 
    annotations for the initializer. 
 
    The globals are required by the generated script. 
    &quot;&quot;&quot;</span>
    <span class="s1">lines </span><span class="s3">= [</span><span class="s4">&quot;self.__attrs_pre_init__()&quot;</span><span class="s3">] </span><span class="s2">if </span><span class="s1">call_pre_init </span><span class="s2">else </span><span class="s3">[]</span>

    <span class="s2">if </span><span class="s1">needs_cached_setattr</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s0"># Circumvent the __setattr__ descriptor to save one lookup per</span>
            <span class="s0"># assignment. Note _setattr will be used again below if</span>
            <span class="s0"># does_cache_hash is True.</span>
            <span class="s4">&quot;_setattr = _cached_setattr_get(self)&quot;</span>
        <span class="s3">)</span>

    <span class="s1">extra_lines</span><span class="s3">, </span><span class="s1">fmt_setter</span><span class="s3">, </span><span class="s1">fmt_setter_with_converter </span><span class="s3">= </span><span class="s1">_determine_setters</span><span class="s3">(</span>
        <span class="s1">is_frozen</span><span class="s3">, </span><span class="s1">is_slotted</span><span class="s3">, </span><span class="s1">base_attr_map</span>
    <span class="s3">)</span>
    <span class="s1">lines</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">extra_lines</span><span class="s3">)</span>

    <span class="s1">args </span><span class="s3">= []</span>
    <span class="s1">kw_only_args </span><span class="s3">= []</span>
    <span class="s1">attrs_to_validate </span><span class="s3">= []</span>

    <span class="s0"># This is a dictionary of names to validator and converter callables.</span>
    <span class="s0"># Injecting this into __init__ globals lets us avoid lookups.</span>
    <span class="s1">names_for_globals </span><span class="s3">= {}</span>
    <span class="s1">annotations </span><span class="s3">= {</span><span class="s4">&quot;return&quot;</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}</span>

    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">validator</span><span class="s3">:</span>
            <span class="s1">attrs_to_validate</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">attr_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">has_on_setattr </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s2">is not None or </span><span class="s3">(</span>
            <span class="s1">a</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s2">is not </span><span class="s1">setters</span><span class="s3">.</span><span class="s1">NO_OP </span><span class="s2">and </span><span class="s1">has_cls_on_setattr</span>
        <span class="s3">)</span>
        <span class="s0"># a.alias is set to maybe-mangled attr_name in _ClassBuilder if not</span>
        <span class="s0"># explicitly provided</span>
        <span class="s1">arg_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">alias</span>

        <span class="s1">has_factory </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">default</span><span class="s3">, </span><span class="s1">Factory</span><span class="s3">)</span>
        <span class="s1">maybe_self </span><span class="s3">= </span><span class="s4">&quot;self&quot; </span><span class="s2">if </span><span class="s1">has_factory </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">else </span><span class="s4">&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">converter </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">, </span><span class="s1">Converter</span><span class="s3">):</span>
            <span class="s1">converter </span><span class="s3">= </span><span class="s1">Converter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">converter </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">converter</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init </span><span class="s2">is False</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has_factory</span><span class="s3">:</span>
                <span class="s1">init_factory_name </span><span class="s3">= </span><span class="s1">_INIT_FACTORY_PAT </span><span class="s3">% (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,)</span>
                <span class="s2">if </span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                        <span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                            <span class="s1">attr_name</span><span class="s3">,</span>
                            <span class="s1">init_factory_name </span><span class="s3">+ </span><span class="s4">f&quot;(</span><span class="s2">{</span><span class="s1">maybe_self</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">,</span>
                            <span class="s1">has_on_setattr</span><span class="s3">,</span>
                            <span class="s1">converter</span><span class="s3">,</span>
                        <span class="s3">)</span>
                    <span class="s3">)</span>
                    <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)] = (</span>
                        <span class="s1">converter</span><span class="s3">.</span><span class="s1">converter</span>
                    <span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                        <span class="s1">fmt_setter</span><span class="s3">(</span>
                            <span class="s1">attr_name</span><span class="s3">,</span>
                            <span class="s1">init_factory_name </span><span class="s3">+ </span><span class="s4">f&quot;(</span><span class="s2">{</span><span class="s1">maybe_self</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">,</span>
                            <span class="s1">has_on_setattr</span><span class="s3">,</span>
                        <span class="s3">)</span>
                    <span class="s3">)</span>
                <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">init_factory_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">factory</span>
            <span class="s2">elif </span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">,</span>
                        <span class="s4">f&quot;attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'].default&quot;</span><span class="s3">,</span>
                        <span class="s1">has_on_setattr</span><span class="s3">,</span>
                        <span class="s1">converter</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)] = (</span>
                    <span class="s1">converter</span><span class="s3">.</span><span class="s1">converter</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">fmt_setter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">,</span>
                        <span class="s4">f&quot;attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'].default&quot;</span><span class="s3">,</span>
                        <span class="s1">has_on_setattr</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is not </span><span class="s1">NOTHING </span><span class="s2">and not </span><span class="s1">has_factory</span><span class="s3">:</span>
            <span class="s1">arg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">}</span><span class="s4">=attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'].default&quot;</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">kw_only</span><span class="s3">:</span>
                <span class="s1">kw_only_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">, </span><span class="s1">converter</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)] = (</span>
                    <span class="s1">converter</span><span class="s3">.</span><span class="s1">converter</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fmt_setter</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">))</span>

        <span class="s2">elif </span><span class="s1">has_factory</span><span class="s3">:</span>
            <span class="s1">arg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">}</span><span class="s4">=NOTHING&quot;</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">kw_only</span><span class="s3">:</span>
                <span class="s1">kw_only_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;if </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">} </span><span class="s4">is not NOTHING:&quot;</span><span class="s3">)</span>

            <span class="s1">init_factory_name </span><span class="s3">= </span><span class="s1">_INIT_FACTORY_PAT </span><span class="s3">% (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,)</span>
            <span class="s2">if </span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s4">&quot;    &quot;</span>
                    <span class="s3">+ </span><span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">, </span><span class="s1">converter</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;else:&quot;</span><span class="s3">)</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s4">&quot;    &quot;</span>
                    <span class="s3">+ </span><span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">,</span>
                        <span class="s1">init_factory_name </span><span class="s3">+ </span><span class="s4">&quot;(&quot; </span><span class="s3">+ </span><span class="s1">maybe_self </span><span class="s3">+ </span><span class="s4">&quot;)&quot;</span><span class="s3">,</span>
                        <span class="s1">has_on_setattr</span><span class="s3">,</span>
                        <span class="s1">converter</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)] = (</span>
                    <span class="s1">converter</span><span class="s3">.</span><span class="s1">converter</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s4">&quot;    &quot; </span><span class="s3">+ </span><span class="s1">fmt_setter</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;else:&quot;</span><span class="s3">)</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s4">&quot;    &quot;</span>
                    <span class="s3">+ </span><span class="s1">fmt_setter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">,</span>
                        <span class="s1">init_factory_name </span><span class="s3">+ </span><span class="s4">&quot;(&quot; </span><span class="s3">+ </span><span class="s1">maybe_self </span><span class="s3">+ </span><span class="s4">&quot;)&quot;</span><span class="s3">,</span>
                        <span class="s1">has_on_setattr</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">init_factory_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">factory</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">kw_only</span><span class="s3">:</span>
                <span class="s1">kw_only_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg_name</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg_name</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">converter </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">fmt_setter_with_converter</span><span class="s3">(</span>
                        <span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">, </span><span class="s1">converter</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)] = (</span>
                    <span class="s1">converter</span><span class="s3">.</span><span class="s1">converter</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fmt_setter</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">has_on_setattr</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None and </span><span class="s1">converter </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">annotations</span><span class="s3">[</span><span class="s1">arg_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s2">elif </span><span class="s1">converter </span><span class="s2">is not None and </span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_first_param_type</span><span class="s3">:</span>
                <span class="s0"># Use the type from the converter if present.</span>
                <span class="s1">annotations</span><span class="s3">[</span><span class="s1">arg_name</span><span class="s3">] = </span><span class="s1">converter</span><span class="s3">.</span><span class="s1">_first_param_type</span>

    <span class="s2">if </span><span class="s1">attrs_to_validate</span><span class="s3">:  </span><span class="s0"># we can skip this if there are no validators.</span>
        <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s4">&quot;_config&quot;</span><span class="s3">] = </span><span class="s1">_config</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;if _config._run_validators is True:&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs_to_validate</span><span class="s3">:</span>
            <span class="s1">val_name </span><span class="s3">= </span><span class="s4">&quot;__attr_validator_&quot; </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s1">attr_name </span><span class="s3">= </span><span class="s4">&quot;__attr_&quot; </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;    </span><span class="s2">{</span><span class="s1">val_name</span><span class="s2">}</span><span class="s4">(self, </span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">, self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>
            <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">val_name</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">validator</span>
            <span class="s1">names_for_globals</span><span class="s3">[</span><span class="s1">attr_name</span><span class="s3">] = </span><span class="s1">a</span>

    <span class="s2">if </span><span class="s1">call_post_init</span><span class="s3">:</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;self.__attrs_post_init__()&quot;</span><span class="s3">)</span>

    <span class="s0"># Because this is set only after __attrs_post_init__ is called, a crash</span>
    <span class="s0"># will result if post-init tries to access the hash code.  This seemed</span>
    <span class="s0"># preferable to setting this beforehand, in which case alteration to field</span>
    <span class="s0"># values during post-init combined with post-init accessing the hash code</span>
    <span class="s0"># would result in silent bugs.</span>
    <span class="s2">if </span><span class="s1">does_cache_hash</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">is_frozen</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">is_slotted</span><span class="s3">:</span>
                <span class="s1">init_hash_cache </span><span class="s3">= </span><span class="s4">f&quot;_setattr('</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">}</span><span class="s4">', None)&quot;</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">init_hash_cache </span><span class="s3">= </span><span class="s4">f&quot;_inst_dict['</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">}</span><span class="s4">'] = None&quot;</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">init_hash_cache </span><span class="s3">= </span><span class="s4">f&quot;self.</span><span class="s2">{</span><span class="s1">_HASH_CACHE_FIELD</span><span class="s2">} </span><span class="s4">= None&quot;</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">init_hash_cache</span><span class="s3">)</span>

    <span class="s0"># For exceptions we rely on BaseException.__init__ for proper</span>
    <span class="s0"># initialization.</span>
    <span class="s2">if </span><span class="s1">is_exc</span><span class="s3">:</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s4">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s4">f&quot;self.</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init</span><span class="s3">)</span>

        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;BaseException.__init__(self, </span><span class="s2">{</span><span class="s1">vals</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>

    <span class="s1">args </span><span class="s3">= </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">pre_init_args </span><span class="s3">= </span><span class="s1">args</span>
    <span class="s2">if </span><span class="s1">kw_only_args</span><span class="s3">:</span>
        <span class="s0"># leading comma &amp; kw_only args</span>
        <span class="s1">args </span><span class="s3">+= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s4">', ' </span><span class="s2">if </span><span class="s1">args </span><span class="s2">else </span><span class="s4">''</span><span class="s2">}</span><span class="s4">*, </span><span class="s2">{</span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">kw_only_args</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">pre_init_kw_only_args </span><span class="s3">= </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">kw_arg_name</span><span class="s2">}</span><span class="s4">=</span><span class="s2">{</span><span class="s1">kw_arg_name</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s0"># We need to remove the defaults from the kw_only_args.</span>
                <span class="s2">for </span><span class="s1">kw_arg_name </span><span class="s2">in </span><span class="s3">(</span><span class="s1">kwa</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">&quot;=&quot;</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">kwa </span><span class="s2">in </span><span class="s1">kw_only_args</span><span class="s3">)</span>
            <span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s1">pre_init_args </span><span class="s3">+= </span><span class="s4">&quot;, &quot; </span><span class="s2">if </span><span class="s1">pre_init_args </span><span class="s2">else </span><span class="s4">&quot;&quot;</span>
        <span class="s1">pre_init_args </span><span class="s3">+= </span><span class="s1">pre_init_kw_only_args</span>

    <span class="s2">if </span><span class="s1">call_pre_init </span><span class="s2">and </span><span class="s1">pre_init_has_args</span><span class="s3">:</span>
        <span class="s0"># If pre init method has arguments, pass same arguments as `__init__`.</span>
        <span class="s1">lines</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s4">f&quot;self.__attrs_pre_init__(</span><span class="s2">{</span><span class="s1">pre_init_args</span><span class="s2">}</span><span class="s4">)&quot;</span>

    <span class="s0"># Python &lt;3.12 doesn't allow backslashes in f-strings.</span>
    <span class="s1">NL </span><span class="s3">= </span><span class="s4">&quot;</span><span class="s2">\n    </span><span class="s4">&quot;</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s4">f&quot;&quot;&quot;def </span><span class="s2">{</span><span class="s1">method_name</span><span class="s2">}</span><span class="s4">(self, </span><span class="s2">{</span><span class="s1">args</span><span class="s2">}</span><span class="s4">):</span>
    <span class="s2">{</span><span class="s1">NL</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">) </span><span class="s2">if </span><span class="s1">lines </span><span class="s2">else </span><span class="s4">&quot;pass&quot;</span><span class="s2">}</span>
<span class="s4">&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">names_for_globals</span><span class="s3">,</span>
        <span class="s1">annotations</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_default_init_alias_for</span><span class="s3">(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    The default __init__ parameter name for a field. 
 
    This performs private-name adjustment via leading-unscore stripping, 
    and is the default value of Attribute.alias if not provided. 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">name</span><span class="s3">.</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Attribute</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    *Read-only* representation of an attribute. 
 
    .. warning:: 
 
       You should never instantiate this class yourself. 
 
    The class has *all* arguments of `attr.ib` (except for ``factory`` which is 
    only syntactic sugar for ``default=Factory(...)`` plus the following: 
 
    - ``name`` (`str`): The name of the attribute. 
    - ``alias`` (`str`): The __init__ parameter name of the attribute, after 
      any explicit overrides and default private-attribute-name handling. 
    - ``inherited`` (`bool`): Whether or not that attribute has been inherited 
      from a base class. 
    - ``eq_key`` and ``order_key`` (`typing.Callable` or `None`): The 
      callables that are used for comparing and ordering objects by this 
      attribute, respectively. These are set by passing a callable to 
      `attr.ib`'s ``eq``, ``order``, or ``cmp`` arguments. See also 
      :ref:`comparison customization &lt;custom-comparison&gt;`. 
 
    Instances of this class are frequently used for introspection purposes 
    like: 
 
    - `fields` returns a tuple of them. 
    - Validators get them passed as the first argument. 
    - The :ref:`field transformer &lt;transform-fields&gt;` hook receives a list of 
      them. 
    - The ``alias`` property exposes the __init__ parameter name of the field, 
      with any overrides and default private-attribute handling applied. 
 
 
    .. versionadded:: 20.1.0 *inherited* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionchanged:: 20.2.0 *inherited* is not taken into account for 
        equality checks and hashing anymore. 
    .. versionadded:: 21.1.0 *eq_key* and *order_key* 
    .. versionadded:: 22.2.0 *alias* 
 
    For the full version history of the fields, see `attr.ib`. 
    &quot;&quot;&quot;</span>

    <span class="s0"># These slots must NOT be reordered because we use them later for</span>
    <span class="s0"># instantiation.</span>
    <span class="s1">__slots__ </span><span class="s3">= (  </span><span class="s0"># noqa: RUF023</span>
        <span class="s4">&quot;name&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;default&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;validator&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;repr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;eq&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;eq_key&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;order&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;order_key&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;hash&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;init&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;metadata&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;type&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;converter&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;kw_only&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;inherited&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;on_setattr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;alias&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">,  </span><span class="s0"># XXX: unused, remove along with other cmp code.</span>
        <span class="s1">hash</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">,</span>
        <span class="s1">inherited</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">converter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">eq_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">order_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">on_setattr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">eq</span><span class="s3">, </span><span class="s1">eq_key</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">order_key </span><span class="s3">= </span><span class="s1">_determine_attrib_eq_order</span><span class="s3">(</span>
            <span class="s1">cmp</span><span class="s3">, </span><span class="s1">eq_key </span><span class="s2">or </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">order_key </span><span class="s2">or </span><span class="s1">order</span><span class="s3">, </span><span class="s2">True</span>
        <span class="s3">)</span>

        <span class="s0"># Cache this descriptor here to speed things up later.</span>
        <span class="s1">bound_setattr </span><span class="s3">= </span><span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s0"># Despite the big red warning, people *do* instantiate `Attribute`</span>
        <span class="s0"># themselves.</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s1">default</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;validator&quot;</span><span class="s3">, </span><span class="s1">validator</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;repr&quot;</span><span class="s3">, </span><span class="s1">repr</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;eq&quot;</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;eq_key&quot;</span><span class="s3">, </span><span class="s1">eq_key</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;order&quot;</span><span class="s3">, </span><span class="s1">order</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;order_key&quot;</span><span class="s3">, </span><span class="s1">order_key</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;hash&quot;</span><span class="s3">, </span><span class="s1">hash</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;init&quot;</span><span class="s3">, </span><span class="s1">init</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;converter&quot;</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span>
            <span class="s4">&quot;metadata&quot;</span><span class="s3">,</span>
            <span class="s3">(</span>
                <span class="s1">types</span><span class="s3">.</span><span class="s1">MappingProxyType</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">))  </span><span class="s0"># Shallow copy</span>
                <span class="s2">if </span><span class="s1">metadata</span>
                <span class="s2">else </span><span class="s1">_EMPTY_METADATA_SINGLETON</span>
            <span class="s3">),</span>
        <span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;type&quot;</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;kw_only&quot;</span><span class="s3">, </span><span class="s1">kw_only</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;inherited&quot;</span><span class="s3">, </span><span class="s1">inherited</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;on_setattr&quot;</span><span class="s3">, </span><span class="s1">on_setattr</span><span class="s3">)</span>
        <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s4">&quot;alias&quot;</span><span class="s3">, </span><span class="s1">alias</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">FrozenInstanceError</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_counting_attr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">ca</span><span class="s3">: </span><span class="s1">_CountingAttr</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># type holds the annotated value. deal with conflicts:</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">type </span><span class="s3">= </span><span class="s1">ca</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s2">elif </span><span class="s1">ca</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;Type annotation and type argument cannot both be present for '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">_default</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">_validator</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">repr</span><span class="s3">,</span>
            <span class="s2">None</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">init</span><span class="s3">,</span>
            <span class="s2">False</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">type</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">kw_only</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">eq_key</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">order</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">order_key</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">on_setattr</span><span class="s3">,</span>
            <span class="s1">ca</span><span class="s3">.</span><span class="s1">alias</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s0"># Don't use attrs.evolve since fields(Attribute) doesn't work</span>
    <span class="s2">def </span><span class="s1">evolve</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Copy *self* and apply *changes*. 
 
        This works similarly to `attrs.evolve` but that function does not work 
        with :class:`attrs.Attribute`. 
 
        It is mainly meant to be used for `transform-fields`. 
 
        .. versionadded:: 20.3.0 
        &quot;&quot;&quot;</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">new</span><span class="s3">.</span><span class="s1">_setattrs</span><span class="s3">(</span><span class="s1">changes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>

        <span class="s2">return </span><span class="s1">new</span>

    <span class="s0"># Don't use _add_pickle since fields(Attribute) doesn't work</span>
    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">) </span><span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;metadata&quot; </span><span class="s2">else </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__slots__</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setattrs</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__slots__</span><span class="s3">, </span><span class="s1">state</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_setattrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name_values_pairs</span><span class="s3">):</span>
        <span class="s1">bound_setattr </span><span class="s3">= </span><span class="s1">_OBJ_SETATTR</span><span class="s3">.</span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">name_values_pairs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;metadata&quot;</span><span class="s3">:</span>
                <span class="s1">bound_setattr</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">bound_setattr</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">,</span>
                    <span class="s3">(</span>
                        <span class="s1">types</span><span class="s3">.</span><span class="s1">MappingProxyType</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
                        <span class="s2">if </span><span class="s1">value</span>
                        <span class="s2">else </span><span class="s1">_EMPTY_METADATA_SINGLETON</span>
                    <span class="s3">),</span>
                <span class="s3">)</span>


<span class="s1">_a </span><span class="s3">= [</span>
    <span class="s1">Attribute</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s1">NOTHING</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">hash</span><span class="s3">=(</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;metadata&quot;</span><span class="s3">),</span>
        <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inherited</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">=</span><span class="s1">_default_init_alias_for</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">Attribute</span><span class="s3">.</span><span class="s1">__slots__</span>
<span class="s3">]</span>

<span class="s1">Attribute </span><span class="s3">= </span><span class="s1">_add_hash</span><span class="s3">(</span>
    <span class="s1">_add_eq</span><span class="s3">(</span>
        <span class="s1">_add_repr</span><span class="s3">(</span><span class="s1">Attribute</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_a</span><span class="s3">),</span>
        <span class="s1">attrs</span><span class="s3">=[</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">_a </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;inherited&quot;</span><span class="s3">],</span>
    <span class="s3">),</span>
    <span class="s1">attrs</span><span class="s3">=[</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">_a </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">hash </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;inherited&quot;</span><span class="s3">],</span>
<span class="s3">)</span>


<span class="s2">class </span><span class="s1">_CountingAttr</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Intermediate representation of attributes that uses a counter to preserve 
    the order in which the attributes have been defined. 
 
    *Internal* data structure of the attrs library.  Running into is most 
    likely the result of a bug like a forgotten `@attr.s` decorator. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;_default&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_validator&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;alias&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;converter&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;counter&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;eq&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;eq_key&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;hash&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;init&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;kw_only&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;metadata&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;on_setattr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;order&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;order_key&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;repr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;type&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">__attrs_attrs__ </span><span class="s3">= (</span>
        <span class="s3">*</span><span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">Attribute</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
                <span class="s1">alias</span><span class="s3">=</span><span class="s1">_default_init_alias_for</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
                <span class="s1">default</span><span class="s3">=</span><span class="s1">NOTHING</span><span class="s3">,</span>
                <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">hash</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">eq</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">eq_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">order</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">order_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">inherited</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">on_setattr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span>
                <span class="s4">&quot;counter&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;_default&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;repr&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;eq&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;order&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;hash&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;init&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;on_setattr&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;alias&quot;</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s3">),</span>
        <span class="s1">Attribute</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;metadata&quot;</span><span class="s3">,</span>
            <span class="s1">alias</span><span class="s3">=</span><span class="s4">&quot;metadata&quot;</span><span class="s3">,</span>
            <span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">hash</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">kw_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">eq</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">eq_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">order</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">order_key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">inherited</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">on_setattr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">cls_counter </span><span class="s3">= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">,</span>
        <span class="s1">hash</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">,</span>
        <span class="s1">converter</span><span class="s3">,</span>
        <span class="s1">metadata</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">,</span>
        <span class="s1">kw_only</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">,</span>
        <span class="s1">eq_key</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">,</span>
        <span class="s1">order_key</span><span class="s3">,</span>
        <span class="s1">on_setattr</span><span class="s3">,</span>
        <span class="s1">alias</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">_CountingAttr</span><span class="s3">.</span><span class="s1">cls_counter </span><span class="s3">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">counter </span><span class="s3">= </span><span class="s1">_CountingAttr</span><span class="s3">.</span><span class="s1">cls_counter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_default </span><span class="s3">= </span><span class="s1">default</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_validator </span><span class="s3">= </span><span class="s1">validator</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">converter </span><span class="s3">= </span><span class="s1">converter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">repr </span><span class="s3">= </span><span class="s1">repr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">eq </span><span class="s3">= </span><span class="s1">eq</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">eq_key </span><span class="s3">= </span><span class="s1">eq_key</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">order </span><span class="s3">= </span><span class="s1">order</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">order_key </span><span class="s3">= </span><span class="s1">order_key</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">= </span><span class="s1">hash</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">init </span><span class="s3">= </span><span class="s1">init</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">metadata </span><span class="s3">= </span><span class="s1">metadata</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">type</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kw_only </span><span class="s3">= </span><span class="s1">kw_only</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">on_setattr </span><span class="s3">= </span><span class="s1">on_setattr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">alias </span><span class="s3">= </span><span class="s1">alias</span>

    <span class="s2">def </span><span class="s1">validator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Decorator that adds *meth* to the list of validators. 
 
        Returns *meth* unchanged. 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validator </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_validator </span><span class="s3">= </span><span class="s1">meth</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_validator </span><span class="s3">= </span><span class="s1">and_</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validator</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">meth</span>

    <span class="s2">def </span><span class="s1">default</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Decorator that allows to set the default for an attribute. 
 
        Returns *meth* unchanged. 
 
        Raises: 
            DefaultAlreadySetError: If default has been set before. 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_default </span><span class="s2">is not </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DefaultAlreadySetError</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_default </span><span class="s3">= </span><span class="s1">Factory</span><span class="s3">(</span><span class="s1">meth</span><span class="s3">, </span><span class="s1">takes_self</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">meth</span>


<span class="s1">_CountingAttr </span><span class="s3">= </span><span class="s1">_add_eq</span><span class="s3">(</span><span class="s1">_add_repr</span><span class="s3">(</span><span class="s1">_CountingAttr</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">Factory</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Stores a factory callable. 
 
    If passed as the default value to `attrs.field`, the factory is used to 
    generate a new value. 
 
    Args: 
        factory (typing.Callable): 
            A callable that takes either none or exactly one mandatory 
            positional argument depending on *takes_self*. 
 
        takes_self (bool): 
            Pass the partially initialized instance that is being initialized 
            as a positional argument. 
 
    .. versionadded:: 17.1.0  *takes_self* 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;factory&quot;</span><span class="s3">, </span><span class="s4">&quot;takes_self&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">factory</span><span class="s3">, </span><span class="s1">takes_self</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">factory </span><span class="s3">= </span><span class="s1">factory</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s3">= </span><span class="s1">takes_self</span>

    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__slots__</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__slots__</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s1">_f </span><span class="s3">= [</span>
    <span class="s1">Attribute</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s1">NOTHING</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">hash</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inherited</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">Factory</span><span class="s3">.</span><span class="s1">__slots__</span>
<span class="s3">]</span>

<span class="s1">Factory </span><span class="s3">= </span><span class="s1">_add_hash</span><span class="s3">(</span><span class="s1">_add_eq</span><span class="s3">(</span><span class="s1">_add_repr</span><span class="s3">(</span><span class="s1">Factory</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span><span class="s3">), </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span><span class="s3">), </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Converter</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Stores a converter callable. 
 
    Allows for the wrapped converter to take additional arguments. The 
    arguments are passed in the order they are documented. 
 
    Args: 
        converter (Callable): A callable that converts the passed value. 
 
        takes_self (bool): 
            Pass the partially initialized instance that is being initialized 
            as a positional argument. (default: `False`) 
 
        takes_field (bool): 
            Pass the field definition (an :class:`Attribute`) into the 
            converter as a positional argument. (default: `False`) 
 
    .. versionadded:: 24.1.0 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;__call__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_first_param_type&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_global_name&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;converter&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;takes_field&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;takes_self&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">, *, </span><span class="s1">takes_self</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">takes_field</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">converter </span><span class="s3">= </span><span class="s1">converter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s3">= </span><span class="s1">takes_self</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field </span><span class="s3">= </span><span class="s1">takes_field</span>

        <span class="s1">ex </span><span class="s3">= </span><span class="s1">_AnnotationExtractor</span><span class="s3">(</span><span class="s1">converter</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_first_param_type </span><span class="s3">= </span><span class="s1">ex</span><span class="s3">.</span><span class="s1">get_first_param_type</span><span class="s3">()</span>

        <span class="s2">if not </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__call__ </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">value</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">__</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__call__ </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">value</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">, </span><span class="s1">__</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">(</span>
                <span class="s1">value</span><span class="s3">, </span><span class="s1">instance</span>
            <span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__call__ </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">value</span><span class="s3">, </span><span class="s1">__</span><span class="s3">, </span><span class="s1">field</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">(</span>
                <span class="s1">value</span><span class="s3">, </span><span class="s1">field</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__call__ </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">value</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">, </span><span class="s1">field</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">(</span>
                <span class="s1">value</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">, </span><span class="s1">field</span>
            <span class="s3">)</span>

        <span class="s1">rt </span><span class="s3">= </span><span class="s1">ex</span><span class="s3">.</span><span class="s1">get_return_type</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">rt </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">[</span><span class="s4">&quot;return&quot;</span><span class="s3">] = </span><span class="s1">rt</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the name that a converter for an attribute name *attr_name* 
        would have. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">f&quot;__attr_converter_</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">_fmt_converter_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value_var</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a string that calls the converter for an attribute name 
        *attr_name* and the value in variable named *value_var* according to 
        `self.takes_self` and `self.takes_field`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">)&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">, self, attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'])&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">, self)&quot;</span>

        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_global_name</span><span class="s3">(</span><span class="s1">attr_name</span><span class="s3">)</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s4">, attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">'])&quot;</span>

    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a dict containing only converter and takes_self -- the rest gets 
        computed when loading. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">{</span>
            <span class="s4">&quot;converter&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">converter</span><span class="s3">,</span>
            <span class="s4">&quot;takes_self&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_self</span><span class="s3">,</span>
            <span class="s4">&quot;takes_field&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takes_field</span><span class="s3">,</span>
        <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Load instance from state. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(**</span><span class="s1">state</span><span class="s3">)</span>


<span class="s1">_f </span><span class="s3">= [</span>
    <span class="s1">Attribute</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s1">NOTHING</span><span class="s3">,</span>
        <span class="s1">validator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">repr</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">cmp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">eq</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">hash</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">init</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inherited</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;converter&quot;</span><span class="s3">, </span><span class="s4">&quot;takes_self&quot;</span><span class="s3">, </span><span class="s4">&quot;takes_field&quot;</span><span class="s3">)</span>
<span class="s3">]</span>

<span class="s1">Converter </span><span class="s3">= </span><span class="s1">_add_hash</span><span class="s3">(</span>
    <span class="s1">_add_eq</span><span class="s3">(</span><span class="s1">_add_repr</span><span class="s3">(</span><span class="s1">Converter</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span><span class="s3">), </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span><span class="s3">), </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_f</span>
<span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_class</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">bases</span><span class="s3">=(</span><span class="s1">object</span><span class="s3">,), </span><span class="s1">class_body</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, **</span><span class="s1">attributes_arguments</span>
<span class="s3">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    A quick way to create a new class called *name* with *attrs*. 
 
    .. note:: 
 
        ``make_class()`` is a thin wrapper around `attr.s`, not `attrs.define` 
        which means that it doesn't come with some of the improved defaults. 
 
        For example, if you want the same ``on_setattr`` behavior as in 
        `attrs.define`, you have to pass the hooks yourself: ``make_class(..., 
        on_setattr=setters.pipe(setters.convert, setters.validate)`` 
 
    .. warning:: 
 
        It is *your* duty to ensure that the class name and the attribute names 
        are valid identifiers. ``make_class()`` will *not* validate them for 
        you. 
 
    Args: 
        name (str): The name for the new class. 
 
        attrs (list | dict): 
            A list of names or a dictionary of mappings of names to `attr.ib`\ 
            s / `attrs.field`\ s. 
 
            The order is deduced from the order of the names or attributes 
            inside *attrs*.  Otherwise the order of the definition of the 
            attributes is used. 
 
        bases (tuple[type, ...]): Classes that the new class will subclass. 
 
        class_body (dict): 
            An optional dictionary of class attributes for the new class. 
 
        attributes_arguments: Passed unmodified to `attr.s`. 
 
    Returns: 
        type: A new class with *attrs*. 
 
    .. versionadded:: 17.1.0 *bases* 
    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained. 
    .. versionchanged:: 23.2.0 *class_body* 
    .. versionchanged:: 25.2.0 Class names can now be unicode. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Class identifiers are converted into the normal form NFKC while parsing</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">unicodedata</span><span class="s3">.</span><span class="s1">normalize</span><span class="s3">(</span><span class="s4">&quot;NFKC&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s1">cls_dict </span><span class="s3">= </span><span class="s1">attrs</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">cls_dict </span><span class="s3">= {</span><span class="s1">a</span><span class="s3">: </span><span class="s1">attrib</span><span class="s3">() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">}</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;attrs argument must be a dict or a list.&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">pre_init </span><span class="s3">= </span><span class="s1">cls_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;__attrs_pre_init__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">post_init </span><span class="s3">= </span><span class="s1">cls_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;__attrs_post_init__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">user_init </span><span class="s3">= </span><span class="s1">cls_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;__init__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">body </span><span class="s3">= {}</span>
    <span class="s2">if </span><span class="s1">class_body </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">body</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">class_body</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">pre_init </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">body</span><span class="s3">[</span><span class="s4">&quot;__attrs_pre_init__&quot;</span><span class="s3">] = </span><span class="s1">pre_init</span>
    <span class="s2">if </span><span class="s1">post_init </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">body</span><span class="s3">[</span><span class="s4">&quot;__attrs_post_init__&quot;</span><span class="s3">] = </span><span class="s1">post_init</span>
    <span class="s2">if </span><span class="s1">user_init </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">body</span><span class="s3">[</span><span class="s4">&quot;__init__&quot;</span><span class="s3">] = </span><span class="s1">user_init</span>

    <span class="s1">type_ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">new_class</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">bases</span><span class="s3">, {}, </span><span class="s2">lambda </span><span class="s1">ns</span><span class="s3">: </span><span class="s1">ns</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">body</span><span class="s3">))</span>

    <span class="s0"># For pickling to work, the __module__ variable needs to be set to the</span>
    <span class="s0"># frame where the class is created.  Bypass this step in environments where</span>
    <span class="s0"># sys._getframe is not defined (Jython for example) or sys._getframe is not</span>
    <span class="s0"># defined for arguments greater than 0 (IronPython).</span>
    <span class="s2">with </span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">suppress</span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">type_</span><span class="s3">.</span><span class="s1">__module__ </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">_getframe</span><span class="s3">(</span><span class="s6">1</span><span class="s3">).</span><span class="s1">f_globals</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
            <span class="s4">&quot;__name__&quot;</span><span class="s3">, </span><span class="s4">&quot;__main__&quot;</span>
        <span class="s3">)</span>

    <span class="s0"># We do it here for proper warnings with meaningful stacklevel.</span>
    <span class="s1">cmp </span><span class="s3">= </span><span class="s1">attributes_arguments</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;cmp&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s3">(</span>
        <span class="s1">attributes_arguments</span><span class="s3">[</span><span class="s4">&quot;eq&quot;</span><span class="s3">],</span>
        <span class="s1">attributes_arguments</span><span class="s3">[</span><span class="s4">&quot;order&quot;</span><span class="s3">],</span>
    <span class="s3">) = </span><span class="s1">_determine_attrs_eq_order</span><span class="s3">(</span>
        <span class="s1">cmp</span><span class="s3">,</span>
        <span class="s1">attributes_arguments</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;eq&quot;</span><span class="s3">),</span>
        <span class="s1">attributes_arguments</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;order&quot;</span><span class="s3">),</span>
        <span class="s2">True</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">cls </span><span class="s3">= </span><span class="s1">_attrs</span><span class="s3">(</span><span class="s1">these</span><span class="s3">=</span><span class="s1">cls_dict</span><span class="s3">, **</span><span class="s1">attributes_arguments</span><span class="s3">)(</span><span class="s1">type_</span><span class="s3">)</span>
    <span class="s0"># Only add type annotations now or &quot;_attrs()&quot; will complain:</span>
    <span class="s1">cls</span><span class="s3">.</span><span class="s1">__annotations__ </span><span class="s3">= {</span>
        <span class="s1">k</span><span class="s3">: </span><span class="s1">v</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">cls_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s0"># These are required by within this module so we define them here and merely</span>
<span class="s0"># import into .validators / .converters.</span>


<span class="s3">@</span><span class="s1">attrs</span><span class="s3">(</span><span class="s1">slots</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">unsafe_hash</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">_AndValidator</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compose many validators to a single one. 
    &quot;&quot;&quot;</span>

    <span class="s1">_validators </span><span class="s3">= </span><span class="s1">attrib</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validators</span><span class="s3">:</span>
            <span class="s1">v</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">and_</span><span class="s3">(*</span><span class="s1">validators</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    A validator that composes multiple validators into one. 
 
    When called on a value, it runs all wrapped validators. 
 
    Args: 
        validators (~collections.abc.Iterable[typing.Callable]): 
            Arbitrary number of validators. 
 
    .. versionadded:: 17.1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">vals </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">validator </span><span class="s2">in </span><span class="s1">validators</span><span class="s3">:</span>
        <span class="s1">vals</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
            <span class="s1">validator</span><span class="s3">.</span><span class="s1">_validators</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">validator</span><span class="s3">, </span><span class="s1">_AndValidator</span><span class="s3">)</span>
            <span class="s2">else </span><span class="s3">[</span><span class="s1">validator</span><span class="s3">]</span>
        <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_AndValidator</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">pipe</span><span class="s3">(*</span><span class="s1">converters</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    A converter that composes multiple converters into one. 
 
    When called on a value, it runs all wrapped converters, returning the 
    *last* value. 
 
    Type annotations will be inferred from the wrapped converters', if they 
    have any. 
 
        converters (~collections.abc.Iterable[typing.Callable]): 
            Arbitrary number of converters. 
 
    .. versionadded:: 20.1.0 
    &quot;&quot;&quot;</span>

    <span class="s1">return_instance </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">Converter</span><span class="s3">) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">converters</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">return_instance</span><span class="s3">:</span>

        <span class="s2">def </span><span class="s1">pipe_converter</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">field</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">converters</span><span class="s3">:</span>
                <span class="s1">val </span><span class="s3">= (</span>
                    <span class="s1">c</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">field</span><span class="s3">) </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">Converter</span><span class="s3">) </span><span class="s2">else </span><span class="s1">c</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
                <span class="s3">)</span>

            <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">else</span><span class="s3">:</span>

        <span class="s2">def </span><span class="s1">pipe_converter</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">converters</span><span class="s3">:</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">c</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">if not </span><span class="s1">converters</span><span class="s3">:</span>
        <span class="s0"># If the converter list is empty, pipe_converter is the identity.</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;A&quot;</span><span class="s3">)</span>
        <span class="s1">pipe_converter</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span><span class="s4">&quot;val&quot;</span><span class="s3">: </span><span class="s1">A</span><span class="s3">, </span><span class="s4">&quot;return&quot;</span><span class="s3">: </span><span class="s1">A</span><span class="s3">})</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># Get parameter type from first converter.</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">_AnnotationExtractor</span><span class="s3">(</span><span class="s1">converters</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]).</span><span class="s1">get_first_param_type</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">t</span><span class="s3">:</span>
            <span class="s1">pipe_converter</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">[</span><span class="s4">&quot;val&quot;</span><span class="s3">] = </span><span class="s1">t</span>

        <span class="s1">last </span><span class="s3">= </span><span class="s1">converters</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">PY_3_11_PLUS </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">last</span><span class="s3">, </span><span class="s1">Converter</span><span class="s3">):</span>
            <span class="s1">last </span><span class="s3">= </span><span class="s1">last</span><span class="s3">.</span><span class="s1">__call__</span>

        <span class="s0"># Get return type from last converter.</span>
        <span class="s1">rt </span><span class="s3">= </span><span class="s1">_AnnotationExtractor</span><span class="s3">(</span><span class="s1">last</span><span class="s3">).</span><span class="s1">get_return_type</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">rt</span><span class="s3">:</span>
            <span class="s1">pipe_converter</span><span class="s3">.</span><span class="s1">__annotations__</span><span class="s3">[</span><span class="s4">&quot;return&quot;</span><span class="s3">] = </span><span class="s1">rt</span>

    <span class="s2">if </span><span class="s1">return_instance</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">Converter</span><span class="s3">(</span><span class="s1">pipe_converter</span><span class="s3">, </span><span class="s1">takes_self</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">takes_field</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pipe_converter</span>
</pre>
</body>
</html>