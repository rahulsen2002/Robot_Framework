<html>
<head>
<title>_decorators.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_decorators.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">ast</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">isclass</span><span class="s2">, </span><span class="s1">isfunction</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">CodeType</span><span class="s2">, </span><span class="s1">FrameType</span><span class="s2">, </span><span class="s1">FunctionType</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">cast</span><span class="s2">, </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">warnings </span><span class="s0">import </span><span class="s1">warn</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_config </span><span class="s0">import </span><span class="s1">CollectionCheckStrategy</span><span class="s2">, </span><span class="s1">ForwardRefPolicy</span><span class="s2">, </span><span class="s1">global_config</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">InstrumentationWarning</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_functions </span><span class="s0">import </span><span class="s1">TypeCheckFailCallback</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_transformer </span><span class="s0">import </span><span class="s1">TypeguardTransformer</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_utils </span><span class="s0">import </span><span class="s1">Unset</span><span class="s2">, </span><span class="s1">function_name</span><span class="s2">, </span><span class="s1">get_stacklevel</span><span class="s2">, </span><span class="s1">is_method_of</span><span class="s2">, </span><span class="s1">unset</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typeshed</span><span class="s2">.</span><span class="s1">stdlib</span><span class="s2">.</span><span class="s1">types </span><span class="s0">import </span><span class="s1">_Cell</span>

    <span class="s1">_F </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;_F&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">typeguard_ignore</span><span class="s2">(</span><span class="s1">f</span><span class="s2">: </span><span class="s1">_F</span><span class="s2">) </span><span class="s1">-&gt; _F</span><span class="s2">:</span>
        <span class="s4">&quot;&quot;&quot;This decorator is a noop during static type-checking.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">f</span>

<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">no_type_check </span><span class="s0">as </span><span class="s1">typeguard_ignore  </span><span class="s5"># noqa: F401</span>

<span class="s1">T_CallableOrType </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;T_CallableOrType&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">Any</span><span class="s2">])</span>


<span class="s0">def </span><span class="s1">make_cell</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">object</span><span class="s2">) </span><span class="s1">-&gt; _Cell</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">value</span><span class="s2">).</span><span class="s1">__closure__</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]  </span><span class="s5"># type: ignore[index]</span>


<span class="s0">def </span><span class="s1">find_target_function</span><span class="s2">(</span>
    <span class="s1">new_code</span><span class="s2">: </span><span class="s1">CodeType</span><span class="s2">, </span><span class="s1">target_path</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">firstlineno</span><span class="s2">: </span><span class="s1">int</span>
<span class="s2">) </span><span class="s1">-&gt; CodeType </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s1">target_name </span><span class="s2">= </span><span class="s1">target_path</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s0">for </span><span class="s1">const </span><span class="s0">in </span><span class="s1">new_code</span><span class="s2">.</span><span class="s1">co_consts</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">const</span><span class="s2">, </span><span class="s1">CodeType</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">const</span><span class="s2">.</span><span class="s1">co_name </span><span class="s2">== </span><span class="s1">target_name</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">const</span><span class="s2">.</span><span class="s1">co_firstlineno </span><span class="s2">== </span><span class="s1">firstlineno</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">const</span>
                <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">target_path</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s1">target_code </span><span class="s2">= </span><span class="s1">find_target_function</span><span class="s2">(</span>
                        <span class="s1">const</span><span class="s2">, </span><span class="s1">target_path</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:], </span><span class="s1">firstlineno</span>
                    <span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">target_code</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">target_code</span>

    <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">instrument</span><span class="s2">(</span><span class="s1">f</span><span class="s2">: </span><span class="s1">T_CallableOrType</span><span class="s2">) </span><span class="s1">-&gt; FunctionType </span><span class="s2">| </span><span class="s1">str</span><span class="s2">:</span>
    <span class="s0">if not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s3">&quot;__code__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s3">&quot;no code associated&quot;</span>
    <span class="s0">elif not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s3">&quot;__module__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s3">&quot;__module__ attribute is not set&quot;</span>
    <span class="s0">elif </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_filename </span><span class="s2">== </span><span class="s3">&quot;&lt;stdin&gt;&quot;</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">&quot;cannot instrument functions defined in a REPL&quot;</span>
    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s3">&quot;__wrapped__&quot;</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s3">&quot;@typechecked only supports instrumenting functions wrapped with &quot;</span>
            <span class="s3">&quot;@classmethod, @staticmethod or @property&quot;</span>
        <span class="s2">)</span>

    <span class="s1">target_path </span><span class="s2">= [</span><span class="s1">item </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;.&quot;</span><span class="s2">) </span><span class="s0">if </span><span class="s1">item </span><span class="s2">!= </span><span class="s3">&quot;&lt;locals&gt;&quot;</span><span class="s2">]</span>
    <span class="s1">module_source </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getsource</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">])</span>
    <span class="s1">module_ast </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">.</span><span class="s1">parse</span><span class="s2">(</span><span class="s1">module_source</span><span class="s2">)</span>
    <span class="s1">instrumentor </span><span class="s2">= </span><span class="s1">TypeguardTransformer</span><span class="s2">(</span><span class="s1">target_path</span><span class="s2">, </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_firstlineno</span><span class="s2">)</span>
    <span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">visit</span><span class="s2">(</span><span class="s1">module_ast</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">target_node </span><span class="s0">or </span><span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">target_lineno </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">&quot;instrumentor did not find the target function&quot;</span>

    <span class="s1">module_code </span><span class="s2">= </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">module_ast</span><span class="s2">, </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_filename</span><span class="s2">, </span><span class="s3">&quot;exec&quot;</span><span class="s2">, </span><span class="s1">dont_inherit</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">new_code </span><span class="s2">= </span><span class="s1">find_target_function</span><span class="s2">(</span>
        <span class="s1">module_code</span><span class="s2">, </span><span class="s1">target_path</span><span class="s2">, </span><span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">target_lineno</span>
    <span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">new_code</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">&quot;cannot find the target function in the AST&quot;</span>

    <span class="s0">if </span><span class="s1">global_config</span><span class="s2">.</span><span class="s1">debug_instrumentation </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s6">3</span><span class="s2">, </span><span class="s6">9</span><span class="s2">):</span>
        <span class="s5"># Find the matching AST node, then unparse it to source and print to stdout</span>
        <span class="s1">print</span><span class="s2">(</span>
            <span class="s3">f&quot;Source code of </span><span class="s0">{</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">}</span><span class="s3">() after instrumentation:&quot;</span>
            <span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">----------------------------------------------&quot;</span><span class="s2">,</span>
            <span class="s1">file</span><span class="s2">=</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">.</span><span class="s1">unparse</span><span class="s2">(</span><span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">target_node</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span>
            <span class="s3">&quot;----------------------------------------------&quot;</span><span class="s2">,</span>
            <span class="s1">file</span><span class="s2">=</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s1">closure </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__closure__</span>
    <span class="s0">if </span><span class="s1">new_code</span><span class="s2">.</span><span class="s1">co_freevars </span><span class="s2">!= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_freevars</span><span class="s2">:</span>
        <span class="s5"># Create a new closure and find values for the new free variables</span>
        <span class="s1">frame </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">FrameType</span><span class="s2">, </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">currentframe</span><span class="s2">())</span>
        <span class="s1">frame </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">FrameType</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">.</span><span class="s1">f_back</span><span class="s2">)</span>
        <span class="s1">frame_locals </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">FrameType</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">.</span><span class="s1">f_back</span><span class="s2">).</span><span class="s1">f_locals</span>
        <span class="s1">cells</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">_Cell</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">new_code</span><span class="s2">.</span><span class="s1">co_freevars</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">instrumentor</span><span class="s2">.</span><span class="s1">names_used_in_annotations</span><span class="s2">:</span>
                <span class="s5"># Find the value and make a new cell from it</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">frame_locals</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">or </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
                <span class="s1">cells</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">make_cell</span><span class="s2">(</span><span class="s1">value</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s5"># Reuse the cell from the existing closure</span>
                <span class="s0">assert </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__closure__</span>
                <span class="s1">cells</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__closure__</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_freevars</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)])</span>

        <span class="s1">closure </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">cells</span><span class="s2">)</span>

    <span class="s1">new_function </span><span class="s2">= </span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">new_code</span><span class="s2">, </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__globals__</span><span class="s2">, </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">closure</span><span class="s2">=</span><span class="s1">closure</span><span class="s2">)</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__module__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__name__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__qualname__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__annotations__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__annotations__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__doc__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__defaults__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__defaults__</span>
    <span class="s1">new_function</span><span class="s2">.</span><span class="s1">__kwdefaults__ </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__kwdefaults__</span>
    <span class="s0">return </span><span class="s1">new_function</span>


<span class="s2">@</span><span class="s1">overload</span>
<span class="s0">def </span><span class="s1">typechecked</span><span class="s2">(</span>
    <span class="s2">*,</span>
    <span class="s1">forward_ref_policy</span><span class="s2">: </span><span class="s1">ForwardRefPolicy </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">typecheck_fail_callback</span><span class="s2">: </span><span class="s1">TypeCheckFailCallback </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">collection_check_strategy</span><span class="s2">: </span><span class="s1">CollectionCheckStrategy </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">debug_instrumentation</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s1">T_CallableOrType</span><span class="s2">], </span><span class="s1">T_CallableOrType</span><span class="s2">]: ...</span>


<span class="s2">@</span><span class="s1">overload</span>
<span class="s0">def </span><span class="s1">typechecked</span><span class="s2">(</span><span class="s1">target</span><span class="s2">: </span><span class="s1">T_CallableOrType</span><span class="s2">) </span><span class="s1">-&gt; T_CallableOrType</span><span class="s2">: ...</span>


<span class="s0">def </span><span class="s1">typechecked</span><span class="s2">(</span>
    <span class="s1">target</span><span class="s2">: </span><span class="s1">T_CallableOrType </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">forward_ref_policy</span><span class="s2">: </span><span class="s1">ForwardRefPolicy </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">typecheck_fail_callback</span><span class="s2">: </span><span class="s1">TypeCheckFailCallback </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">collection_check_strategy</span><span class="s2">: </span><span class="s1">CollectionCheckStrategy </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
    <span class="s1">debug_instrumentation</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">Unset </span><span class="s2">= </span><span class="s1">unset</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Instrument the target function to perform run-time type checking. 
 
    This decorator recompiles the target function, injecting code to type check 
    arguments, return values, yield values (excluding ``yield from``) and assignments to 
    annotated local variables. 
 
    This can also be used as a class decorator. This will instrument all type annotated 
    methods, including :func:`@classmethod &lt;classmethod&gt;`, 
    :func:`@staticmethod &lt;staticmethod&gt;`,  and :class:`@property &lt;property&gt;` decorated 
    methods in the class. 
 
    .. note:: When Python is run in optimized mode (``-O`` or ``-OO``, this decorator 
        is a no-op). This is a feature meant for selectively introducing type checking 
        into a code base where the checks aren't meant to be run in production. 
 
    :param target: the function or class to enable type checking for 
    :param forward_ref_policy: override for 
        :attr:`.TypeCheckConfiguration.forward_ref_policy` 
    :param typecheck_fail_callback: override for 
        :attr:`.TypeCheckConfiguration.typecheck_fail_callback` 
    :param collection_check_strategy: override for 
        :attr:`.TypeCheckConfiguration.collection_check_strategy` 
    :param debug_instrumentation: override for 
        :attr:`.TypeCheckConfiguration.debug_instrumentation` 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">target </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">partial</span><span class="s2">(</span>
            <span class="s1">typechecked</span><span class="s2">,</span>
            <span class="s1">forward_ref_policy</span><span class="s2">=</span><span class="s1">forward_ref_policy</span><span class="s2">,</span>
            <span class="s1">typecheck_fail_callback</span><span class="s2">=</span><span class="s1">typecheck_fail_callback</span><span class="s2">,</span>
            <span class="s1">collection_check_strategy</span><span class="s2">=</span><span class="s1">collection_check_strategy</span><span class="s2">,</span>
            <span class="s1">debug_instrumentation</span><span class="s2">=</span><span class="s1">debug_instrumentation</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">if not __debug__</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">target</span>

    <span class="s0">if </span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">target</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">target</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">is_method_of</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">target</span><span class="s2">):</span>
                <span class="s1">retval </span><span class="s2">= </span><span class="s1">instrument</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isfunction</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">):</span>
                    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">retval</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, (</span><span class="s1">classmethod</span><span class="s2">, </span><span class="s1">staticmethod</span><span class="s2">)):</span>
                <span class="s0">if </span><span class="s1">is_method_of</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">__func__</span><span class="s2">, </span><span class="s1">target</span><span class="s2">):</span>
                    <span class="s1">retval </span><span class="s2">= </span><span class="s1">instrument</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">__func__</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">isfunction</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">):</span>
                        <span class="s1">wrapper </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">)</span>
                        <span class="s1">setattr</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">wrapper</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">property</span><span class="s2">):</span>
                <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">=</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">__doc__</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s2">(</span><span class="s3">&quot;fset&quot;</span><span class="s2">, </span><span class="s3">&quot;fget&quot;</span><span class="s2">, </span><span class="s3">&quot;fdel&quot;</span><span class="s2">):</span>
                    <span class="s1">property_func </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">is_method_of</span><span class="s2">(</span><span class="s1">property_func</span><span class="s2">, </span><span class="s1">target</span><span class="s2">):</span>
                        <span class="s1">retval </span><span class="s2">= </span><span class="s1">instrument</span><span class="s2">(</span><span class="s1">property_func</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">isfunction</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">):</span>
                            <span class="s1">kwargs</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">retval</span>

                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">target</span>

    <span class="s5"># Find either the first Python wrapper or the actual function</span>
    <span class="s1">wrapper_class</span><span class="s2">: (</span>
        <span class="s1">type</span><span class="s2">[</span><span class="s1">classmethod</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]] | </span><span class="s1">type</span><span class="s2">[</span><span class="s1">staticmethod</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]] | </span><span class="s0">None</span>
    <span class="s2">) = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, (</span><span class="s1">classmethod</span><span class="s2">, </span><span class="s1">staticmethod</span><span class="s2">)):</span>
        <span class="s1">wrapper_class </span><span class="s2">= </span><span class="s1">target</span><span class="s2">.</span><span class="s1">__class__</span>
        <span class="s1">target </span><span class="s2">= </span><span class="s1">target</span><span class="s2">.</span><span class="s1">__func__</span>

    <span class="s1">retval </span><span class="s2">= </span><span class="s1">instrument</span><span class="s2">(</span><span class="s1">target</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">retval</span><span class="s0">} </span><span class="s3">-- not typechecking </span><span class="s0">{</span><span class="s1">function_name</span><span class="s2">(</span><span class="s1">target</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s1">InstrumentationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">get_stacklevel</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">target</span>

    <span class="s0">if </span><span class="s1">wrapper_class </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">retval</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">wrapper_class</span><span class="s2">(</span><span class="s1">retval</span><span class="s2">)</span>
</pre>
</body>
</html>