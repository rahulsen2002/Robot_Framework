<html>
<head>
<title>typeinfo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typeinfo.py</font>
</center></td></tr></table>
<pre><span class="s0">#  Copyright 2008-2015 Nokia Networks</span>
<span class="s0">#  Copyright 2016-     Robot Framework Foundation</span>
<span class="s0">#</span>
<span class="s0">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0">#  you may not use this file except in compliance with the License.</span>
<span class="s0">#  You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="s0">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0">#  See the License for the specific language governing permissions and</span>
<span class="s0">#  limitations under the License.</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Set</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">date</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">, </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">ForwardRef</span><span class="s3">, </span><span class="s1">get_args</span><span class="s3">, </span><span class="s1">get_origin</span><span class="s3">, </span><span class="s1">get_type_hints</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">9</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s0"># get_args and get_origin handle at least Annotated wrong in Python 3.8.</span>
        <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">get_args</span><span class="s3">, </span><span class="s1">get_origin</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">pass</span>
<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NotRequired</span><span class="s3">, </span><span class="s1">Required</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">NotRequired</span><span class="s3">, </span><span class="s1">Required</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s1">NotRequired </span><span class="s3">= </span><span class="s1">Required </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>

<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">conf </span><span class="s2">import </span><span class="s1">Languages</span><span class="s3">, </span><span class="s1">LanguagesLike</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">DataError</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">is_union</span><span class="s3">, </span><span class="s1">NOT_SET</span><span class="s3">, </span><span class="s1">plural_or_not </span><span class="s2">as </span><span class="s1">s</span><span class="s3">, </span><span class="s1">setter</span><span class="s3">, </span><span class="s1">SetterAwareType</span><span class="s3">, </span><span class="s1">type_name</span><span class="s3">,</span>
    <span class="s1">type_repr</span><span class="s3">, </span><span class="s1">typeddict_types</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">robot</span><span class="s3">.</span><span class="s1">variables </span><span class="s2">import </span><span class="s1">search_variable</span><span class="s3">, </span><span class="s1">VariableMatch</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">context </span><span class="s2">import </span><span class="s1">EXECUTION_CONTEXTS</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">customconverters </span><span class="s2">import </span><span class="s1">CustomArgumentConverters</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">typeconverters </span><span class="s2">import </span><span class="s1">TypeConverter</span>

<span class="s1">TYPE_NAMES </span><span class="s3">= {</span>
    <span class="s5">&quot;...&quot;</span><span class="s3">: </span><span class="s1">Ellipsis</span><span class="s3">,</span>
    <span class="s5">&quot;ellipsis&quot;</span><span class="s3">: </span><span class="s1">Ellipsis</span><span class="s3">,</span>
    <span class="s5">&quot;any&quot;</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s5">&quot;str&quot;</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s5">&quot;string&quot;</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s5">&quot;unicode&quot;</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s5">&quot;bool&quot;</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s5">&quot;boolean&quot;</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s5">&quot;int&quot;</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
    <span class="s5">&quot;integer&quot;</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
    <span class="s5">&quot;long&quot;</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
    <span class="s5">&quot;float&quot;</span><span class="s3">: </span><span class="s1">float</span><span class="s3">,</span>
    <span class="s5">&quot;double&quot;</span><span class="s3">: </span><span class="s1">float</span><span class="s3">,</span>
    <span class="s5">&quot;decimal&quot;</span><span class="s3">: </span><span class="s1">Decimal</span><span class="s3">,</span>
    <span class="s5">&quot;bytes&quot;</span><span class="s3">: </span><span class="s1">bytes</span><span class="s3">,</span>
    <span class="s5">&quot;bytearray&quot;</span><span class="s3">: </span><span class="s1">bytearray</span><span class="s3">,</span>
    <span class="s5">&quot;datetime&quot;</span><span class="s3">: </span><span class="s1">datetime</span><span class="s3">,</span>
    <span class="s5">&quot;date&quot;</span><span class="s3">: </span><span class="s1">date</span><span class="s3">,</span>
    <span class="s5">&quot;timedelta&quot;</span><span class="s3">: </span><span class="s1">timedelta</span><span class="s3">,</span>
    <span class="s5">&quot;path&quot;</span><span class="s3">: </span><span class="s1">Path</span><span class="s3">,</span>
    <span class="s5">&quot;none&quot;</span><span class="s3">: </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">),</span>
    <span class="s5">&quot;list&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">,</span>
    <span class="s5">&quot;sequence&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">,</span>
    <span class="s5">&quot;tuple&quot;</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">,</span>
    <span class="s5">&quot;dictionary&quot;</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s5">&quot;dict&quot;</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s5">&quot;mapping&quot;</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s5">&quot;map&quot;</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s5">&quot;set&quot;</span><span class="s3">: </span><span class="s1">set</span><span class="s3">,</span>
    <span class="s5">&quot;frozenset&quot;</span><span class="s3">: </span><span class="s1">frozenset</span><span class="s3">,</span>
    <span class="s5">&quot;union&quot;</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">,</span>
    <span class="s5">&quot;literal&quot;</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">,</span>
<span class="s3">}</span>
<span class="s1">LITERAL_TYPES </span><span class="s3">= (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">TypeInfo</span><span class="s3">(</span><span class="s1">metaclass</span><span class="s3">=</span><span class="s1">SetterAwareType</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Represents an argument type. 
 
    Normally created using the :meth:`from_type_hint` classmethod. 
    With unions and parametrized types, :attr:`nested` contains nested types. 
 
    Values can be converted according to this type info by using the 
    :meth:`convert` method. 
 
    Part of the public API starting from Robot Framework 7.0. In such usage 
    should be imported via the :mod:`robot.api` package. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_typed_dict </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s5">&quot;name&quot;</span><span class="s3">, </span><span class="s5">&quot;type&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s5">&quot;str|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">: </span><span class="s1">Any </span><span class="s3">= </span><span class="s1">NOT_SET</span><span class="s3">,</span>
        <span class="s1">nested</span><span class="s3">: </span><span class="s5">&quot;Sequence[TypeInfo]|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s2">is </span><span class="s1">NOT_SET</span><span class="s3">:</span>
            <span class="s1">type </span><span class="s3">= </span><span class="s1">TYPE_NAMES</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()) </span><span class="s2">if </span><span class="s1">name </span><span class="s2">else None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">type</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nested </span><span class="s3">= </span><span class="s1">nested</span>

    <span class="s3">@</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">nested</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">: </span><span class="s5">&quot;Sequence[TypeInfo]&quot;</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;tuple[TypeInfo, ...]|None&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Nested types as a tuple of ``TypeInfo`` objects. 
 
        Used with parameterized types and unions. 
        &quot;&quot;&quot;</span>
        <span class="s1">typ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_union</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_union</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">nested </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">typ </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typ </span><span class="s2">is </span><span class="s1">Literal</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_literal</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">nested</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">].</span><span class="s1">type </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_nested_count</span><span class="s3">(</span>
                        <span class="s1">nested</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">&quot;Homogenous tuple&quot;</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=-</span><span class="s4">1</span>
                    <span class="s3">)</span>
                <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">)</span>
                <span class="s2">and not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, (</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">bytearray</span><span class="s3">, </span><span class="s1">memoryview</span><span class="s3">))</span>
            <span class="s3">):  </span><span class="s0"># fmt: skip</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_nested_count</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">Set</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_nested_count</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_nested_count</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">TYPE_NAMES</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_report_nested_error</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_validate_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">nested</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span><span class="s5">&quot;Union cannot be empty.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_validate_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">nested</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span><span class="s5">&quot;Literal cannot be empty.&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">info </span><span class="s2">in </span><span class="s1">nested</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">LITERAL_TYPES</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span>
                    <span class="s5">f&quot;Literal supports only integers, strings, bytes, Booleans, enums &quot;</span>
                    <span class="s5">f&quot;and None, value </span><span class="s2">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s2">} </span><span class="s5">is </span><span class="s2">{</span><span class="s1">type_name</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span><span class="s2">}</span><span class="s5">.&quot;</span>
                <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_validate_nested_count</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">) != </span><span class="s1">expected</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_report_nested_error</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_report_nested_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
        <span class="s1">expected </span><span class="s3">+= </span><span class="s1">offset</span>
        <span class="s1">actual </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">) + </span><span class="s1">offset</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s1">kind </span><span class="s3">= </span><span class="s1">kind </span><span class="s2">or </span><span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}{</span><span class="s5">'[]' </span><span class="s2">if </span><span class="s1">expected </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s5">''</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s2">if </span><span class="s1">expected </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span>
                <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">} </span><span class="s5">does not accept parameters, &quot;</span>
                <span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">args</span><span class="s2">}</span><span class="s5">]' has </span><span class="s2">{</span><span class="s1">actual</span><span class="s2">}</span><span class="s5">.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span>
            <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">kind</span><span class="s2">} </span><span class="s5">requires exactly </span><span class="s2">{</span><span class="s1">expected</span><span class="s2">} </span><span class="s5">parameter</span><span class="s2">{</span><span class="s1">s</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">)</span><span class="s2">}</span><span class="s5">, &quot;</span>
            <span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">args</span><span class="s2">}</span><span class="s5">]' has </span><span class="s2">{</span><span class="s1">actual</span><span class="s2">}</span><span class="s5">.&quot;</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">is_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">&quot;Union&quot;</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_type_hint</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;TypeInfo&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Construct a ``TypeInfo`` based on a type hint. 
 
        The type hint can be in various different formats: 
 
        - an actual type such as ``int`` 
        - a parameterized type such as ``list[int]`` 
        - a union such as ``int | float`` 
        - a string such as ``'int'``, ``'list[int]'`` or ``'int | float'`` 
        - a ``TypedDict`` (represented as a :class:`TypedDictInfo`) 
        - a sequence of supported type hints to create a union from such as 
          ``[int, float]`` or ``('int', 'list[int]')`` 
 
        In special cases using a more specialized method like :meth:`from_sequence` 
        may be more appropriate than using this generic method. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hint </span><span class="s2">is </span><span class="s1">NOT_SET</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">hint</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">ForwardRef</span><span class="s3">):</span>
            <span class="s1">hint </span><span class="s3">= </span><span class="s1">hint</span><span class="s3">.</span><span class="s1">__forward_arg__</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">typeddict_types</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">TypedDictInfo</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">is_union</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">):</span>
            <span class="s1">nested </span><span class="s3">= [</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_type_hint</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)]</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;Union&quot;</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">=</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">origin</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">Literal</span><span class="s3">:</span>
                <span class="s1">nested </span><span class="s3">= [</span>
                    <span class="s1">cls</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">Enum</span><span class="s3">) </span><span class="s2">else </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)</span>
                <span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">):</span>
                <span class="s1">nested </span><span class="s3">= [</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_type_hint</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">nested </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">type_repr</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_string</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_sequence</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">type_repr</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">), </span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hint </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;None&quot;</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">hint </span><span class="s2">is </span><span class="s1">Union</span><span class="s3">:  </span><span class="s0"># Plain `Union` without params.</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;Union&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hint </span><span class="s2">is </span><span class="s1">Any</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;Any&quot;</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hint </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;...&quot;</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_type</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">: </span><span class="s1">type</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;TypeInfo&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Construct a ``TypeInfo`` based on an actual type. 
 
        Use :meth:`from_type_hint` if the type hint can also be something else 
        than a concrete type such as a string. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">type_repr</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">), </span><span class="s1">hint</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_string</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">hint</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;TypeInfo&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Construct a ``TypeInfo`` based on a string. 
 
        In addition to just types names or their aliases like ``int`` or ``integer``, 
        supports also parameterized types like ``list[int]`` as well as unions like 
        ``int | float``. 
 
        Use :meth:`from_type_hint` if the type hint can also be something else 
        than a string such as an actual type. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Needs to be imported here due to cyclic dependency.</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">typeinfoparser </span><span class="s2">import </span><span class="s1">TypeInfoParser</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">TypeInfoParser</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">).</span><span class="s1">parse</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">err</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_sequence</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">sequence</span><span class="s3">: </span><span class="s5">&quot;tuple|list&quot;</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;TypeInfo&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Construct a ``TypeInfo`` based on a sequence of types. 
 
        Types can be actual types, strings, or anything else accepted by 
        :meth:`from_type_hint`. If the sequence contains just one type, 
        a ``TypeInfo`` created based on it is returned. If there are more 
        types, the returned ``TypeInfo`` represents a union. Using an empty 
        sequence is an error. 
 
        Use :meth:`from_type_hint` if other types than sequences need to 
        supported. 
        &quot;&quot;&quot;</span>
        <span class="s1">infos </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">sequence</span><span class="s3">:</span>
            <span class="s1">info </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_type_hint</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">info</span><span class="s3">.</span><span class="s1">is_union</span><span class="s3">:</span>
                <span class="s1">infos</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">nested</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">infos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">info</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">infos</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">infos</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">cls</span><span class="s3">(</span><span class="s5">&quot;Union&quot;</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">=</span><span class="s1">infos</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_variable</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">variable</span><span class="s3">: </span><span class="s5">&quot;str|VariableMatch&quot;</span><span class="s3">,</span>
        <span class="s1">handle_list_and_dict</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;TypeInfo&quot;</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Construct a ``TypeInfo`` based on a variable. 
 
        Type can be specified using syntax like ``${x: int}``. 
 
        :param variable: Variable as a string or as an already parsed 
            ``VariableMatch`` object. 
        :param handle_list_and_dict: When ``True``, types in list and dictionary 
            variables get ``list[]`` and ``dict[]`` decoration implicitly. 
            For example, ``@{x: int}``, ``&amp;{x: int}`` and ``&amp;{x: str=int}`` 
            yield types ``list[int]``, ``dict[Any, int]`` and ``dict[str, int]``, 
            respectively. 
        :raises: ``DataError`` if variable has an unrecognized type. Variable 
            not having a type is not an error. 
 
        New in Robot Framework 7.3. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">variable </span><span class="s3">= </span><span class="s1">search_variable</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">, </span><span class="s1">parse_type</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">variable</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s3">()</span>
        <span class="s1">type_ </span><span class="s3">= </span><span class="s1">variable</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s2">if </span><span class="s1">handle_list_and_dict</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">variable</span><span class="s3">.</span><span class="s1">identifier </span><span class="s3">== </span><span class="s5">&quot;@&quot;</span><span class="s3">:</span>
                <span class="s1">type_ </span><span class="s3">= </span><span class="s5">f&quot;list[</span><span class="s2">{</span><span class="s1">type_</span><span class="s2">}</span><span class="s5">]&quot;</span>
            <span class="s2">elif </span><span class="s1">variable</span><span class="s3">.</span><span class="s1">identifier </span><span class="s3">== </span><span class="s5">&quot;&amp;&quot;</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s5">&quot;=&quot; </span><span class="s2">in </span><span class="s1">type_</span><span class="s3">:</span>
                    <span class="s1">kt</span><span class="s3">, </span><span class="s1">vt </span><span class="s3">= </span><span class="s1">type_</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;=&quot;</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">kt</span><span class="s3">, </span><span class="s1">vt </span><span class="s3">= </span><span class="s5">&quot;Any&quot;</span><span class="s3">, </span><span class="s1">type_</span>
                <span class="s1">type_ </span><span class="s3">= </span><span class="s5">f&quot;dict[</span><span class="s2">{</span><span class="s1">kt</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">vt</span><span class="s2">}</span><span class="s5">]&quot;</span>
        <span class="s1">info </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">from_string</span><span class="s3">(</span><span class="s1">type_</span><span class="s3">)</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">_validate_var_type</span><span class="s3">(</span><span class="s1">info</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">info</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_validate_var_type</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">info</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">DataError</span><span class="s3">(</span><span class="s5">f&quot;Unrecognized type '</span><span class="s2">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">'.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">info</span><span class="s3">.</span><span class="s1">nested </span><span class="s2">and </span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not </span><span class="s1">Literal</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">nested </span><span class="s2">in </span><span class="s1">info</span><span class="s3">.</span><span class="s1">nested</span><span class="s3">:</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">_validate_var_type</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">convert</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s5">&quot;str|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">custom_converters</span><span class="s3">: </span><span class="s5">&quot;CustomArgumentConverters|dict|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">languages</span><span class="s3">: </span><span class="s5">&quot;LanguagesLike&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s5">&quot;Argument&quot;</span><span class="s3">,</span>
        <span class="s1">allow_unknown</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; object</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Convert ``value`` based on type information this ``TypeInfo`` contains. 
 
        :param value: Value to convert. 
        :param name: Name of the argument or other thing to convert. 
            Used only for error reporting. 
        :param custom_converters: Custom argument converters. 
        :param languages: Language configuration. During execution, uses the 
            current language configuration by default. 
        :param kind: Type of the thing to be converted. 
            Used only for error reporting. 
        :param allow_unknown: If ``False``, a ``TypeError`` is raised if there 
            is no converter for this type or to its nested types. If ``True``, 
            conversion returns the original value instead. 
        :raises: ``ValueError`` if conversion fails and ``TypeError`` if there is 
            no converter for this type and unknown converters are not accepted. 
        :return: Converted value. 
        &quot;&quot;&quot;</span>
        <span class="s1">converter </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_converter</span><span class="s3">(</span><span class="s1">custom_converters</span><span class="s3">, </span><span class="s1">languages</span><span class="s3">, </span><span class="s1">allow_unknown</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">converter</span><span class="s3">.</span><span class="s1">convert</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_converter</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">custom_converters</span><span class="s3">: </span><span class="s5">&quot;CustomArgumentConverters|dict|None&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">languages</span><span class="s3">: </span><span class="s5">&quot;LanguagesLike&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">allow_unknown</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; TypeConverter</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Get argument converter for this ``TypeInfo``. 
 
        :param custom_converters: Custom argument converters. 
        :param languages: Language configuration. During execution, uses the 
            current language configuration by default. 
        :param allow_unknown: If ``False``, a ``TypeError`` is raised if there 
            is no converter for this type or to its nested types. If ``True``, 
            a special ``UnknownConverter`` is returned instead. 
        :raises: ``TypeError`` if there is no converter and unknown converters 
            are not accepted. 
        :return: ``TypeConverter``. 
 
        The :meth:`convert` method handles the common conversion case, but this 
        method can be used if the converter is needed multiple times or its 
        needed also for other purposes than conversion. 
 
        New in Robot Framework 7.2. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">custom_converters</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
            <span class="s1">custom_converters </span><span class="s3">= </span><span class="s1">CustomArgumentConverters</span><span class="s3">.</span><span class="s1">from_dict</span><span class="s3">(</span><span class="s1">custom_converters</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">languages </span><span class="s2">and </span><span class="s1">EXECUTION_CONTEXTS</span><span class="s3">.</span><span class="s1">current</span><span class="s3">:</span>
            <span class="s1">languages </span><span class="s3">= </span><span class="s1">EXECUTION_CONTEXTS</span><span class="s3">.</span><span class="s1">current</span><span class="s3">.</span><span class="s1">languages</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">languages</span><span class="s3">, </span><span class="s1">Languages</span><span class="s3">):</span>
            <span class="s1">languages </span><span class="s3">= </span><span class="s1">Languages</span><span class="s3">(</span><span class="s1">languages</span><span class="s3">)</span>
        <span class="s1">converter </span><span class="s3">= </span><span class="s1">TypeConverter</span><span class="s3">.</span><span class="s1">converter_for</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">custom_converters</span><span class="s3">, </span><span class="s1">languages</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">allow_unknown</span><span class="s3">:</span>
            <span class="s1">converter</span><span class="s3">.</span><span class="s1">validate</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">converter</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_union</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s5">&quot; | &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s2">or </span><span class="s5">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nested </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">name</span>
        <span class="s1">nested </span><span class="s3">= </span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nested</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">nested</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s2">is not None</span>


<span class="s2">class </span><span class="s1">TypedDictInfo</span><span class="s3">(</span><span class="s1">TypeInfo</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Represents ``TypedDict`` used as an argument.&quot;&quot;&quot;</span>

    <span class="s1">is_typed_dict </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s5">&quot;annotations&quot;</span><span class="s3">, </span><span class="s5">&quot;required&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">type</span><span class="s3">: </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
        <span class="s1">type_hints </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_type_hints</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s0"># __required_keys__ is new in Python 3.9.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">required </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s5">&quot;__required_keys__&quot;</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">())</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_handle_typing_extensions_required_and_not_required</span><span class="s3">(</span><span class="s1">type_hints</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">annotations </span><span class="s3">= {</span>
            <span class="s1">name</span><span class="s3">: </span><span class="s1">TypeInfo</span><span class="s3">.</span><span class="s1">from_type_hint</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">hint </span><span class="s2">in </span><span class="s1">type_hints</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">_get_type_hints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s5">&quot;dict[str, Any]&quot;</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">get_type_hints</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">type</span><span class="s3">.</span><span class="s1">__annotations__</span>

    <span class="s2">def </span><span class="s1">_handle_typing_extensions_required_and_not_required</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type_hints</span><span class="s3">):</span>
        <span class="s0"># NotRequired and Required are handled automatically by Python 3.11 and newer,</span>
        <span class="s0"># but with older they appear in type hints and need to be handled separately.</span>
        <span class="s1">required </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">required</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">hint </span><span class="s2">in </span><span class="s1">type_hints</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">origin </span><span class="s3">= </span><span class="s1">get_origin</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">Required</span><span class="s3">:</span>
                <span class="s1">required</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
                <span class="s1">type_hints</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">origin </span><span class="s2">is </span><span class="s1">NotRequired</span><span class="s3">:</span>
                <span class="s1">required</span><span class="s3">.</span><span class="s1">discard</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
                <span class="s1">type_hints</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">required </span><span class="s3">= </span><span class="s1">frozenset</span><span class="s3">(</span><span class="s1">required</span><span class="s3">)</span>
</pre>
</body>
</html>