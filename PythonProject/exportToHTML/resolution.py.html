<html>
<head>
<title>resolution.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolution.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Generic</span>

<span class="s0">from </span><span class="s2">..</span><span class="s1">structs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">CT</span><span class="s2">,</span>
    <span class="s1">KT</span><span class="s2">,</span>
    <span class="s1">RT</span><span class="s2">,</span>
    <span class="s1">DirectedGraph</span><span class="s2">,</span>
    <span class="s1">IterableView</span><span class="s2">,</span>
    <span class="s1">IteratorMapping</span><span class="s2">,</span>
    <span class="s1">RequirementInformation</span><span class="s2">,</span>
    <span class="s1">State</span><span class="s2">,</span>
    <span class="s1">build_iter_view</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">abstract </span><span class="s0">import </span><span class="s1">AbstractResolver</span><span class="s2">, </span><span class="s1">Result</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">criterion </span><span class="s0">import </span><span class="s1">Criterion</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">exceptions </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">InconsistentCandidate</span><span class="s2">,</span>
    <span class="s1">RequirementsConflicted</span><span class="s2">,</span>
    <span class="s1">ResolutionImpossible</span><span class="s2">,</span>
    <span class="s1">ResolutionTooDeep</span><span class="s2">,</span>
    <span class="s1">ResolverException</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Collection</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">Mapping</span>

    <span class="s0">from </span><span class="s2">..</span><span class="s1">providers </span><span class="s0">import </span><span class="s1">AbstractProvider</span><span class="s2">, </span><span class="s1">Preference</span>
    <span class="s0">from </span><span class="s2">..</span><span class="s1">reporters </span><span class="s0">import </span><span class="s1">BaseReporter</span>

<span class="s1">_OPTIMISTIC_BACKJUMPING_RATIO</span><span class="s2">: </span><span class="s1">float </span><span class="s2">= </span><span class="s3">0.1</span>


<span class="s0">def </span><span class="s1">_build_result</span><span class="s2">(</span><span class="s1">state</span><span class="s2">: </span><span class="s1">State</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]) </span><span class="s1">-&gt; Result</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]:</span>
    <span class="s1">mapping </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span>
    <span class="s1">all_keys</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">] = {</span><span class="s1">id</span><span class="s2">(</span><span class="s1">v</span><span class="s2">): </span><span class="s1">k </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>
    <span class="s1">all_keys</span><span class="s2">[</span><span class="s1">id</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)] = </span><span class="s0">None</span>

    <span class="s1">graph</span><span class="s2">: </span><span class="s1">DirectedGraph</span><span class="s2">[</span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">] = </span><span class="s1">DirectedGraph</span><span class="s2">()</span>
    <span class="s1">graph</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)  </span><span class="s4"># Sentinel as root dependencies' parent.</span>

    <span class="s1">connected</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">] = {</span><span class="s0">None</span><span class="s2">}</span>
    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion </span><span class="s0">in </span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s0">if not </span><span class="s1">_has_route_to_root</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">all_keys</span><span class="s2">, </span><span class="s1">connected</span><span class="s2">):</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">graph</span><span class="s2">:</span>
            <span class="s1">graph</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">iter_parent</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">pkey </span><span class="s2">= </span><span class="s1">all_keys</span><span class="s2">[</span><span class="s1">id</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">pkey </span><span class="s0">not in </span><span class="s1">graph</span><span class="s2">:</span>
                <span class="s1">graph</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">pkey</span><span class="s2">)</span>
            <span class="s1">graph</span><span class="s2">.</span><span class="s1">connect</span><span class="s2">(</span><span class="s1">pkey</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Result</span><span class="s2">(</span>
        <span class="s1">mapping</span><span class="s2">={</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">connected</span><span class="s2">},</span>
        <span class="s1">graph</span><span class="s2">=</span><span class="s1">graph</span><span class="s2">,</span>
        <span class="s1">criteria</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">Resolution</span><span class="s2">(</span><span class="s1">Generic</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]):</span>
    <span class="s5">&quot;&quot;&quot;Stateful resolution object. 
 
    This is designed as a one-off object that holds information to kick start 
    the resolution process, and holds the results afterwards. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">provider</span><span class="s2">: </span><span class="s1">AbstractProvider</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">],</span>
        <span class="s1">reporter</span><span class="s2">: </span><span class="s1">BaseReporter</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_p </span><span class="s2">= </span><span class="s1">provider</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_r </span><span class="s2">= </span><span class="s1">reporter</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">State</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]] = []</span>

        <span class="s4"># Optimistic backjumping variables</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio </span><span class="s2">= </span><span class="s1">_OPTIMISTIC_BACKJUMPING_RATIO</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">State</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_start_round</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; State</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s6">&quot;state&quot;</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">_push_new_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Push a new state into history. 
 
        This new state will be used to hold resolution results of the next 
        coming round. 
        &quot;&quot;&quot;</span>
        <span class="s1">base </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">]</span>
        <span class="s1">state </span><span class="s2">= </span><span class="s1">State</span><span class="s2">(</span>
            <span class="s1">mapping</span><span class="s2">=</span><span class="s1">base</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),</span>
            <span class="s1">criteria</span><span class="s2">=</span><span class="s1">base</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),</span>
            <span class="s1">backtrack_causes</span><span class="s2">=</span><span class="s1">base</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">[:],</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_add_to_criteria</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">criteria</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">, </span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]],</span>
        <span class="s1">requirement</span><span class="s2">: </span><span class="s1">RT</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s1">CT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">adding_requirement</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">=</span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">=</span><span class="s1">parent</span><span class="s2">)</span>

        <span class="s1">identifier </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">identify</span><span class="s2">(</span><span class="s1">requirement_or_candidate</span><span class="s2">=</span><span class="s1">requirement</span><span class="s2">)</span>
        <span class="s1">criterion </span><span class="s2">= </span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">criterion</span><span class="s2">:</span>
            <span class="s1">incompatibilities </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">incompatibilities</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">incompatibilities </span><span class="s2">= []</span>

        <span class="s1">matches </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">find_matches</span><span class="s2">(</span>
            <span class="s1">identifier</span><span class="s2">=</span><span class="s1">identifier</span><span class="s2">,</span>
            <span class="s1">requirements</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                <span class="s1">criteria</span><span class="s2">,</span>
                <span class="s1">operator</span><span class="s2">.</span><span class="s1">methodcaller</span><span class="s2">(</span><span class="s6">&quot;iter_requirement&quot;</span><span class="s2">),</span>
                <span class="s2">{</span><span class="s1">identifier</span><span class="s2">: [</span><span class="s1">requirement</span><span class="s2">]},</span>
            <span class="s2">),</span>
            <span class="s1">incompatibilities</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                <span class="s1">criteria</span><span class="s2">,</span>
                <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;incompatibilities&quot;</span><span class="s2">),</span>
                <span class="s2">{</span><span class="s1">identifier</span><span class="s2">: </span><span class="s1">incompatibilities</span><span class="s2">},</span>
            <span class="s2">),</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">criterion</span><span class="s2">:</span>
            <span class="s1">information </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">information</span><span class="s2">)</span>
            <span class="s1">information</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">RequirementInformation</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">information </span><span class="s2">= [</span><span class="s1">RequirementInformation</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">)]</span>

        <span class="s1">criterion </span><span class="s2">= </span><span class="s1">Criterion</span><span class="s2">(</span>
            <span class="s1">candidates</span><span class="s2">=</span><span class="s1">build_iter_view</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">),</span>
            <span class="s1">information</span><span class="s2">=</span><span class="s1">information</span><span class="s2">,</span>
            <span class="s1">incompatibilities</span><span class="s2">=</span><span class="s1">incompatibilities</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">candidates</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RequirementsConflicted</span><span class="s2">(</span><span class="s1">criterion</span><span class="s2">)</span>
        <span class="s1">criteria</span><span class="s2">[</span><span class="s1">identifier</span><span class="s2">] = </span><span class="s1">criterion</span>

    <span class="s0">def </span><span class="s1">_remove_information_from_criteria</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">criteria</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">, </span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]], </span><span class="s1">parents</span><span class="s2">: </span><span class="s1">Collection</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Remove information from parents of criteria. 
 
        Concretely, removes all values from each criterion's ``information`` 
        field that have one of ``parents`` as provider of the requirement. 
 
        :param criteria: The criteria to update. 
        :param parents: Identifiers for which to remove information from all criteria. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">parents</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion </span><span class="s0">in </span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">criteria</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">Criterion</span><span class="s2">(</span>
                <span class="s1">criterion</span><span class="s2">.</span><span class="s1">candidates</span><span class="s2">,</span>
                <span class="s2">[</span>
                    <span class="s1">information</span>
                    <span class="s0">for </span><span class="s1">information </span><span class="s0">in </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">information</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">information</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">is None</span>
                        <span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">identify</span><span class="s2">(</span><span class="s1">information</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">) </span><span class="s0">not in </span><span class="s1">parents</span>
                    <span class="s2">)</span>
                <span class="s2">],</span>
                <span class="s1">criterion</span><span class="s2">.</span><span class="s1">incompatibilities</span><span class="s2">,</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_preference</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">KT</span><span class="s2">) </span><span class="s1">-&gt; Preference</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">get_preference</span><span class="s2">(</span>
            <span class="s1">identifier</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">resolutions</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">,</span>
            <span class="s1">candidates</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;candidates&quot;</span><span class="s2">),</span>
            <span class="s2">),</span>
            <span class="s1">information</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;information&quot;</span><span class="s2">),</span>
            <span class="s2">),</span>
            <span class="s1">backtrack_causes</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_is_current_pin_satisfying</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">KT</span><span class="s2">, </span><span class="s1">criterion</span><span class="s2">: </span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">current_pin </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">all</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">is_satisfied_by</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">=</span><span class="s1">r</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">=</span><span class="s1">current_pin</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">iter_requirement</span><span class="s2">()</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_updated_criteria</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">: </span><span class="s1">CT</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">, </span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]]:</span>
        <span class="s1">criteria </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">requirement </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">get_dependencies</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">=</span><span class="s1">candidate</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_to_criteria</span><span class="s2">(</span><span class="s1">criteria</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">=</span><span class="s1">candidate</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">criteria</span>

    <span class="s0">def </span><span class="s1">_attempt_to_pin_criterion</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">KT</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]]:</span>
        <span class="s1">criterion </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>

        <span class="s1">causes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]] = []</span>
        <span class="s0">for </span><span class="s1">candidate </span><span class="s0">in </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">candidates</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">criteria </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_updated_criteria</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">RequirementsConflicted </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">rejecting_candidate</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">criterion</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">)</span>
                <span class="s1">causes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">criterion</span><span class="s2">)</span>
                <span class="s0">continue</span>

            <span class="s4"># Check the newly-pinned candidate actually works. This should</span>
            <span class="s4"># always pass under normal circumstances, but in the case of a</span>
            <span class="s4"># faulty provider, we will raise an error to notify the implementer</span>
            <span class="s4"># to fix find_matches() and/or is_satisfied_by().</span>
            <span class="s1">satisfied </span><span class="s2">= </span><span class="s1">all</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">is_satisfied_by</span><span class="s2">(</span><span class="s1">requirement</span><span class="s2">=</span><span class="s1">r</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">=</span><span class="s1">candidate</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">iter_requirement</span><span class="s2">()</span>
            <span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">satisfied</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">InconsistentCandidate</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">, </span><span class="s1">criterion</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">pinning</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">=</span><span class="s1">candidate</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">criteria</span><span class="s2">)</span>

            <span class="s4"># Put newly-pinned candidate at the end. This is essential because</span>
            <span class="s4"># backtracking looks at this mapping to get the last pin.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">candidate</span>

            <span class="s0">return </span><span class="s2">[]</span>

        <span class="s4"># All candidates tried, nothing works. This criterion is a dead</span>
        <span class="s4"># end, signal for backtracking.</span>
        <span class="s0">return </span><span class="s1">causes</span>

    <span class="s0">def </span><span class="s1">_patch_criteria</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">incompatibilities_from_broken</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">CT</span><span class="s2">]]]</span>
    <span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s4"># Create a new state from the last known-to-work one, and apply</span>
        <span class="s4"># the previously gathered incompatibility information.</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">incompatibilities </span><span class="s0">in </span><span class="s1">incompatibilities_from_broken</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">incompatibilities</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">criterion </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">matches </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">find_matches</span><span class="s2">(</span>
                <span class="s1">identifier</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                <span class="s1">requirements</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                    <span class="s1">operator</span><span class="s2">.</span><span class="s1">methodcaller</span><span class="s2">(</span><span class="s6">&quot;iter_requirement&quot;</span><span class="s2">),</span>
                <span class="s2">),</span>
                <span class="s1">incompatibilities</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                    <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;incompatibilities&quot;</span><span class="s2">),</span>
                    <span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">incompatibilities</span><span class="s2">},</span>
                <span class="s2">),</span>
            <span class="s2">)</span>
            <span class="s1">candidates</span><span class="s2">: </span><span class="s1">IterableView</span><span class="s2">[</span><span class="s1">CT</span><span class="s2">] = </span><span class="s1">build_iter_view</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">candidates</span><span class="s2">:</span>
                <span class="s0">return False</span>
            <span class="s1">incompatibilities</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">incompatibilities</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">Criterion</span><span class="s2">(</span>
                <span class="s1">candidates</span><span class="s2">=</span><span class="s1">candidates</span><span class="s2">,</span>
                <span class="s1">information</span><span class="s2">=</span><span class="s1">list</span><span class="s2">(</span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">information</span><span class="s2">),</span>
                <span class="s1">incompatibilities</span><span class="s2">=</span><span class="s1">incompatibilities</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_save_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Save states for potential rollback if optimistic backjumping fails.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states </span><span class="s2">= [</span>
                <span class="s1">State</span><span class="s2">(</span>
                    <span class="s1">mapping</span><span class="s2">=</span><span class="s1">s</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),</span>
                    <span class="s1">criteria</span><span class="s2">=</span><span class="s1">s</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),</span>
                    <span class="s1">backtrack_causes</span><span class="s2">=</span><span class="s1">s</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">[:],</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span>
            <span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_rollback_states</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Rollback states and disable optimistic backjumping.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio </span><span class="s2">= </span><span class="s3">0.0</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_states </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_backjump</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">causes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">RequirementInformation</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]]) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Perform backjumping. 
 
        When we enter here, the stack is like this:: 
 
            [ state Z ] 
            [ state Y ] 
            [ state X ] 
            .... earlier states are irrelevant. 
 
        1. No pins worked for Z, so it does not have a pin. 
        2. We want to reset state Y to unpinned, and pin another candidate. 
        3. State X holds what state Y was before the pin, but does not 
           have the incompatibility information gathered in state Y. 
 
        Each iteration of the loop will: 
 
        1.  Identify Z. The incompatibility is not always caused by the latest 
            state. For example, given three requirements A, B and C, with 
            dependencies A1, B1 and C1, where A1 and B1 are incompatible: the 
            last state might be related to C, so we want to discard the 
            previous state. 
        2.  Discard Z. 
        3.  Discard Y but remember its incompatibility information gathered 
            previously, and the failure we're dealing with right now. 
        4.  Push a new state Y' based on X, and apply the incompatibility 
            information from Y to Y'. 
        5a. If this causes Y' to conflict, we need to backtrack again. Make Y' 
            the new Z and go back to step 2. 
        5b. If the incompatibilities apply cleanly, end backtracking. 
        &quot;&quot;&quot;</span>
        <span class="s1">incompatible_reqs</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">CT </span><span class="s2">| </span><span class="s1">RT</span><span class="s2">] = </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">chain</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">causes </span><span class="s0">if </span><span class="s1">c</span><span class="s2">.</span><span class="s1">parent </span><span class="s0">is not None</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">requirement </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">causes</span><span class="s2">),</span>
        <span class="s2">)</span>
        <span class="s1">incompatible_deps </span><span class="s2">= {</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">identify</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">incompatible_reqs</span><span class="s2">}</span>
        <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">) &gt;= </span><span class="s3">3</span><span class="s2">:</span>
            <span class="s4"># Remove the state that triggered backtracking.</span>
            <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">]</span>

            <span class="s4"># Optimistically backtrack to a state that caused the incompatibility</span>
            <span class="s1">broken_state </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s4"># Retrieve the last candidate pin and known incompatibilities.</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">broken_state </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
                    <span class="s1">name</span><span class="s2">, </span><span class="s1">candidate </span><span class="s2">= </span><span class="s1">broken_state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">popitem</span><span class="s2">()</span>
                <span class="s0">except </span><span class="s2">(</span><span class="s1">IndexError</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ResolutionImpossible</span><span class="s2">(</span><span class="s1">causes</span><span class="s2">) </span><span class="s0">from None</span>

                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s0">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio</span>
                    <span class="s0">and </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">incompatible_deps</span>
                <span class="s2">):</span>
                    <span class="s4"># For safe backjumping only backjump if the current dependency</span>
                    <span class="s4"># is not the same as the incompatible dependency</span>
                    <span class="s0">break</span>

                <span class="s4"># On the first time a non-safe backjump is done the state</span>
                <span class="s4"># is saved so we can restore it later if the resolution fails</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio</span>
                    <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states </span><span class="s0">is None</span>
                    <span class="s0">and </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">incompatible_deps</span>
                <span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_state</span><span class="s2">()</span>

                <span class="s4"># If the current dependencies and the incompatible dependencies</span>
                <span class="s4"># are overlapping then we have likely found a cause of the</span>
                <span class="s4"># incompatibility</span>
                <span class="s1">current_dependencies </span><span class="s2">= {</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">identify</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">get_dependencies</span><span class="s2">(</span><span class="s1">candidate</span><span class="s2">)</span>
                <span class="s2">}</span>
                <span class="s0">if not </span><span class="s1">current_dependencies</span><span class="s2">.</span><span class="s1">isdisjoint</span><span class="s2">(</span><span class="s1">incompatible_deps</span><span class="s2">):</span>
                    <span class="s0">break</span>

                <span class="s4"># Fallback: We should not backtrack to the point where</span>
                <span class="s4"># broken_state.mapping is empty, so stop backtracking for</span>
                <span class="s4"># a chance for the resolution to recover</span>
                <span class="s0">if not </span><span class="s1">broken_state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">:</span>
                    <span class="s0">break</span>

            <span class="s1">incompatibilities_from_broken </span><span class="s2">= [</span>
                <span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">list</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">incompatibilities</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">broken_state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
            <span class="s2">]</span>

            <span class="s4"># Also mark the newly known incompatibility.</span>
            <span class="s1">incompatibilities_from_broken</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">name</span><span class="s2">, [</span><span class="s1">candidate</span><span class="s2">]))</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_push_new_state</span><span class="s2">()</span>
            <span class="s1">success </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_patch_criteria</span><span class="s2">(</span><span class="s1">incompatibilities_from_broken</span><span class="s2">)</span>

            <span class="s4"># It works! Let's work on this new state.</span>
            <span class="s0">if </span><span class="s1">success</span><span class="s2">:</span>
                <span class="s0">return True</span>

            <span class="s4"># State does not work after applying known incompatibilities.</span>
            <span class="s4"># Try the still previous state.</span>

        <span class="s4"># No way to backtrack anymore.</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_extract_causes</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">criteron</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]]</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">RequirementInformation</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot;Extract causes from list of criterion and deduplicate&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">({</span><span class="s1">id</span><span class="s2">(</span><span class="s1">i</span><span class="s2">): </span><span class="s1">i </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">criteron </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">c</span><span class="s2">.</span><span class="s1">information</span><span class="s2">}.</span><span class="s1">values</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">resolve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">requirements</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">], </span><span class="s1">max_rounds</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; State</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_states</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s6">&quot;already resolved&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">starting</span><span class="s2">()</span>

        <span class="s4"># Initialize the root state.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_states </span><span class="s2">= [</span>
            <span class="s1">State</span><span class="s2">(</span>
                <span class="s1">mapping</span><span class="s2">=</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">OrderedDict</span><span class="s2">(),</span>
                <span class="s1">criteria</span><span class="s2">={},</span>
                <span class="s1">backtrack_causes</span><span class="s2">=[],</span>
            <span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">requirements</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_to_criteria</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">RequirementsConflicted </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ResolutionImpossible</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">criterion</span><span class="s2">.</span><span class="s1">information</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

        <span class="s4"># The root state is saved as a sentinel so the first ever pin can have</span>
        <span class="s4"># something to backtrack to if it fails. The root state is basically</span>
        <span class="s4"># pinning the virtual &quot;root&quot; package in the graph.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_push_new_state</span><span class="s2">()</span>

        <span class="s4"># Variables for optimistic backjumping</span>
        <span class="s1">optimistic_rounds_cutoff</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">optimistic_backjumping_start_round</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">for </span><span class="s1">round_index </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">max_rounds</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">starting_round</span><span class="s2">(</span><span class="s1">index</span><span class="s2">=</span><span class="s1">round_index</span><span class="s2">)</span>

            <span class="s4"># Handle if optimistic backjumping has been running for too long</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">optimistic_backjumping_start_round </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">optimistic_backjumping_start_round </span><span class="s2">= </span><span class="s1">round_index</span>
                    <span class="s1">optimistic_rounds_cutoff </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span>
                        <span class="s2">(</span><span class="s1">max_rounds </span><span class="s2">- </span><span class="s1">round_index</span><span class="s2">) * </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio</span>
                    <span class="s2">)</span>

                    <span class="s0">if </span><span class="s1">optimistic_rounds_cutoff </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_rollback_states</span><span class="s2">()</span>
                        <span class="s0">continue</span>
                <span class="s0">elif </span><span class="s1">optimistic_rounds_cutoff </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">round_index </span><span class="s2">- </span><span class="s1">optimistic_backjumping_start_round</span>
                        <span class="s2">&gt;= </span><span class="s1">optimistic_rounds_cutoff</span>
                    <span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_rollback_states</span><span class="s2">()</span>
                        <span class="s0">continue</span>

            <span class="s1">unsatisfied_names </span><span class="s2">= [</span>
                <span class="s1">key</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_is_current_pin_satisfying</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion</span><span class="s2">)</span>
            <span class="s2">]</span>

            <span class="s4"># All criteria are accounted for. Nothing more to pin, we are done!</span>
            <span class="s0">if not </span><span class="s1">unsatisfied_names</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">ending</span><span class="s2">(</span><span class="s1">state</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span>

            <span class="s4"># keep track of satisfied names to calculate diff after pinning</span>
            <span class="s1">satisfied_names </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">unsatisfied_names</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">unsatisfied_names</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s1">narrowed_unstatisfied_names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_p</span><span class="s2">.</span><span class="s1">narrow_requirement_selection</span><span class="s2">(</span>
                        <span class="s1">identifiers</span><span class="s2">=</span><span class="s1">unsatisfied_names</span><span class="s2">,</span>
                        <span class="s1">resolutions</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">,</span>
                        <span class="s1">candidates</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                            <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;candidates&quot;</span><span class="s2">),</span>
                        <span class="s2">),</span>
                        <span class="s1">information</span><span class="s2">=</span><span class="s1">IteratorMapping</span><span class="s2">(</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">,</span>
                            <span class="s1">operator</span><span class="s2">.</span><span class="s1">attrgetter</span><span class="s2">(</span><span class="s6">&quot;information&quot;</span><span class="s2">),</span>
                        <span class="s2">),</span>
                        <span class="s1">backtrack_causes</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">narrowed_unstatisfied_names </span><span class="s2">= </span><span class="s1">unsatisfied_names</span>

            <span class="s4"># If there are no unsatisfied names use unsatisfied names</span>
            <span class="s0">if not </span><span class="s1">narrowed_unstatisfied_names</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s6">&quot;narrow_requirement_selection returned 0 names&quot;</span><span class="s2">)</span>

            <span class="s4"># If there is only 1 unsatisfied name skip calling self._get_preference</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">narrowed_unstatisfied_names</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s4"># Choose the most preferred unpinned criterion to try.</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">narrowed_unstatisfied_names</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_preference</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">narrowed_unstatisfied_names</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>

            <span class="s1">failure_criterion </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attempt_to_pin_criterion</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">failure_criterion</span><span class="s2">:</span>
                <span class="s1">causes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_extract_causes</span><span class="s2">(</span><span class="s1">failure_criterion</span><span class="s2">)</span>
                <span class="s4"># Backjump if pinning fails. The backjump process puts us in</span>
                <span class="s4"># an unpinned state, so we can work on it in the next round.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">resolving_conflicts</span><span class="s2">(</span><span class="s1">causes</span><span class="s2">=</span><span class="s1">causes</span><span class="s2">)</span>

                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">success </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backjump</span><span class="s2">(</span><span class="s1">causes</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">ResolutionImpossible</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span><span class="s2">:</span>
                        <span class="s1">failed_optimistic_backjumping </span><span class="s2">= </span><span class="s0">True</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">raise</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">failed_optimistic_backjumping </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span>
                        <span class="s0">not </span><span class="s1">success</span>
                        <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_optimistic_backjumping_ratio</span>
                        <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span>
                    <span class="s2">)</span>

                <span class="s0">if </span><span class="s1">failed_optimistic_backjumping </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_save_states</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_rollback_states</span><span class="s2">()</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">[:] = </span><span class="s1">causes</span>

                    <span class="s4"># Dead ends everywhere. Give up.</span>
                    <span class="s0">if not </span><span class="s1">success</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">ResolutionImpossible</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">backtrack_causes</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># discard as information sources any invalidated names</span>
                <span class="s4"># (unsatisfied names that were previously satisfied)</span>
                <span class="s1">newly_unsatisfied_names </span><span class="s2">= {</span>
                    <span class="s1">key</span>
                    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                    <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">satisfied_names</span>
                    <span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_is_current_pin_satisfying</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">criterion</span><span class="s2">)</span>
                <span class="s2">}</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_remove_information_from_criteria</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">.</span><span class="s1">criteria</span><span class="s2">, </span><span class="s1">newly_unsatisfied_names</span>
                <span class="s2">)</span>
                <span class="s4"># Pinning was successful. Push a new state to do another pin.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_push_new_state</span><span class="s2">()</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_r</span><span class="s2">.</span><span class="s1">ending_round</span><span class="s2">(</span><span class="s1">index</span><span class="s2">=</span><span class="s1">round_index</span><span class="s2">, </span><span class="s1">state</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">state</span><span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">ResolutionTooDeep</span><span class="s2">(</span><span class="s1">max_rounds</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Resolver</span><span class="s2">(</span><span class="s1">AbstractResolver</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]):</span>
    <span class="s5">&quot;&quot;&quot;The thing that performs the actual resolution work.&quot;&quot;&quot;</span>

    <span class="s1">base_exception </span><span class="s2">= </span><span class="s1">ResolverException</span>

    <span class="s0">def </span><span class="s1">resolve</span><span class="s2">(  </span><span class="s4"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">requirements</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">],</span>
        <span class="s1">max_rounds</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s3">100</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Result</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">, </span><span class="s1">KT</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Take a collection of constraints, spit out the resolution result. 
 
        The return value is a representation to the final resolution result. It 
        is a tuple subclass with three public members: 
 
        * `mapping`: A dict of resolved candidates. Each key is an identifier 
            of a requirement (as returned by the provider's `identify` method), 
            and the value is the resolved candidate. 
        * `graph`: A `DirectedGraph` instance representing the dependency tree. 
            The vertices are keys of `mapping`, and each edge represents *why* 
            a particular package is included. A special vertex `None` is 
            included to represent parents of user-supplied requirements. 
        * `criteria`: A dict of &quot;criteria&quot; that hold detailed information on 
            how edges in the graph are derived. Each key is an identifier of a 
            requirement, and the value is a `Criterion` instance. 
 
        The following exceptions may be raised if a resolution cannot be found: 
 
        * `ResolutionImpossible`: A resolution cannot be found for the given 
            combination of requirements. The `causes` attribute of the 
            exception is a list of (requirement, parent), giving the 
            requirements that could not be satisfied. 
        * `ResolutionTooDeep`: The dependency tree is too deeply nested and 
            the resolver gave up. This is usually caused by a circular 
            dependency, but you can try to resolve this by increasing the 
            `max_rounds` argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s1">Resolution</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">provider</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reporter</span><span class="s2">)</span>
        <span class="s1">state </span><span class="s2">= </span><span class="s1">resolution</span><span class="s2">.</span><span class="s1">resolve</span><span class="s2">(</span><span class="s1">requirements</span><span class="s2">, </span><span class="s1">max_rounds</span><span class="s2">=</span><span class="s1">max_rounds</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">_build_result</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_has_route_to_root</span><span class="s2">(</span>
    <span class="s1">criteria</span><span class="s2">: </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">KT</span><span class="s2">, </span><span class="s1">Criterion</span><span class="s2">[</span><span class="s1">RT</span><span class="s2">, </span><span class="s1">CT</span><span class="s2">]],</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">all_keys</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">],</span>
    <span class="s1">connected</span><span class="s2">: </span><span class="s1">set</span><span class="s2">[</span><span class="s1">KT </span><span class="s2">| </span><span class="s0">None</span><span class="s2">],</span>
<span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">connected</span><span class="s2">:</span>
        <span class="s0">return True</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">criteria</span><span class="s2">:</span>
        <span class="s0">return False</span>
    <span class="s0">assert </span><span class="s1">key </span><span class="s0">is not None</span>
    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">criteria</span><span class="s2">[</span><span class="s1">key</span><span class="s2">].</span><span class="s1">iter_parent</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">pkey </span><span class="s2">= </span><span class="s1">all_keys</span><span class="s2">[</span><span class="s1">id</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">pkey </span><span class="s0">in </span><span class="s1">connected</span><span class="s2">:</span>
            <span class="s1">connected</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s0">return True</span>
        <span class="s0">if </span><span class="s1">_has_route_to_root</span><span class="s2">(</span><span class="s1">criteria</span><span class="s2">, </span><span class="s1">pkey</span><span class="s2">, </span><span class="s1">all_keys</span><span class="s2">, </span><span class="s1">connected</span><span class="s2">):</span>
            <span class="s1">connected</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s0">return True</span>
    <span class="s0">return False</span>
</pre>
</body>
</html>